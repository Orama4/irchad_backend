
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model EndUser
 * 
 */
export type EndUser = $Result.DefaultSelection<Prisma.$EndUserPayload>
/**
 * Model Helper
 * 
 */
export type Helper = $Result.DefaultSelection<Prisma.$HelperPayload>
/**
 * Model Commercial
 * 
 */
export type Commercial = $Result.DefaultSelection<Prisma.$CommercialPayload>
/**
 * Model Maintainer
 * 
 */
export type Maintainer = $Result.DefaultSelection<Prisma.$MaintainerPayload>
/**
 * Model Decider
 * 
 */
export type Decider = $Result.DefaultSelection<Prisma.$DeciderPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model UserDeviceHistory
 * 
 */
export type UserDeviceHistory = $Result.DefaultSelection<Prisma.$UserDeviceHistoryPayload>
/**
 * Model Environment
 * 
 */
export type Environment = $Result.DefaultSelection<Prisma.$EnvironmentPayload>
/**
 * Model EnvUser
 * 
 */
export type EnvUser = $Result.DefaultSelection<Prisma.$EnvUserPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model POI
 * 
 */
export type POI = $Result.DefaultSelection<Prisma.$POIPayload>
/**
 * Model Obstacle
 * 
 */
export type Obstacle = $Result.DefaultSelection<Prisma.$ObstaclePayload>
/**
 * Model Itinerary
 * 
 */
export type Itinerary = $Result.DefaultSelection<Prisma.$ItineraryPayload>
/**
 * Model HelpRequest
 * 
 */
export type HelpRequest = $Result.DefaultSelection<Prisma.$HelpRequestPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model Intervention
 * 
 */
export type Intervention = $Result.DefaultSelection<Prisma.$InterventionPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model KPI
 * 
 */
export type KPI = $Result.DefaultSelection<Prisma.$KPIPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  super: 'super',
  normal: 'normal'
};

export type Role = (typeof Role)[keyof typeof Role]


export const DeviceType: {
  Ceinture: 'Ceinture',
  Canne_Augmenté: 'Canne_Augmenté',
  Lunnettes_Connectées: 'Lunnettes_Connectées'
};

export type DeviceType = (typeof DeviceType)[keyof typeof DeviceType]


export const DeviceStatus: {
  connected: 'connected',
  disconnected: 'disconnected',
  under_maintenance: 'under_maintenance',
  en_panne: 'en_panne'
};

export type DeviceStatus = (typeof DeviceStatus)[keyof typeof DeviceStatus]


export const ZoneType: {
  Zone_de_circulation: 'Zone_de_circulation',
  Zone_de_travail: 'Zone_de_travail',
  Zone_de_service: 'Zone_de_service',
  Zone_interdite: 'Zone_interdite',
  Zone_danger: 'Zone_danger'
};

export type ZoneType = (typeof ZoneType)[keyof typeof ZoneType]


export const POICategory: {
  acceuil: 'acceuil',
  bureau: 'bureau',
  sortie: 'sortie'
};

export type POICategory = (typeof POICategory)[keyof typeof POICategory]


export const InterventionType: {
  preventive: 'preventive',
  curative: 'curative'
};

export type InterventionType = (typeof InterventionType)[keyof typeof InterventionType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type DeviceType = $Enums.DeviceType

export const DeviceType: typeof $Enums.DeviceType

export type DeviceStatus = $Enums.DeviceStatus

export const DeviceStatus: typeof $Enums.DeviceStatus

export type ZoneType = $Enums.ZoneType

export const ZoneType: typeof $Enums.ZoneType

export type POICategory = $Enums.POICategory

export const POICategory: typeof $Enums.POICategory

export type InterventionType = $Enums.InterventionType

export const InterventionType: typeof $Enums.InterventionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.endUser`: Exposes CRUD operations for the **EndUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EndUsers
    * const endUsers = await prisma.endUser.findMany()
    * ```
    */
  get endUser(): Prisma.EndUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helper`: Exposes CRUD operations for the **Helper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Helpers
    * const helpers = await prisma.helper.findMany()
    * ```
    */
  get helper(): Prisma.HelperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commercial`: Exposes CRUD operations for the **Commercial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commercials
    * const commercials = await prisma.commercial.findMany()
    * ```
    */
  get commercial(): Prisma.CommercialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintainer`: Exposes CRUD operations for the **Maintainer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintainers
    * const maintainers = await prisma.maintainer.findMany()
    * ```
    */
  get maintainer(): Prisma.MaintainerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.decider`: Exposes CRUD operations for the **Decider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deciders
    * const deciders = await prisma.decider.findMany()
    * ```
    */
  get decider(): Prisma.DeciderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userDeviceHistory`: Exposes CRUD operations for the **UserDeviceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDeviceHistories
    * const userDeviceHistories = await prisma.userDeviceHistory.findMany()
    * ```
    */
  get userDeviceHistory(): Prisma.UserDeviceHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.environment`: Exposes CRUD operations for the **Environment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Environments
    * const environments = await prisma.environment.findMany()
    * ```
    */
  get environment(): Prisma.EnvironmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.envUser`: Exposes CRUD operations for the **EnvUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnvUsers
    * const envUsers = await prisma.envUser.findMany()
    * ```
    */
  get envUser(): Prisma.EnvUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOI`: Exposes CRUD operations for the **POI** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POIS
    * const pOIS = await prisma.pOI.findMany()
    * ```
    */
  get pOI(): Prisma.POIDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.obstacle`: Exposes CRUD operations for the **Obstacle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Obstacles
    * const obstacles = await prisma.obstacle.findMany()
    * ```
    */
  get obstacle(): Prisma.ObstacleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itinerary`: Exposes CRUD operations for the **Itinerary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itineraries
    * const itineraries = await prisma.itinerary.findMany()
    * ```
    */
  get itinerary(): Prisma.ItineraryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helpRequest`: Exposes CRUD operations for the **HelpRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpRequests
    * const helpRequests = await prisma.helpRequest.findMany()
    * ```
    */
  get helpRequest(): Prisma.HelpRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intervention`: Exposes CRUD operations for the **Intervention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interventions
    * const interventions = await prisma.intervention.findMany()
    * ```
    */
  get intervention(): Prisma.InterventionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kPI`: Exposes CRUD operations for the **KPI** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KPIS
    * const kPIS = await prisma.kPI.findMany()
    * ```
    */
  get kPI(): Prisma.KPIDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    Admin: 'Admin',
    EndUser: 'EndUser',
    Helper: 'Helper',
    Commercial: 'Commercial',
    Maintainer: 'Maintainer',
    Decider: 'Decider',
    Device: 'Device',
    Notification: 'Notification',
    UserDeviceHistory: 'UserDeviceHistory',
    Environment: 'Environment',
    EnvUser: 'EnvUser',
    Zone: 'Zone',
    POI: 'POI',
    Obstacle: 'Obstacle',
    Itinerary: 'Itinerary',
    HelpRequest: 'HelpRequest',
    Sale: 'Sale',
    Intervention: 'Intervention',
    Log: 'Log',
    KPI: 'KPI'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "profile" | "admin" | "endUser" | "helper" | "commercial" | "maintainer" | "decider" | "device" | "notification" | "userDeviceHistory" | "environment" | "envUser" | "zone" | "pOI" | "obstacle" | "itinerary" | "helpRequest" | "sale" | "intervention" | "log" | "kPI"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      EndUser: {
        payload: Prisma.$EndUserPayload<ExtArgs>
        fields: Prisma.EndUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EndUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EndUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload>
          }
          findFirst: {
            args: Prisma.EndUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EndUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload>
          }
          findMany: {
            args: Prisma.EndUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload>[]
          }
          create: {
            args: Prisma.EndUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload>
          }
          createMany: {
            args: Prisma.EndUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EndUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload>[]
          }
          delete: {
            args: Prisma.EndUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload>
          }
          update: {
            args: Prisma.EndUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload>
          }
          deleteMany: {
            args: Prisma.EndUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EndUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EndUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload>[]
          }
          upsert: {
            args: Prisma.EndUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EndUserPayload>
          }
          aggregate: {
            args: Prisma.EndUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEndUser>
          }
          groupBy: {
            args: Prisma.EndUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<EndUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.EndUserCountArgs<ExtArgs>
            result: $Utils.Optional<EndUserCountAggregateOutputType> | number
          }
        }
      }
      Helper: {
        payload: Prisma.$HelperPayload<ExtArgs>
        fields: Prisma.HelperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          findFirst: {
            args: Prisma.HelperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          findMany: {
            args: Prisma.HelperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>[]
          }
          create: {
            args: Prisma.HelperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          createMany: {
            args: Prisma.HelperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>[]
          }
          delete: {
            args: Prisma.HelperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          update: {
            args: Prisma.HelperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          deleteMany: {
            args: Prisma.HelperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HelperUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>[]
          }
          upsert: {
            args: Prisma.HelperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelperPayload>
          }
          aggregate: {
            args: Prisma.HelperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelper>
          }
          groupBy: {
            args: Prisma.HelperGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelperGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelperCountArgs<ExtArgs>
            result: $Utils.Optional<HelperCountAggregateOutputType> | number
          }
        }
      }
      Commercial: {
        payload: Prisma.$CommercialPayload<ExtArgs>
        fields: Prisma.CommercialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommercialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommercialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          findFirst: {
            args: Prisma.CommercialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommercialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          findMany: {
            args: Prisma.CommercialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>[]
          }
          create: {
            args: Prisma.CommercialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          createMany: {
            args: Prisma.CommercialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommercialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>[]
          }
          delete: {
            args: Prisma.CommercialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          update: {
            args: Prisma.CommercialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          deleteMany: {
            args: Prisma.CommercialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommercialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommercialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>[]
          }
          upsert: {
            args: Prisma.CommercialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommercialPayload>
          }
          aggregate: {
            args: Prisma.CommercialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommercial>
          }
          groupBy: {
            args: Prisma.CommercialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommercialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommercialCountArgs<ExtArgs>
            result: $Utils.Optional<CommercialCountAggregateOutputType> | number
          }
        }
      }
      Maintainer: {
        payload: Prisma.$MaintainerPayload<ExtArgs>
        fields: Prisma.MaintainerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintainerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintainerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          findFirst: {
            args: Prisma.MaintainerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintainerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          findMany: {
            args: Prisma.MaintainerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>[]
          }
          create: {
            args: Prisma.MaintainerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          createMany: {
            args: Prisma.MaintainerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintainerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>[]
          }
          delete: {
            args: Prisma.MaintainerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          update: {
            args: Prisma.MaintainerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          deleteMany: {
            args: Prisma.MaintainerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintainerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintainerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>[]
          }
          upsert: {
            args: Prisma.MaintainerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintainerPayload>
          }
          aggregate: {
            args: Prisma.MaintainerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintainer>
          }
          groupBy: {
            args: Prisma.MaintainerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintainerGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintainerCountArgs<ExtArgs>
            result: $Utils.Optional<MaintainerCountAggregateOutputType> | number
          }
        }
      }
      Decider: {
        payload: Prisma.$DeciderPayload<ExtArgs>
        fields: Prisma.DeciderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeciderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeciderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          findFirst: {
            args: Prisma.DeciderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeciderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          findMany: {
            args: Prisma.DeciderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>[]
          }
          create: {
            args: Prisma.DeciderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          createMany: {
            args: Prisma.DeciderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeciderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>[]
          }
          delete: {
            args: Prisma.DeciderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          update: {
            args: Prisma.DeciderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          deleteMany: {
            args: Prisma.DeciderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeciderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeciderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>[]
          }
          upsert: {
            args: Prisma.DeciderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeciderPayload>
          }
          aggregate: {
            args: Prisma.DeciderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecider>
          }
          groupBy: {
            args: Prisma.DeciderGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeciderGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeciderCountArgs<ExtArgs>
            result: $Utils.Optional<DeciderCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      UserDeviceHistory: {
        payload: Prisma.$UserDeviceHistoryPayload<ExtArgs>
        fields: Prisma.UserDeviceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDeviceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDeviceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserDeviceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDeviceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload>
          }
          findMany: {
            args: Prisma.UserDeviceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload>[]
          }
          create: {
            args: Prisma.UserDeviceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload>
          }
          createMany: {
            args: Prisma.UserDeviceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDeviceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload>[]
          }
          delete: {
            args: Prisma.UserDeviceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload>
          }
          update: {
            args: Prisma.UserDeviceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserDeviceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDeviceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserDeviceHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload>[]
          }
          upsert: {
            args: Prisma.UserDeviceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDeviceHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserDeviceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDeviceHistory>
          }
          groupBy: {
            args: Prisma.UserDeviceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDeviceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceHistoryCountAggregateOutputType> | number
          }
        }
      }
      Environment: {
        payload: Prisma.$EnvironmentPayload<ExtArgs>
        fields: Prisma.EnvironmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvironmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvironmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          findFirst: {
            args: Prisma.EnvironmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvironmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          findMany: {
            args: Prisma.EnvironmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>[]
          }
          create: {
            args: Prisma.EnvironmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          createMany: {
            args: Prisma.EnvironmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnvironmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>[]
          }
          delete: {
            args: Prisma.EnvironmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          update: {
            args: Prisma.EnvironmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          deleteMany: {
            args: Prisma.EnvironmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnvironmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnvironmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>[]
          }
          upsert: {
            args: Prisma.EnvironmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          aggregate: {
            args: Prisma.EnvironmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnvironment>
          }
          groupBy: {
            args: Prisma.EnvironmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnvironmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvironmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnvironmentCountAggregateOutputType> | number
          }
        }
      }
      EnvUser: {
        payload: Prisma.$EnvUserPayload<ExtArgs>
        fields: Prisma.EnvUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload>
          }
          findFirst: {
            args: Prisma.EnvUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload>
          }
          findMany: {
            args: Prisma.EnvUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload>[]
          }
          create: {
            args: Prisma.EnvUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload>
          }
          createMany: {
            args: Prisma.EnvUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnvUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload>[]
          }
          delete: {
            args: Prisma.EnvUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload>
          }
          update: {
            args: Prisma.EnvUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload>
          }
          deleteMany: {
            args: Prisma.EnvUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnvUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnvUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload>[]
          }
          upsert: {
            args: Prisma.EnvUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvUserPayload>
          }
          aggregate: {
            args: Prisma.EnvUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnvUser>
          }
          groupBy: {
            args: Prisma.EnvUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnvUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvUserCountArgs<ExtArgs>
            result: $Utils.Optional<EnvUserCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      POI: {
        payload: Prisma.$POIPayload<ExtArgs>
        fields: Prisma.POIFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POIFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POIFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload>
          }
          findFirst: {
            args: Prisma.POIFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POIFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload>
          }
          findMany: {
            args: Prisma.POIFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload>[]
          }
          create: {
            args: Prisma.POICreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload>
          }
          createMany: {
            args: Prisma.POICreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POICreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload>[]
          }
          delete: {
            args: Prisma.POIDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload>
          }
          update: {
            args: Prisma.POIUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload>
          }
          deleteMany: {
            args: Prisma.POIDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POIUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.POIUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload>[]
          }
          upsert: {
            args: Prisma.POIUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POIPayload>
          }
          aggregate: {
            args: Prisma.POIAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOI>
          }
          groupBy: {
            args: Prisma.POIGroupByArgs<ExtArgs>
            result: $Utils.Optional<POIGroupByOutputType>[]
          }
          count: {
            args: Prisma.POICountArgs<ExtArgs>
            result: $Utils.Optional<POICountAggregateOutputType> | number
          }
        }
      }
      Obstacle: {
        payload: Prisma.$ObstaclePayload<ExtArgs>
        fields: Prisma.ObstacleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObstacleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObstacleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload>
          }
          findFirst: {
            args: Prisma.ObstacleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObstacleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload>
          }
          findMany: {
            args: Prisma.ObstacleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload>[]
          }
          create: {
            args: Prisma.ObstacleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload>
          }
          createMany: {
            args: Prisma.ObstacleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObstacleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload>[]
          }
          delete: {
            args: Prisma.ObstacleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload>
          }
          update: {
            args: Prisma.ObstacleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload>
          }
          deleteMany: {
            args: Prisma.ObstacleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObstacleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ObstacleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload>[]
          }
          upsert: {
            args: Prisma.ObstacleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObstaclePayload>
          }
          aggregate: {
            args: Prisma.ObstacleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObstacle>
          }
          groupBy: {
            args: Prisma.ObstacleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObstacleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObstacleCountArgs<ExtArgs>
            result: $Utils.Optional<ObstacleCountAggregateOutputType> | number
          }
        }
      }
      Itinerary: {
        payload: Prisma.$ItineraryPayload<ExtArgs>
        fields: Prisma.ItineraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItineraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItineraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findFirst: {
            args: Prisma.ItineraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItineraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findMany: {
            args: Prisma.ItineraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          create: {
            args: Prisma.ItineraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          createMany: {
            args: Prisma.ItineraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItineraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          delete: {
            args: Prisma.ItineraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          update: {
            args: Prisma.ItineraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          deleteMany: {
            args: Prisma.ItineraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItineraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItineraryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          upsert: {
            args: Prisma.ItineraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          aggregate: {
            args: Prisma.ItineraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItinerary>
          }
          groupBy: {
            args: Prisma.ItineraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItineraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItineraryCountArgs<ExtArgs>
            result: $Utils.Optional<ItineraryCountAggregateOutputType> | number
          }
        }
      }
      HelpRequest: {
        payload: Prisma.$HelpRequestPayload<ExtArgs>
        fields: Prisma.HelpRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload>
          }
          findFirst: {
            args: Prisma.HelpRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload>
          }
          findMany: {
            args: Prisma.HelpRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload>[]
          }
          create: {
            args: Prisma.HelpRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload>
          }
          createMany: {
            args: Prisma.HelpRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload>[]
          }
          delete: {
            args: Prisma.HelpRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload>
          }
          update: {
            args: Prisma.HelpRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload>
          }
          deleteMany: {
            args: Prisma.HelpRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HelpRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload>[]
          }
          upsert: {
            args: Prisma.HelpRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpRequestPayload>
          }
          aggregate: {
            args: Prisma.HelpRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpRequest>
          }
          groupBy: {
            args: Prisma.HelpRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpRequestCountArgs<ExtArgs>
            result: $Utils.Optional<HelpRequestCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      Intervention: {
        payload: Prisma.$InterventionPayload<ExtArgs>
        fields: Prisma.InterventionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterventionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterventionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findFirst: {
            args: Prisma.InterventionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterventionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findMany: {
            args: Prisma.InterventionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          create: {
            args: Prisma.InterventionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          createMany: {
            args: Prisma.InterventionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterventionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          delete: {
            args: Prisma.InterventionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          update: {
            args: Prisma.InterventionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          deleteMany: {
            args: Prisma.InterventionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterventionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterventionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          upsert: {
            args: Prisma.InterventionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          aggregate: {
            args: Prisma.InterventionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntervention>
          }
          groupBy: {
            args: Prisma.InterventionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterventionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterventionCountArgs<ExtArgs>
            result: $Utils.Optional<InterventionCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      KPI: {
        payload: Prisma.$KPIPayload<ExtArgs>
        fields: Prisma.KPIFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KPIFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KPIFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload>
          }
          findFirst: {
            args: Prisma.KPIFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KPIFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload>
          }
          findMany: {
            args: Prisma.KPIFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload>[]
          }
          create: {
            args: Prisma.KPICreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload>
          }
          createMany: {
            args: Prisma.KPICreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KPICreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload>[]
          }
          delete: {
            args: Prisma.KPIDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload>
          }
          update: {
            args: Prisma.KPIUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload>
          }
          deleteMany: {
            args: Prisma.KPIDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KPIUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KPIUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload>[]
          }
          upsert: {
            args: Prisma.KPIUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KPIPayload>
          }
          aggregate: {
            args: Prisma.KPIAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKPI>
          }
          groupBy: {
            args: Prisma.KPIGroupByArgs<ExtArgs>
            result: $Utils.Optional<KPIGroupByOutputType>[]
          }
          count: {
            args: Prisma.KPICountArgs<ExtArgs>
            result: $Utils.Optional<KPICountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    profile?: ProfileOmit
    admin?: AdminOmit
    endUser?: EndUserOmit
    helper?: HelperOmit
    commercial?: CommercialOmit
    maintainer?: MaintainerOmit
    decider?: DeciderOmit
    device?: DeviceOmit
    notification?: NotificationOmit
    userDeviceHistory?: UserDeviceHistoryOmit
    environment?: EnvironmentOmit
    envUser?: EnvUserOmit
    zone?: ZoneOmit
    pOI?: POIOmit
    obstacle?: ObstacleOmit
    itinerary?: ItineraryOmit
    helpRequest?: HelpRequestOmit
    sale?: SaleOmit
    intervention?: InterventionOmit
    log?: LogOmit
    kPI?: KPIOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    userDeviceHistories: number
    envUsers: number
    logs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    userDeviceHistories?: boolean | UserCountOutputTypeCountUserDeviceHistoriesArgs
    envUsers?: boolean | UserCountOutputTypeCountEnvUsersArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserDeviceHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDeviceHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnvUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }


  /**
   * Count Type EndUserCountOutputType
   */

  export type EndUserCountOutputType = {
    devices: number
    helpRequests: number
    mySales: number
  }

  export type EndUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devices?: boolean | EndUserCountOutputTypeCountDevicesArgs
    helpRequests?: boolean | EndUserCountOutputTypeCountHelpRequestsArgs
    mySales?: boolean | EndUserCountOutputTypeCountMySalesArgs
  }

  // Custom InputTypes
  /**
   * EndUserCountOutputType without action
   */
  export type EndUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUserCountOutputType
     */
    select?: EndUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EndUserCountOutputType without action
   */
  export type EndUserCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * EndUserCountOutputType without action
   */
  export type EndUserCountOutputTypeCountHelpRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpRequestWhereInput
  }

  /**
   * EndUserCountOutputType without action
   */
  export type EndUserCountOutputTypeCountMySalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * Count Type HelperCountOutputType
   */

  export type HelperCountOutputType = {
    endUsers: number
    helpRequests: number
  }

  export type HelperCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endUsers?: boolean | HelperCountOutputTypeCountEndUsersArgs
    helpRequests?: boolean | HelperCountOutputTypeCountHelpRequestsArgs
  }

  // Custom InputTypes
  /**
   * HelperCountOutputType without action
   */
  export type HelperCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperCountOutputType
     */
    select?: HelperCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelperCountOutputType without action
   */
  export type HelperCountOutputTypeCountEndUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EndUserWhereInput
  }

  /**
   * HelperCountOutputType without action
   */
  export type HelperCountOutputTypeCountHelpRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpRequestWhereInput
  }


  /**
   * Count Type MaintainerCountOutputType
   */

  export type MaintainerCountOutputType = {
    interventions: number
  }

  export type MaintainerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventions?: boolean | MaintainerCountOutputTypeCountInterventionsArgs
  }

  // Custom InputTypes
  /**
   * MaintainerCountOutputType without action
   */
  export type MaintainerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintainerCountOutputType
     */
    select?: MaintainerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintainerCountOutputType without action
   */
  export type MaintainerCountOutputTypeCountInterventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    sales: number
    userDeviceHistories: number
    interventions: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | DeviceCountOutputTypeCountSalesArgs
    userDeviceHistories?: boolean | DeviceCountOutputTypeCountUserDeviceHistoriesArgs
    interventions?: boolean | DeviceCountOutputTypeCountInterventionsArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountUserDeviceHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDeviceHistoryWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountInterventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
  }


  /**
   * Count Type EnvironmentCountOutputType
   */

  export type EnvironmentCountOutputType = {
    zones: number
    obstacles: number
    envUsers: number
    routes: number
  }

  export type EnvironmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | EnvironmentCountOutputTypeCountZonesArgs
    obstacles?: boolean | EnvironmentCountOutputTypeCountObstaclesArgs
    envUsers?: boolean | EnvironmentCountOutputTypeCountEnvUsersArgs
    routes?: boolean | EnvironmentCountOutputTypeCountRoutesArgs
  }

  // Custom InputTypes
  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentCountOutputType
     */
    select?: EnvironmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
  }

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountObstaclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObstacleWhereInput
  }

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountEnvUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvUserWhereInput
  }

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    pois: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pois?: boolean | ZoneCountOutputTypeCountPoisArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountPoisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POIWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    role: $Enums.Role | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    admin?: boolean | User$adminArgs<ExtArgs>
    endUser?: boolean | User$endUserArgs<ExtArgs>
    helper?: boolean | User$helperArgs<ExtArgs>
    commercial?: boolean | User$commercialArgs<ExtArgs>
    maintainer?: boolean | User$maintainerArgs<ExtArgs>
    decider?: boolean | User$deciderArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userDeviceHistories?: boolean | User$userDeviceHistoriesArgs<ExtArgs>
    envUsers?: boolean | User$envUsersArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | User$adminArgs<ExtArgs>
    endUser?: boolean | User$endUserArgs<ExtArgs>
    helper?: boolean | User$helperArgs<ExtArgs>
    commercial?: boolean | User$commercialArgs<ExtArgs>
    maintainer?: boolean | User$maintainerArgs<ExtArgs>
    decider?: boolean | User$deciderArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userDeviceHistories?: boolean | User$userDeviceHistoriesArgs<ExtArgs>
    envUsers?: boolean | User$envUsersArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
      endUser: Prisma.$EndUserPayload<ExtArgs> | null
      helper: Prisma.$HelperPayload<ExtArgs> | null
      commercial: Prisma.$CommercialPayload<ExtArgs> | null
      maintainer: Prisma.$MaintainerPayload<ExtArgs> | null
      decider: Prisma.$DeciderPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      userDeviceHistories: Prisma.$UserDeviceHistoryPayload<ExtArgs>[]
      envUsers: Prisma.$EnvUserPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      role: $Enums.Role | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    endUser<T extends User$endUserArgs<ExtArgs> = {}>(args?: Subset<T, User$endUserArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    helper<T extends User$helperArgs<ExtArgs> = {}>(args?: Subset<T, User$helperArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    commercial<T extends User$commercialArgs<ExtArgs> = {}>(args?: Subset<T, User$commercialArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    maintainer<T extends User$maintainerArgs<ExtArgs> = {}>(args?: Subset<T, User$maintainerArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    decider<T extends User$deciderArgs<ExtArgs> = {}>(args?: Subset<T, User$deciderArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    userDeviceHistories<T extends User$userDeviceHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$userDeviceHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    envUsers<T extends User$envUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$envUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.endUser
   */
  export type User$endUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    where?: EndUserWhereInput
  }

  /**
   * User.helper
   */
  export type User$helperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    where?: HelperWhereInput
  }

  /**
   * User.commercial
   */
  export type User$commercialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    where?: CommercialWhereInput
  }

  /**
   * User.maintainer
   */
  export type User$maintainerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    where?: MaintainerWhereInput
  }

  /**
   * User.decider
   */
  export type User$deciderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    where?: DeciderWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.userDeviceHistories
   */
  export type User$userDeviceHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    where?: UserDeviceHistoryWhereInput
    orderBy?: UserDeviceHistoryOrderByWithRelationInput | UserDeviceHistoryOrderByWithRelationInput[]
    cursor?: UserDeviceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDeviceHistoryScalarFieldEnum | UserDeviceHistoryScalarFieldEnum[]
  }

  /**
   * User.envUsers
   */
  export type User$envUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    where?: EnvUserWhereInput
    orderBy?: EnvUserOrderByWithRelationInput | EnvUserOrderByWithRelationInput[]
    cursor?: EnvUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvUserScalarFieldEnum | EnvUserScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    userId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    userId: number | null
  }

  export type ProfileMinAggregateOutputType = {
    userId: number | null
    firstname: string | null
    lastname: string | null
    phonenumber: string | null
    address: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    userId: number | null
    firstname: string | null
    lastname: string | null
    phonenumber: string | null
    address: string | null
  }

  export type ProfileCountAggregateOutputType = {
    userId: number
    firstname: number
    lastname: number
    phonenumber: number
    address: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    userId?: true
  }

  export type ProfileSumAggregateInputType = {
    userId?: true
  }

  export type ProfileMinAggregateInputType = {
    userId?: true
    firstname?: true
    lastname?: true
    phonenumber?: true
    address?: true
  }

  export type ProfileMaxAggregateInputType = {
    userId?: true
    firstname?: true
    lastname?: true
    phonenumber?: true
    address?: true
  }

  export type ProfileCountAggregateInputType = {
    userId?: true
    firstname?: true
    lastname?: true
    phonenumber?: true
    address?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    userId: number
    firstname: string | null
    lastname: string | null
    phonenumber: string | null
    address: string
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstname?: boolean
    lastname?: boolean
    phonenumber?: boolean
    address?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstname?: boolean
    lastname?: boolean
    phonenumber?: boolean
    address?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    firstname?: boolean
    lastname?: boolean
    phonenumber?: boolean
    address?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    userId?: boolean
    firstname?: boolean
    lastname?: boolean
    phonenumber?: boolean
    address?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "firstname" | "lastname" | "phonenumber" | "address", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      firstname: string | null
      lastname: string | null
      phonenumber: string | null
      address: string
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const profileWithUserIdOnly = await prisma.profile.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `userId`
     * const profileWithUserIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `userId`
     * const profileWithUserIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly userId: FieldRef<"Profile", 'Int'>
    readonly firstname: FieldRef<"Profile", 'String'>
    readonly lastname: FieldRef<"Profile", 'String'>
    readonly phonenumber: FieldRef<"Profile", 'String'>
    readonly address: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    userId: number | null
    role: $Enums.Role | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    role: $Enums.Role | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    role: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    role?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    role?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    userId: number
    role: $Enums.Role
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    role?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "role", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      role: $Enums.Role
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly userId: FieldRef<"Admin", 'Int'>
    readonly role: FieldRef<"Admin", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model EndUser
   */

  export type AggregateEndUser = {
    _count: EndUserCountAggregateOutputType | null
    _avg: EndUserAvgAggregateOutputType | null
    _sum: EndUserSumAggregateOutputType | null
    _min: EndUserMinAggregateOutputType | null
    _max: EndUserMaxAggregateOutputType | null
  }

  export type EndUserAvgAggregateOutputType = {
    id: number | null
    helperId: number | null
    userId: number | null
  }

  export type EndUserSumAggregateOutputType = {
    id: number | null
    helperId: number | null
    userId: number | null
  }

  export type EndUserMinAggregateOutputType = {
    id: number | null
    helperId: number | null
    status: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type EndUserMaxAggregateOutputType = {
    id: number | null
    helperId: number | null
    status: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type EndUserCountAggregateOutputType = {
    id: number
    helperId: number
    lastPos: number
    status: number
    userId: number
    createdAt: number
    _all: number
  }


  export type EndUserAvgAggregateInputType = {
    id?: true
    helperId?: true
    userId?: true
  }

  export type EndUserSumAggregateInputType = {
    id?: true
    helperId?: true
    userId?: true
  }

  export type EndUserMinAggregateInputType = {
    id?: true
    helperId?: true
    status?: true
    userId?: true
    createdAt?: true
  }

  export type EndUserMaxAggregateInputType = {
    id?: true
    helperId?: true
    status?: true
    userId?: true
    createdAt?: true
  }

  export type EndUserCountAggregateInputType = {
    id?: true
    helperId?: true
    lastPos?: true
    status?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type EndUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EndUser to aggregate.
     */
    where?: EndUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EndUsers to fetch.
     */
    orderBy?: EndUserOrderByWithRelationInput | EndUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EndUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EndUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EndUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EndUsers
    **/
    _count?: true | EndUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EndUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EndUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EndUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EndUserMaxAggregateInputType
  }

  export type GetEndUserAggregateType<T extends EndUserAggregateArgs> = {
        [P in keyof T & keyof AggregateEndUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndUser[P]>
      : GetScalarType<T[P], AggregateEndUser[P]>
  }




  export type EndUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EndUserWhereInput
    orderBy?: EndUserOrderByWithAggregationInput | EndUserOrderByWithAggregationInput[]
    by: EndUserScalarFieldEnum[] | EndUserScalarFieldEnum
    having?: EndUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EndUserCountAggregateInputType | true
    _avg?: EndUserAvgAggregateInputType
    _sum?: EndUserSumAggregateInputType
    _min?: EndUserMinAggregateInputType
    _max?: EndUserMaxAggregateInputType
  }

  export type EndUserGroupByOutputType = {
    id: number
    helperId: number | null
    lastPos: JsonValue | null
    status: string
    userId: number
    createdAt: Date
    _count: EndUserCountAggregateOutputType | null
    _avg: EndUserAvgAggregateOutputType | null
    _sum: EndUserSumAggregateOutputType | null
    _min: EndUserMinAggregateOutputType | null
    _max: EndUserMaxAggregateOutputType | null
  }

  type GetEndUserGroupByPayload<T extends EndUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EndUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EndUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EndUserGroupByOutputType[P]>
            : GetScalarType<T[P], EndUserGroupByOutputType[P]>
        }
      >
    >


  export type EndUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    helperId?: boolean
    lastPos?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    helper?: boolean | EndUser$helperArgs<ExtArgs>
    devices?: boolean | EndUser$devicesArgs<ExtArgs>
    helpRequests?: boolean | EndUser$helpRequestsArgs<ExtArgs>
    mySales?: boolean | EndUser$mySalesArgs<ExtArgs>
    _count?: boolean | EndUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endUser"]>

  export type EndUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    helperId?: boolean
    lastPos?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    helper?: boolean | EndUser$helperArgs<ExtArgs>
  }, ExtArgs["result"]["endUser"]>

  export type EndUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    helperId?: boolean
    lastPos?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    helper?: boolean | EndUser$helperArgs<ExtArgs>
  }, ExtArgs["result"]["endUser"]>

  export type EndUserSelectScalar = {
    id?: boolean
    helperId?: boolean
    lastPos?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type EndUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "helperId" | "lastPos" | "status" | "userId" | "createdAt", ExtArgs["result"]["endUser"]>
  export type EndUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    helper?: boolean | EndUser$helperArgs<ExtArgs>
    devices?: boolean | EndUser$devicesArgs<ExtArgs>
    helpRequests?: boolean | EndUser$helpRequestsArgs<ExtArgs>
    mySales?: boolean | EndUser$mySalesArgs<ExtArgs>
    _count?: boolean | EndUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EndUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    helper?: boolean | EndUser$helperArgs<ExtArgs>
  }
  export type EndUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    helper?: boolean | EndUser$helperArgs<ExtArgs>
  }

  export type $EndUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EndUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      helper: Prisma.$HelperPayload<ExtArgs> | null
      devices: Prisma.$DevicePayload<ExtArgs>[]
      helpRequests: Prisma.$HelpRequestPayload<ExtArgs>[]
      mySales: Prisma.$SalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      helperId: number | null
      lastPos: Prisma.JsonValue | null
      status: string
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["endUser"]>
    composites: {}
  }

  type EndUserGetPayload<S extends boolean | null | undefined | EndUserDefaultArgs> = $Result.GetResult<Prisma.$EndUserPayload, S>

  type EndUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EndUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EndUserCountAggregateInputType | true
    }

  export interface EndUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EndUser'], meta: { name: 'EndUser' } }
    /**
     * Find zero or one EndUser that matches the filter.
     * @param {EndUserFindUniqueArgs} args - Arguments to find a EndUser
     * @example
     * // Get one EndUser
     * const endUser = await prisma.endUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EndUserFindUniqueArgs>(args: SelectSubset<T, EndUserFindUniqueArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EndUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EndUserFindUniqueOrThrowArgs} args - Arguments to find a EndUser
     * @example
     * // Get one EndUser
     * const endUser = await prisma.endUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EndUserFindUniqueOrThrowArgs>(args: SelectSubset<T, EndUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EndUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndUserFindFirstArgs} args - Arguments to find a EndUser
     * @example
     * // Get one EndUser
     * const endUser = await prisma.endUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EndUserFindFirstArgs>(args?: SelectSubset<T, EndUserFindFirstArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EndUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndUserFindFirstOrThrowArgs} args - Arguments to find a EndUser
     * @example
     * // Get one EndUser
     * const endUser = await prisma.endUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EndUserFindFirstOrThrowArgs>(args?: SelectSubset<T, EndUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EndUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EndUsers
     * const endUsers = await prisma.endUser.findMany()
     * 
     * // Get first 10 EndUsers
     * const endUsers = await prisma.endUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const endUserWithIdOnly = await prisma.endUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EndUserFindManyArgs>(args?: SelectSubset<T, EndUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EndUser.
     * @param {EndUserCreateArgs} args - Arguments to create a EndUser.
     * @example
     * // Create one EndUser
     * const EndUser = await prisma.endUser.create({
     *   data: {
     *     // ... data to create a EndUser
     *   }
     * })
     * 
     */
    create<T extends EndUserCreateArgs>(args: SelectSubset<T, EndUserCreateArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EndUsers.
     * @param {EndUserCreateManyArgs} args - Arguments to create many EndUsers.
     * @example
     * // Create many EndUsers
     * const endUser = await prisma.endUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EndUserCreateManyArgs>(args?: SelectSubset<T, EndUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EndUsers and returns the data saved in the database.
     * @param {EndUserCreateManyAndReturnArgs} args - Arguments to create many EndUsers.
     * @example
     * // Create many EndUsers
     * const endUser = await prisma.endUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EndUsers and only return the `id`
     * const endUserWithIdOnly = await prisma.endUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EndUserCreateManyAndReturnArgs>(args?: SelectSubset<T, EndUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EndUser.
     * @param {EndUserDeleteArgs} args - Arguments to delete one EndUser.
     * @example
     * // Delete one EndUser
     * const EndUser = await prisma.endUser.delete({
     *   where: {
     *     // ... filter to delete one EndUser
     *   }
     * })
     * 
     */
    delete<T extends EndUserDeleteArgs>(args: SelectSubset<T, EndUserDeleteArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EndUser.
     * @param {EndUserUpdateArgs} args - Arguments to update one EndUser.
     * @example
     * // Update one EndUser
     * const endUser = await prisma.endUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EndUserUpdateArgs>(args: SelectSubset<T, EndUserUpdateArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EndUsers.
     * @param {EndUserDeleteManyArgs} args - Arguments to filter EndUsers to delete.
     * @example
     * // Delete a few EndUsers
     * const { count } = await prisma.endUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EndUserDeleteManyArgs>(args?: SelectSubset<T, EndUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EndUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EndUsers
     * const endUser = await prisma.endUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EndUserUpdateManyArgs>(args: SelectSubset<T, EndUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EndUsers and returns the data updated in the database.
     * @param {EndUserUpdateManyAndReturnArgs} args - Arguments to update many EndUsers.
     * @example
     * // Update many EndUsers
     * const endUser = await prisma.endUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EndUsers and only return the `id`
     * const endUserWithIdOnly = await prisma.endUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EndUserUpdateManyAndReturnArgs>(args: SelectSubset<T, EndUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EndUser.
     * @param {EndUserUpsertArgs} args - Arguments to update or create a EndUser.
     * @example
     * // Update or create a EndUser
     * const endUser = await prisma.endUser.upsert({
     *   create: {
     *     // ... data to create a EndUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EndUser we want to update
     *   }
     * })
     */
    upsert<T extends EndUserUpsertArgs>(args: SelectSubset<T, EndUserUpsertArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EndUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndUserCountArgs} args - Arguments to filter EndUsers to count.
     * @example
     * // Count the number of EndUsers
     * const count = await prisma.endUser.count({
     *   where: {
     *     // ... the filter for the EndUsers we want to count
     *   }
     * })
    **/
    count<T extends EndUserCountArgs>(
      args?: Subset<T, EndUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EndUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EndUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EndUserAggregateArgs>(args: Subset<T, EndUserAggregateArgs>): Prisma.PrismaPromise<GetEndUserAggregateType<T>>

    /**
     * Group by EndUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EndUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EndUserGroupByArgs['orderBy'] }
        : { orderBy?: EndUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EndUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEndUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EndUser model
   */
  readonly fields: EndUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EndUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EndUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    helper<T extends EndUser$helperArgs<ExtArgs> = {}>(args?: Subset<T, EndUser$helperArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    devices<T extends EndUser$devicesArgs<ExtArgs> = {}>(args?: Subset<T, EndUser$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    helpRequests<T extends EndUser$helpRequestsArgs<ExtArgs> = {}>(args?: Subset<T, EndUser$helpRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    mySales<T extends EndUser$mySalesArgs<ExtArgs> = {}>(args?: Subset<T, EndUser$mySalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EndUser model
   */ 
  interface EndUserFieldRefs {
    readonly id: FieldRef<"EndUser", 'Int'>
    readonly helperId: FieldRef<"EndUser", 'Int'>
    readonly lastPos: FieldRef<"EndUser", 'Json'>
    readonly status: FieldRef<"EndUser", 'String'>
    readonly userId: FieldRef<"EndUser", 'Int'>
    readonly createdAt: FieldRef<"EndUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EndUser findUnique
   */
  export type EndUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    /**
     * Filter, which EndUser to fetch.
     */
    where: EndUserWhereUniqueInput
  }

  /**
   * EndUser findUniqueOrThrow
   */
  export type EndUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    /**
     * Filter, which EndUser to fetch.
     */
    where: EndUserWhereUniqueInput
  }

  /**
   * EndUser findFirst
   */
  export type EndUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    /**
     * Filter, which EndUser to fetch.
     */
    where?: EndUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EndUsers to fetch.
     */
    orderBy?: EndUserOrderByWithRelationInput | EndUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EndUsers.
     */
    cursor?: EndUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EndUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EndUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EndUsers.
     */
    distinct?: EndUserScalarFieldEnum | EndUserScalarFieldEnum[]
  }

  /**
   * EndUser findFirstOrThrow
   */
  export type EndUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    /**
     * Filter, which EndUser to fetch.
     */
    where?: EndUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EndUsers to fetch.
     */
    orderBy?: EndUserOrderByWithRelationInput | EndUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EndUsers.
     */
    cursor?: EndUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EndUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EndUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EndUsers.
     */
    distinct?: EndUserScalarFieldEnum | EndUserScalarFieldEnum[]
  }

  /**
   * EndUser findMany
   */
  export type EndUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    /**
     * Filter, which EndUsers to fetch.
     */
    where?: EndUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EndUsers to fetch.
     */
    orderBy?: EndUserOrderByWithRelationInput | EndUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EndUsers.
     */
    cursor?: EndUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EndUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EndUsers.
     */
    skip?: number
    distinct?: EndUserScalarFieldEnum | EndUserScalarFieldEnum[]
  }

  /**
   * EndUser create
   */
  export type EndUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    /**
     * The data needed to create a EndUser.
     */
    data: XOR<EndUserCreateInput, EndUserUncheckedCreateInput>
  }

  /**
   * EndUser createMany
   */
  export type EndUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EndUsers.
     */
    data: EndUserCreateManyInput | EndUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EndUser createManyAndReturn
   */
  export type EndUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * The data used to create many EndUsers.
     */
    data: EndUserCreateManyInput | EndUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EndUser update
   */
  export type EndUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    /**
     * The data needed to update a EndUser.
     */
    data: XOR<EndUserUpdateInput, EndUserUncheckedUpdateInput>
    /**
     * Choose, which EndUser to update.
     */
    where: EndUserWhereUniqueInput
  }

  /**
   * EndUser updateMany
   */
  export type EndUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EndUsers.
     */
    data: XOR<EndUserUpdateManyMutationInput, EndUserUncheckedUpdateManyInput>
    /**
     * Filter which EndUsers to update
     */
    where?: EndUserWhereInput
    /**
     * Limit how many EndUsers to update.
     */
    limit?: number
  }

  /**
   * EndUser updateManyAndReturn
   */
  export type EndUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * The data used to update EndUsers.
     */
    data: XOR<EndUserUpdateManyMutationInput, EndUserUncheckedUpdateManyInput>
    /**
     * Filter which EndUsers to update
     */
    where?: EndUserWhereInput
    /**
     * Limit how many EndUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EndUser upsert
   */
  export type EndUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    /**
     * The filter to search for the EndUser to update in case it exists.
     */
    where: EndUserWhereUniqueInput
    /**
     * In case the EndUser found by the `where` argument doesn't exist, create a new EndUser with this data.
     */
    create: XOR<EndUserCreateInput, EndUserUncheckedCreateInput>
    /**
     * In case the EndUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EndUserUpdateInput, EndUserUncheckedUpdateInput>
  }

  /**
   * EndUser delete
   */
  export type EndUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    /**
     * Filter which EndUser to delete.
     */
    where: EndUserWhereUniqueInput
  }

  /**
   * EndUser deleteMany
   */
  export type EndUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EndUsers to delete
     */
    where?: EndUserWhereInput
    /**
     * Limit how many EndUsers to delete.
     */
    limit?: number
  }

  /**
   * EndUser.helper
   */
  export type EndUser$helperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    where?: HelperWhereInput
  }

  /**
   * EndUser.devices
   */
  export type EndUser$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * EndUser.helpRequests
   */
  export type EndUser$helpRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    where?: HelpRequestWhereInput
    orderBy?: HelpRequestOrderByWithRelationInput | HelpRequestOrderByWithRelationInput[]
    cursor?: HelpRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * EndUser.mySales
   */
  export type EndUser$mySalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * EndUser without action
   */
  export type EndUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
  }


  /**
   * Model Helper
   */

  export type AggregateHelper = {
    _count: HelperCountAggregateOutputType | null
    _avg: HelperAvgAggregateOutputType | null
    _sum: HelperSumAggregateOutputType | null
    _min: HelperMinAggregateOutputType | null
    _max: HelperMaxAggregateOutputType | null
  }

  export type HelperAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type HelperSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type HelperMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type HelperMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type HelperCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type HelperAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type HelperSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type HelperMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type HelperMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type HelperCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type HelperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Helper to aggregate.
     */
    where?: HelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helpers to fetch.
     */
    orderBy?: HelperOrderByWithRelationInput | HelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Helpers
    **/
    _count?: true | HelperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelperMaxAggregateInputType
  }

  export type GetHelperAggregateType<T extends HelperAggregateArgs> = {
        [P in keyof T & keyof AggregateHelper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelper[P]>
      : GetScalarType<T[P], AggregateHelper[P]>
  }




  export type HelperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelperWhereInput
    orderBy?: HelperOrderByWithAggregationInput | HelperOrderByWithAggregationInput[]
    by: HelperScalarFieldEnum[] | HelperScalarFieldEnum
    having?: HelperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelperCountAggregateInputType | true
    _avg?: HelperAvgAggregateInputType
    _sum?: HelperSumAggregateInputType
    _min?: HelperMinAggregateInputType
    _max?: HelperMaxAggregateInputType
  }

  export type HelperGroupByOutputType = {
    id: number
    userId: number
    _count: HelperCountAggregateOutputType | null
    _avg: HelperAvgAggregateOutputType | null
    _sum: HelperSumAggregateOutputType | null
    _min: HelperMinAggregateOutputType | null
    _max: HelperMaxAggregateOutputType | null
  }

  type GetHelperGroupByPayload<T extends HelperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelperGroupByOutputType[P]>
            : GetScalarType<T[P], HelperGroupByOutputType[P]>
        }
      >
    >


  export type HelperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    endUsers?: boolean | Helper$endUsersArgs<ExtArgs>
    helpRequests?: boolean | Helper$helpRequestsArgs<ExtArgs>
    _count?: boolean | HelperCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helper"]>

  export type HelperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helper"]>

  export type HelperSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helper"]>

  export type HelperSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type HelperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["helper"]>
  export type HelperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    endUsers?: boolean | Helper$endUsersArgs<ExtArgs>
    helpRequests?: boolean | Helper$helpRequestsArgs<ExtArgs>
    _count?: boolean | HelperCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HelperIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HelperIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HelperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Helper"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      endUsers: Prisma.$EndUserPayload<ExtArgs>[]
      helpRequests: Prisma.$HelpRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
    }, ExtArgs["result"]["helper"]>
    composites: {}
  }

  type HelperGetPayload<S extends boolean | null | undefined | HelperDefaultArgs> = $Result.GetResult<Prisma.$HelperPayload, S>

  type HelperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HelperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HelperCountAggregateInputType | true
    }

  export interface HelperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Helper'], meta: { name: 'Helper' } }
    /**
     * Find zero or one Helper that matches the filter.
     * @param {HelperFindUniqueArgs} args - Arguments to find a Helper
     * @example
     * // Get one Helper
     * const helper = await prisma.helper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelperFindUniqueArgs>(args: SelectSubset<T, HelperFindUniqueArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Helper that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HelperFindUniqueOrThrowArgs} args - Arguments to find a Helper
     * @example
     * // Get one Helper
     * const helper = await prisma.helper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelperFindUniqueOrThrowArgs>(args: SelectSubset<T, HelperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Helper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperFindFirstArgs} args - Arguments to find a Helper
     * @example
     * // Get one Helper
     * const helper = await prisma.helper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelperFindFirstArgs>(args?: SelectSubset<T, HelperFindFirstArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Helper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperFindFirstOrThrowArgs} args - Arguments to find a Helper
     * @example
     * // Get one Helper
     * const helper = await prisma.helper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelperFindFirstOrThrowArgs>(args?: SelectSubset<T, HelperFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Helpers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Helpers
     * const helpers = await prisma.helper.findMany()
     * 
     * // Get first 10 Helpers
     * const helpers = await prisma.helper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helperWithIdOnly = await prisma.helper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelperFindManyArgs>(args?: SelectSubset<T, HelperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Helper.
     * @param {HelperCreateArgs} args - Arguments to create a Helper.
     * @example
     * // Create one Helper
     * const Helper = await prisma.helper.create({
     *   data: {
     *     // ... data to create a Helper
     *   }
     * })
     * 
     */
    create<T extends HelperCreateArgs>(args: SelectSubset<T, HelperCreateArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Helpers.
     * @param {HelperCreateManyArgs} args - Arguments to create many Helpers.
     * @example
     * // Create many Helpers
     * const helper = await prisma.helper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelperCreateManyArgs>(args?: SelectSubset<T, HelperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Helpers and returns the data saved in the database.
     * @param {HelperCreateManyAndReturnArgs} args - Arguments to create many Helpers.
     * @example
     * // Create many Helpers
     * const helper = await prisma.helper.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Helpers and only return the `id`
     * const helperWithIdOnly = await prisma.helper.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelperCreateManyAndReturnArgs>(args?: SelectSubset<T, HelperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Helper.
     * @param {HelperDeleteArgs} args - Arguments to delete one Helper.
     * @example
     * // Delete one Helper
     * const Helper = await prisma.helper.delete({
     *   where: {
     *     // ... filter to delete one Helper
     *   }
     * })
     * 
     */
    delete<T extends HelperDeleteArgs>(args: SelectSubset<T, HelperDeleteArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Helper.
     * @param {HelperUpdateArgs} args - Arguments to update one Helper.
     * @example
     * // Update one Helper
     * const helper = await prisma.helper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelperUpdateArgs>(args: SelectSubset<T, HelperUpdateArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Helpers.
     * @param {HelperDeleteManyArgs} args - Arguments to filter Helpers to delete.
     * @example
     * // Delete a few Helpers
     * const { count } = await prisma.helper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelperDeleteManyArgs>(args?: SelectSubset<T, HelperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Helpers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Helpers
     * const helper = await prisma.helper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelperUpdateManyArgs>(args: SelectSubset<T, HelperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Helpers and returns the data updated in the database.
     * @param {HelperUpdateManyAndReturnArgs} args - Arguments to update many Helpers.
     * @example
     * // Update many Helpers
     * const helper = await prisma.helper.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Helpers and only return the `id`
     * const helperWithIdOnly = await prisma.helper.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HelperUpdateManyAndReturnArgs>(args: SelectSubset<T, HelperUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Helper.
     * @param {HelperUpsertArgs} args - Arguments to update or create a Helper.
     * @example
     * // Update or create a Helper
     * const helper = await prisma.helper.upsert({
     *   create: {
     *     // ... data to create a Helper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Helper we want to update
     *   }
     * })
     */
    upsert<T extends HelperUpsertArgs>(args: SelectSubset<T, HelperUpsertArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Helpers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperCountArgs} args - Arguments to filter Helpers to count.
     * @example
     * // Count the number of Helpers
     * const count = await prisma.helper.count({
     *   where: {
     *     // ... the filter for the Helpers we want to count
     *   }
     * })
    **/
    count<T extends HelperCountArgs>(
      args?: Subset<T, HelperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Helper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelperAggregateArgs>(args: Subset<T, HelperAggregateArgs>): Prisma.PrismaPromise<GetHelperAggregateType<T>>

    /**
     * Group by Helper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelperGroupByArgs['orderBy'] }
        : { orderBy?: HelperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Helper model
   */
  readonly fields: HelperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Helper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    endUsers<T extends Helper$endUsersArgs<ExtArgs> = {}>(args?: Subset<T, Helper$endUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    helpRequests<T extends Helper$helpRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Helper$helpRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Helper model
   */ 
  interface HelperFieldRefs {
    readonly id: FieldRef<"Helper", 'Int'>
    readonly userId: FieldRef<"Helper", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Helper findUnique
   */
  export type HelperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helper to fetch.
     */
    where: HelperWhereUniqueInput
  }

  /**
   * Helper findUniqueOrThrow
   */
  export type HelperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helper to fetch.
     */
    where: HelperWhereUniqueInput
  }

  /**
   * Helper findFirst
   */
  export type HelperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helper to fetch.
     */
    where?: HelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helpers to fetch.
     */
    orderBy?: HelperOrderByWithRelationInput | HelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Helpers.
     */
    cursor?: HelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Helpers.
     */
    distinct?: HelperScalarFieldEnum | HelperScalarFieldEnum[]
  }

  /**
   * Helper findFirstOrThrow
   */
  export type HelperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helper to fetch.
     */
    where?: HelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helpers to fetch.
     */
    orderBy?: HelperOrderByWithRelationInput | HelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Helpers.
     */
    cursor?: HelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Helpers.
     */
    distinct?: HelperScalarFieldEnum | HelperScalarFieldEnum[]
  }

  /**
   * Helper findMany
   */
  export type HelperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter, which Helpers to fetch.
     */
    where?: HelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helpers to fetch.
     */
    orderBy?: HelperOrderByWithRelationInput | HelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Helpers.
     */
    cursor?: HelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helpers.
     */
    skip?: number
    distinct?: HelperScalarFieldEnum | HelperScalarFieldEnum[]
  }

  /**
   * Helper create
   */
  export type HelperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * The data needed to create a Helper.
     */
    data: XOR<HelperCreateInput, HelperUncheckedCreateInput>
  }

  /**
   * Helper createMany
   */
  export type HelperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Helpers.
     */
    data: HelperCreateManyInput | HelperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Helper createManyAndReturn
   */
  export type HelperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * The data used to create many Helpers.
     */
    data: HelperCreateManyInput | HelperCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Helper update
   */
  export type HelperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * The data needed to update a Helper.
     */
    data: XOR<HelperUpdateInput, HelperUncheckedUpdateInput>
    /**
     * Choose, which Helper to update.
     */
    where: HelperWhereUniqueInput
  }

  /**
   * Helper updateMany
   */
  export type HelperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Helpers.
     */
    data: XOR<HelperUpdateManyMutationInput, HelperUncheckedUpdateManyInput>
    /**
     * Filter which Helpers to update
     */
    where?: HelperWhereInput
    /**
     * Limit how many Helpers to update.
     */
    limit?: number
  }

  /**
   * Helper updateManyAndReturn
   */
  export type HelperUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * The data used to update Helpers.
     */
    data: XOR<HelperUpdateManyMutationInput, HelperUncheckedUpdateManyInput>
    /**
     * Filter which Helpers to update
     */
    where?: HelperWhereInput
    /**
     * Limit how many Helpers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Helper upsert
   */
  export type HelperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * The filter to search for the Helper to update in case it exists.
     */
    where: HelperWhereUniqueInput
    /**
     * In case the Helper found by the `where` argument doesn't exist, create a new Helper with this data.
     */
    create: XOR<HelperCreateInput, HelperUncheckedCreateInput>
    /**
     * In case the Helper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelperUpdateInput, HelperUncheckedUpdateInput>
  }

  /**
   * Helper delete
   */
  export type HelperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
    /**
     * Filter which Helper to delete.
     */
    where: HelperWhereUniqueInput
  }

  /**
   * Helper deleteMany
   */
  export type HelperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Helpers to delete
     */
    where?: HelperWhereInput
    /**
     * Limit how many Helpers to delete.
     */
    limit?: number
  }

  /**
   * Helper.endUsers
   */
  export type Helper$endUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    where?: EndUserWhereInput
    orderBy?: EndUserOrderByWithRelationInput | EndUserOrderByWithRelationInput[]
    cursor?: EndUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EndUserScalarFieldEnum | EndUserScalarFieldEnum[]
  }

  /**
   * Helper.helpRequests
   */
  export type Helper$helpRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    where?: HelpRequestWhereInput
    orderBy?: HelpRequestOrderByWithRelationInput | HelpRequestOrderByWithRelationInput[]
    cursor?: HelpRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * Helper without action
   */
  export type HelperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Helper
     */
    select?: HelperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Helper
     */
    omit?: HelperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelperInclude<ExtArgs> | null
  }


  /**
   * Model Commercial
   */

  export type AggregateCommercial = {
    _count: CommercialCountAggregateOutputType | null
    _avg: CommercialAvgAggregateOutputType | null
    _sum: CommercialSumAggregateOutputType | null
    _min: CommercialMinAggregateOutputType | null
    _max: CommercialMaxAggregateOutputType | null
  }

  export type CommercialAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CommercialSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CommercialMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CommercialMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CommercialCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type CommercialAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CommercialSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CommercialMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CommercialMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CommercialCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type CommercialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commercial to aggregate.
     */
    where?: CommercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commercials to fetch.
     */
    orderBy?: CommercialOrderByWithRelationInput | CommercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commercials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commercials
    **/
    _count?: true | CommercialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommercialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommercialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommercialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommercialMaxAggregateInputType
  }

  export type GetCommercialAggregateType<T extends CommercialAggregateArgs> = {
        [P in keyof T & keyof AggregateCommercial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommercial[P]>
      : GetScalarType<T[P], AggregateCommercial[P]>
  }




  export type CommercialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommercialWhereInput
    orderBy?: CommercialOrderByWithAggregationInput | CommercialOrderByWithAggregationInput[]
    by: CommercialScalarFieldEnum[] | CommercialScalarFieldEnum
    having?: CommercialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommercialCountAggregateInputType | true
    _avg?: CommercialAvgAggregateInputType
    _sum?: CommercialSumAggregateInputType
    _min?: CommercialMinAggregateInputType
    _max?: CommercialMaxAggregateInputType
  }

  export type CommercialGroupByOutputType = {
    id: number
    userId: number
    _count: CommercialCountAggregateOutputType | null
    _avg: CommercialAvgAggregateOutputType | null
    _sum: CommercialSumAggregateOutputType | null
    _min: CommercialMinAggregateOutputType | null
    _max: CommercialMaxAggregateOutputType | null
  }

  type GetCommercialGroupByPayload<T extends CommercialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommercialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommercialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommercialGroupByOutputType[P]>
            : GetScalarType<T[P], CommercialGroupByOutputType[P]>
        }
      >
    >


  export type CommercialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commercial"]>

  export type CommercialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commercial"]>

  export type CommercialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commercial"]>

  export type CommercialSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type CommercialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["commercial"]>
  export type CommercialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommercialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommercialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommercialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commercial"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
    }, ExtArgs["result"]["commercial"]>
    composites: {}
  }

  type CommercialGetPayload<S extends boolean | null | undefined | CommercialDefaultArgs> = $Result.GetResult<Prisma.$CommercialPayload, S>

  type CommercialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommercialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommercialCountAggregateInputType | true
    }

  export interface CommercialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commercial'], meta: { name: 'Commercial' } }
    /**
     * Find zero or one Commercial that matches the filter.
     * @param {CommercialFindUniqueArgs} args - Arguments to find a Commercial
     * @example
     * // Get one Commercial
     * const commercial = await prisma.commercial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommercialFindUniqueArgs>(args: SelectSubset<T, CommercialFindUniqueArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Commercial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommercialFindUniqueOrThrowArgs} args - Arguments to find a Commercial
     * @example
     * // Get one Commercial
     * const commercial = await prisma.commercial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommercialFindUniqueOrThrowArgs>(args: SelectSubset<T, CommercialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Commercial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialFindFirstArgs} args - Arguments to find a Commercial
     * @example
     * // Get one Commercial
     * const commercial = await prisma.commercial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommercialFindFirstArgs>(args?: SelectSubset<T, CommercialFindFirstArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Commercial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialFindFirstOrThrowArgs} args - Arguments to find a Commercial
     * @example
     * // Get one Commercial
     * const commercial = await prisma.commercial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommercialFindFirstOrThrowArgs>(args?: SelectSubset<T, CommercialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Commercials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commercials
     * const commercials = await prisma.commercial.findMany()
     * 
     * // Get first 10 Commercials
     * const commercials = await prisma.commercial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commercialWithIdOnly = await prisma.commercial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommercialFindManyArgs>(args?: SelectSubset<T, CommercialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Commercial.
     * @param {CommercialCreateArgs} args - Arguments to create a Commercial.
     * @example
     * // Create one Commercial
     * const Commercial = await prisma.commercial.create({
     *   data: {
     *     // ... data to create a Commercial
     *   }
     * })
     * 
     */
    create<T extends CommercialCreateArgs>(args: SelectSubset<T, CommercialCreateArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Commercials.
     * @param {CommercialCreateManyArgs} args - Arguments to create many Commercials.
     * @example
     * // Create many Commercials
     * const commercial = await prisma.commercial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommercialCreateManyArgs>(args?: SelectSubset<T, CommercialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commercials and returns the data saved in the database.
     * @param {CommercialCreateManyAndReturnArgs} args - Arguments to create many Commercials.
     * @example
     * // Create many Commercials
     * const commercial = await prisma.commercial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commercials and only return the `id`
     * const commercialWithIdOnly = await prisma.commercial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommercialCreateManyAndReturnArgs>(args?: SelectSubset<T, CommercialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Commercial.
     * @param {CommercialDeleteArgs} args - Arguments to delete one Commercial.
     * @example
     * // Delete one Commercial
     * const Commercial = await prisma.commercial.delete({
     *   where: {
     *     // ... filter to delete one Commercial
     *   }
     * })
     * 
     */
    delete<T extends CommercialDeleteArgs>(args: SelectSubset<T, CommercialDeleteArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Commercial.
     * @param {CommercialUpdateArgs} args - Arguments to update one Commercial.
     * @example
     * // Update one Commercial
     * const commercial = await prisma.commercial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommercialUpdateArgs>(args: SelectSubset<T, CommercialUpdateArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Commercials.
     * @param {CommercialDeleteManyArgs} args - Arguments to filter Commercials to delete.
     * @example
     * // Delete a few Commercials
     * const { count } = await prisma.commercial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommercialDeleteManyArgs>(args?: SelectSubset<T, CommercialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commercials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commercials
     * const commercial = await prisma.commercial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommercialUpdateManyArgs>(args: SelectSubset<T, CommercialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commercials and returns the data updated in the database.
     * @param {CommercialUpdateManyAndReturnArgs} args - Arguments to update many Commercials.
     * @example
     * // Update many Commercials
     * const commercial = await prisma.commercial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Commercials and only return the `id`
     * const commercialWithIdOnly = await prisma.commercial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommercialUpdateManyAndReturnArgs>(args: SelectSubset<T, CommercialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Commercial.
     * @param {CommercialUpsertArgs} args - Arguments to update or create a Commercial.
     * @example
     * // Update or create a Commercial
     * const commercial = await prisma.commercial.upsert({
     *   create: {
     *     // ... data to create a Commercial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commercial we want to update
     *   }
     * })
     */
    upsert<T extends CommercialUpsertArgs>(args: SelectSubset<T, CommercialUpsertArgs<ExtArgs>>): Prisma__CommercialClient<$Result.GetResult<Prisma.$CommercialPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Commercials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialCountArgs} args - Arguments to filter Commercials to count.
     * @example
     * // Count the number of Commercials
     * const count = await prisma.commercial.count({
     *   where: {
     *     // ... the filter for the Commercials we want to count
     *   }
     * })
    **/
    count<T extends CommercialCountArgs>(
      args?: Subset<T, CommercialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommercialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commercial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommercialAggregateArgs>(args: Subset<T, CommercialAggregateArgs>): Prisma.PrismaPromise<GetCommercialAggregateType<T>>

    /**
     * Group by Commercial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommercialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommercialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommercialGroupByArgs['orderBy'] }
        : { orderBy?: CommercialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommercialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommercialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commercial model
   */
  readonly fields: CommercialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commercial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommercialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commercial model
   */ 
  interface CommercialFieldRefs {
    readonly id: FieldRef<"Commercial", 'Int'>
    readonly userId: FieldRef<"Commercial", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Commercial findUnique
   */
  export type CommercialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercial to fetch.
     */
    where: CommercialWhereUniqueInput
  }

  /**
   * Commercial findUniqueOrThrow
   */
  export type CommercialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercial to fetch.
     */
    where: CommercialWhereUniqueInput
  }

  /**
   * Commercial findFirst
   */
  export type CommercialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercial to fetch.
     */
    where?: CommercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commercials to fetch.
     */
    orderBy?: CommercialOrderByWithRelationInput | CommercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commercials.
     */
    cursor?: CommercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commercials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commercials.
     */
    distinct?: CommercialScalarFieldEnum | CommercialScalarFieldEnum[]
  }

  /**
   * Commercial findFirstOrThrow
   */
  export type CommercialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercial to fetch.
     */
    where?: CommercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commercials to fetch.
     */
    orderBy?: CommercialOrderByWithRelationInput | CommercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commercials.
     */
    cursor?: CommercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commercials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commercials.
     */
    distinct?: CommercialScalarFieldEnum | CommercialScalarFieldEnum[]
  }

  /**
   * Commercial findMany
   */
  export type CommercialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter, which Commercials to fetch.
     */
    where?: CommercialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commercials to fetch.
     */
    orderBy?: CommercialOrderByWithRelationInput | CommercialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commercials.
     */
    cursor?: CommercialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commercials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commercials.
     */
    skip?: number
    distinct?: CommercialScalarFieldEnum | CommercialScalarFieldEnum[]
  }

  /**
   * Commercial create
   */
  export type CommercialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * The data needed to create a Commercial.
     */
    data: XOR<CommercialCreateInput, CommercialUncheckedCreateInput>
  }

  /**
   * Commercial createMany
   */
  export type CommercialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commercials.
     */
    data: CommercialCreateManyInput | CommercialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commercial createManyAndReturn
   */
  export type CommercialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * The data used to create many Commercials.
     */
    data: CommercialCreateManyInput | CommercialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Commercial update
   */
  export type CommercialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * The data needed to update a Commercial.
     */
    data: XOR<CommercialUpdateInput, CommercialUncheckedUpdateInput>
    /**
     * Choose, which Commercial to update.
     */
    where: CommercialWhereUniqueInput
  }

  /**
   * Commercial updateMany
   */
  export type CommercialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commercials.
     */
    data: XOR<CommercialUpdateManyMutationInput, CommercialUncheckedUpdateManyInput>
    /**
     * Filter which Commercials to update
     */
    where?: CommercialWhereInput
    /**
     * Limit how many Commercials to update.
     */
    limit?: number
  }

  /**
   * Commercial updateManyAndReturn
   */
  export type CommercialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * The data used to update Commercials.
     */
    data: XOR<CommercialUpdateManyMutationInput, CommercialUncheckedUpdateManyInput>
    /**
     * Filter which Commercials to update
     */
    where?: CommercialWhereInput
    /**
     * Limit how many Commercials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Commercial upsert
   */
  export type CommercialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * The filter to search for the Commercial to update in case it exists.
     */
    where: CommercialWhereUniqueInput
    /**
     * In case the Commercial found by the `where` argument doesn't exist, create a new Commercial with this data.
     */
    create: XOR<CommercialCreateInput, CommercialUncheckedCreateInput>
    /**
     * In case the Commercial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommercialUpdateInput, CommercialUncheckedUpdateInput>
  }

  /**
   * Commercial delete
   */
  export type CommercialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
    /**
     * Filter which Commercial to delete.
     */
    where: CommercialWhereUniqueInput
  }

  /**
   * Commercial deleteMany
   */
  export type CommercialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commercials to delete
     */
    where?: CommercialWhereInput
    /**
     * Limit how many Commercials to delete.
     */
    limit?: number
  }

  /**
   * Commercial without action
   */
  export type CommercialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commercial
     */
    select?: CommercialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commercial
     */
    omit?: CommercialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommercialInclude<ExtArgs> | null
  }


  /**
   * Model Maintainer
   */

  export type AggregateMaintainer = {
    _count: MaintainerCountAggregateOutputType | null
    _avg: MaintainerAvgAggregateOutputType | null
    _sum: MaintainerSumAggregateOutputType | null
    _min: MaintainerMinAggregateOutputType | null
    _max: MaintainerMaxAggregateOutputType | null
  }

  export type MaintainerAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MaintainerSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MaintainerMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MaintainerMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MaintainerCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type MaintainerAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MaintainerSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MaintainerMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MaintainerMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MaintainerCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type MaintainerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintainer to aggregate.
     */
    where?: MaintainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintainers to fetch.
     */
    orderBy?: MaintainerOrderByWithRelationInput | MaintainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maintainers
    **/
    _count?: true | MaintainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintainerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintainerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintainerMaxAggregateInputType
  }

  export type GetMaintainerAggregateType<T extends MaintainerAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintainer[P]>
      : GetScalarType<T[P], AggregateMaintainer[P]>
  }




  export type MaintainerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintainerWhereInput
    orderBy?: MaintainerOrderByWithAggregationInput | MaintainerOrderByWithAggregationInput[]
    by: MaintainerScalarFieldEnum[] | MaintainerScalarFieldEnum
    having?: MaintainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintainerCountAggregateInputType | true
    _avg?: MaintainerAvgAggregateInputType
    _sum?: MaintainerSumAggregateInputType
    _min?: MaintainerMinAggregateInputType
    _max?: MaintainerMaxAggregateInputType
  }

  export type MaintainerGroupByOutputType = {
    id: number
    userId: number
    _count: MaintainerCountAggregateOutputType | null
    _avg: MaintainerAvgAggregateOutputType | null
    _sum: MaintainerSumAggregateOutputType | null
    _min: MaintainerMinAggregateOutputType | null
    _max: MaintainerMaxAggregateOutputType | null
  }

  type GetMaintainerGroupByPayload<T extends MaintainerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintainerGroupByOutputType[P]>
            : GetScalarType<T[P], MaintainerGroupByOutputType[P]>
        }
      >
    >


  export type MaintainerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    interventions?: boolean | Maintainer$interventionsArgs<ExtArgs>
    _count?: boolean | MaintainerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintainer"]>

  export type MaintainerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintainer"]>

  export type MaintainerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintainer"]>

  export type MaintainerSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type MaintainerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["maintainer"]>
  export type MaintainerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    interventions?: boolean | Maintainer$interventionsArgs<ExtArgs>
    _count?: boolean | MaintainerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintainerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MaintainerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MaintainerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maintainer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      interventions: Prisma.$InterventionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
    }, ExtArgs["result"]["maintainer"]>
    composites: {}
  }

  type MaintainerGetPayload<S extends boolean | null | undefined | MaintainerDefaultArgs> = $Result.GetResult<Prisma.$MaintainerPayload, S>

  type MaintainerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintainerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintainerCountAggregateInputType | true
    }

  export interface MaintainerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maintainer'], meta: { name: 'Maintainer' } }
    /**
     * Find zero or one Maintainer that matches the filter.
     * @param {MaintainerFindUniqueArgs} args - Arguments to find a Maintainer
     * @example
     * // Get one Maintainer
     * const maintainer = await prisma.maintainer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintainerFindUniqueArgs>(args: SelectSubset<T, MaintainerFindUniqueArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Maintainer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintainerFindUniqueOrThrowArgs} args - Arguments to find a Maintainer
     * @example
     * // Get one Maintainer
     * const maintainer = await prisma.maintainer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintainerFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintainerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Maintainer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerFindFirstArgs} args - Arguments to find a Maintainer
     * @example
     * // Get one Maintainer
     * const maintainer = await prisma.maintainer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintainerFindFirstArgs>(args?: SelectSubset<T, MaintainerFindFirstArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Maintainer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerFindFirstOrThrowArgs} args - Arguments to find a Maintainer
     * @example
     * // Get one Maintainer
     * const maintainer = await prisma.maintainer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintainerFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintainerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Maintainers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintainers
     * const maintainers = await prisma.maintainer.findMany()
     * 
     * // Get first 10 Maintainers
     * const maintainers = await prisma.maintainer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintainerWithIdOnly = await prisma.maintainer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintainerFindManyArgs>(args?: SelectSubset<T, MaintainerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Maintainer.
     * @param {MaintainerCreateArgs} args - Arguments to create a Maintainer.
     * @example
     * // Create one Maintainer
     * const Maintainer = await prisma.maintainer.create({
     *   data: {
     *     // ... data to create a Maintainer
     *   }
     * })
     * 
     */
    create<T extends MaintainerCreateArgs>(args: SelectSubset<T, MaintainerCreateArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Maintainers.
     * @param {MaintainerCreateManyArgs} args - Arguments to create many Maintainers.
     * @example
     * // Create many Maintainers
     * const maintainer = await prisma.maintainer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintainerCreateManyArgs>(args?: SelectSubset<T, MaintainerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maintainers and returns the data saved in the database.
     * @param {MaintainerCreateManyAndReturnArgs} args - Arguments to create many Maintainers.
     * @example
     * // Create many Maintainers
     * const maintainer = await prisma.maintainer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maintainers and only return the `id`
     * const maintainerWithIdOnly = await prisma.maintainer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintainerCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintainerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Maintainer.
     * @param {MaintainerDeleteArgs} args - Arguments to delete one Maintainer.
     * @example
     * // Delete one Maintainer
     * const Maintainer = await prisma.maintainer.delete({
     *   where: {
     *     // ... filter to delete one Maintainer
     *   }
     * })
     * 
     */
    delete<T extends MaintainerDeleteArgs>(args: SelectSubset<T, MaintainerDeleteArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Maintainer.
     * @param {MaintainerUpdateArgs} args - Arguments to update one Maintainer.
     * @example
     * // Update one Maintainer
     * const maintainer = await prisma.maintainer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintainerUpdateArgs>(args: SelectSubset<T, MaintainerUpdateArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Maintainers.
     * @param {MaintainerDeleteManyArgs} args - Arguments to filter Maintainers to delete.
     * @example
     * // Delete a few Maintainers
     * const { count } = await prisma.maintainer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintainerDeleteManyArgs>(args?: SelectSubset<T, MaintainerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintainers
     * const maintainer = await prisma.maintainer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintainerUpdateManyArgs>(args: SelectSubset<T, MaintainerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintainers and returns the data updated in the database.
     * @param {MaintainerUpdateManyAndReturnArgs} args - Arguments to update many Maintainers.
     * @example
     * // Update many Maintainers
     * const maintainer = await prisma.maintainer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maintainers and only return the `id`
     * const maintainerWithIdOnly = await prisma.maintainer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintainerUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintainerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Maintainer.
     * @param {MaintainerUpsertArgs} args - Arguments to update or create a Maintainer.
     * @example
     * // Update or create a Maintainer
     * const maintainer = await prisma.maintainer.upsert({
     *   create: {
     *     // ... data to create a Maintainer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintainer we want to update
     *   }
     * })
     */
    upsert<T extends MaintainerUpsertArgs>(args: SelectSubset<T, MaintainerUpsertArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Maintainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerCountArgs} args - Arguments to filter Maintainers to count.
     * @example
     * // Count the number of Maintainers
     * const count = await prisma.maintainer.count({
     *   where: {
     *     // ... the filter for the Maintainers we want to count
     *   }
     * })
    **/
    count<T extends MaintainerCountArgs>(
      args?: Subset<T, MaintainerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintainerAggregateArgs>(args: Subset<T, MaintainerAggregateArgs>): Prisma.PrismaPromise<GetMaintainerAggregateType<T>>

    /**
     * Group by Maintainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintainerGroupByArgs['orderBy'] }
        : { orderBy?: MaintainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintainerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maintainer model
   */
  readonly fields: MaintainerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maintainer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintainerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    interventions<T extends Maintainer$interventionsArgs<ExtArgs> = {}>(args?: Subset<T, Maintainer$interventionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maintainer model
   */ 
  interface MaintainerFieldRefs {
    readonly id: FieldRef<"Maintainer", 'Int'>
    readonly userId: FieldRef<"Maintainer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Maintainer findUnique
   */
  export type MaintainerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainer to fetch.
     */
    where: MaintainerWhereUniqueInput
  }

  /**
   * Maintainer findUniqueOrThrow
   */
  export type MaintainerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainer to fetch.
     */
    where: MaintainerWhereUniqueInput
  }

  /**
   * Maintainer findFirst
   */
  export type MaintainerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainer to fetch.
     */
    where?: MaintainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintainers to fetch.
     */
    orderBy?: MaintainerOrderByWithRelationInput | MaintainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintainers.
     */
    cursor?: MaintainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintainers.
     */
    distinct?: MaintainerScalarFieldEnum | MaintainerScalarFieldEnum[]
  }

  /**
   * Maintainer findFirstOrThrow
   */
  export type MaintainerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainer to fetch.
     */
    where?: MaintainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintainers to fetch.
     */
    orderBy?: MaintainerOrderByWithRelationInput | MaintainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintainers.
     */
    cursor?: MaintainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintainers.
     */
    distinct?: MaintainerScalarFieldEnum | MaintainerScalarFieldEnum[]
  }

  /**
   * Maintainer findMany
   */
  export type MaintainerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter, which Maintainers to fetch.
     */
    where?: MaintainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintainers to fetch.
     */
    orderBy?: MaintainerOrderByWithRelationInput | MaintainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maintainers.
     */
    cursor?: MaintainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintainers.
     */
    skip?: number
    distinct?: MaintainerScalarFieldEnum | MaintainerScalarFieldEnum[]
  }

  /**
   * Maintainer create
   */
  export type MaintainerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * The data needed to create a Maintainer.
     */
    data: XOR<MaintainerCreateInput, MaintainerUncheckedCreateInput>
  }

  /**
   * Maintainer createMany
   */
  export type MaintainerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maintainers.
     */
    data: MaintainerCreateManyInput | MaintainerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintainer createManyAndReturn
   */
  export type MaintainerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * The data used to create many Maintainers.
     */
    data: MaintainerCreateManyInput | MaintainerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maintainer update
   */
  export type MaintainerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * The data needed to update a Maintainer.
     */
    data: XOR<MaintainerUpdateInput, MaintainerUncheckedUpdateInput>
    /**
     * Choose, which Maintainer to update.
     */
    where: MaintainerWhereUniqueInput
  }

  /**
   * Maintainer updateMany
   */
  export type MaintainerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maintainers.
     */
    data: XOR<MaintainerUpdateManyMutationInput, MaintainerUncheckedUpdateManyInput>
    /**
     * Filter which Maintainers to update
     */
    where?: MaintainerWhereInput
    /**
     * Limit how many Maintainers to update.
     */
    limit?: number
  }

  /**
   * Maintainer updateManyAndReturn
   */
  export type MaintainerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * The data used to update Maintainers.
     */
    data: XOR<MaintainerUpdateManyMutationInput, MaintainerUncheckedUpdateManyInput>
    /**
     * Filter which Maintainers to update
     */
    where?: MaintainerWhereInput
    /**
     * Limit how many Maintainers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maintainer upsert
   */
  export type MaintainerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * The filter to search for the Maintainer to update in case it exists.
     */
    where: MaintainerWhereUniqueInput
    /**
     * In case the Maintainer found by the `where` argument doesn't exist, create a new Maintainer with this data.
     */
    create: XOR<MaintainerCreateInput, MaintainerUncheckedCreateInput>
    /**
     * In case the Maintainer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintainerUpdateInput, MaintainerUncheckedUpdateInput>
  }

  /**
   * Maintainer delete
   */
  export type MaintainerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
    /**
     * Filter which Maintainer to delete.
     */
    where: MaintainerWhereUniqueInput
  }

  /**
   * Maintainer deleteMany
   */
  export type MaintainerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintainers to delete
     */
    where?: MaintainerWhereInput
    /**
     * Limit how many Maintainers to delete.
     */
    limit?: number
  }

  /**
   * Maintainer.interventions
   */
  export type Maintainer$interventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    cursor?: InterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Maintainer without action
   */
  export type MaintainerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintainer
     */
    select?: MaintainerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintainer
     */
    omit?: MaintainerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintainerInclude<ExtArgs> | null
  }


  /**
   * Model Decider
   */

  export type AggregateDecider = {
    _count: DeciderCountAggregateOutputType | null
    _avg: DeciderAvgAggregateOutputType | null
    _sum: DeciderSumAggregateOutputType | null
    _min: DeciderMinAggregateOutputType | null
    _max: DeciderMaxAggregateOutputType | null
  }

  export type DeciderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DeciderSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DeciderMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DeciderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DeciderCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type DeciderAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DeciderSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DeciderMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DeciderMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DeciderCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type DeciderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Decider to aggregate.
     */
    where?: DeciderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deciders to fetch.
     */
    orderBy?: DeciderOrderByWithRelationInput | DeciderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeciderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deciders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deciders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deciders
    **/
    _count?: true | DeciderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeciderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeciderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeciderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeciderMaxAggregateInputType
  }

  export type GetDeciderAggregateType<T extends DeciderAggregateArgs> = {
        [P in keyof T & keyof AggregateDecider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecider[P]>
      : GetScalarType<T[P], AggregateDecider[P]>
  }




  export type DeciderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeciderWhereInput
    orderBy?: DeciderOrderByWithAggregationInput | DeciderOrderByWithAggregationInput[]
    by: DeciderScalarFieldEnum[] | DeciderScalarFieldEnum
    having?: DeciderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeciderCountAggregateInputType | true
    _avg?: DeciderAvgAggregateInputType
    _sum?: DeciderSumAggregateInputType
    _min?: DeciderMinAggregateInputType
    _max?: DeciderMaxAggregateInputType
  }

  export type DeciderGroupByOutputType = {
    id: number
    userId: number
    _count: DeciderCountAggregateOutputType | null
    _avg: DeciderAvgAggregateOutputType | null
    _sum: DeciderSumAggregateOutputType | null
    _min: DeciderMinAggregateOutputType | null
    _max: DeciderMaxAggregateOutputType | null
  }

  type GetDeciderGroupByPayload<T extends DeciderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeciderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeciderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeciderGroupByOutputType[P]>
            : GetScalarType<T[P], DeciderGroupByOutputType[P]>
        }
      >
    >


  export type DeciderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decider"]>

  export type DeciderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decider"]>

  export type DeciderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decider"]>

  export type DeciderSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type DeciderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["decider"]>
  export type DeciderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeciderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeciderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeciderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Decider"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
    }, ExtArgs["result"]["decider"]>
    composites: {}
  }

  type DeciderGetPayload<S extends boolean | null | undefined | DeciderDefaultArgs> = $Result.GetResult<Prisma.$DeciderPayload, S>

  type DeciderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeciderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeciderCountAggregateInputType | true
    }

  export interface DeciderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Decider'], meta: { name: 'Decider' } }
    /**
     * Find zero or one Decider that matches the filter.
     * @param {DeciderFindUniqueArgs} args - Arguments to find a Decider
     * @example
     * // Get one Decider
     * const decider = await prisma.decider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeciderFindUniqueArgs>(args: SelectSubset<T, DeciderFindUniqueArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Decider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeciderFindUniqueOrThrowArgs} args - Arguments to find a Decider
     * @example
     * // Get one Decider
     * const decider = await prisma.decider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeciderFindUniqueOrThrowArgs>(args: SelectSubset<T, DeciderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Decider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderFindFirstArgs} args - Arguments to find a Decider
     * @example
     * // Get one Decider
     * const decider = await prisma.decider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeciderFindFirstArgs>(args?: SelectSubset<T, DeciderFindFirstArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Decider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderFindFirstOrThrowArgs} args - Arguments to find a Decider
     * @example
     * // Get one Decider
     * const decider = await prisma.decider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeciderFindFirstOrThrowArgs>(args?: SelectSubset<T, DeciderFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Deciders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deciders
     * const deciders = await prisma.decider.findMany()
     * 
     * // Get first 10 Deciders
     * const deciders = await prisma.decider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deciderWithIdOnly = await prisma.decider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeciderFindManyArgs>(args?: SelectSubset<T, DeciderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Decider.
     * @param {DeciderCreateArgs} args - Arguments to create a Decider.
     * @example
     * // Create one Decider
     * const Decider = await prisma.decider.create({
     *   data: {
     *     // ... data to create a Decider
     *   }
     * })
     * 
     */
    create<T extends DeciderCreateArgs>(args: SelectSubset<T, DeciderCreateArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Deciders.
     * @param {DeciderCreateManyArgs} args - Arguments to create many Deciders.
     * @example
     * // Create many Deciders
     * const decider = await prisma.decider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeciderCreateManyArgs>(args?: SelectSubset<T, DeciderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deciders and returns the data saved in the database.
     * @param {DeciderCreateManyAndReturnArgs} args - Arguments to create many Deciders.
     * @example
     * // Create many Deciders
     * const decider = await prisma.decider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deciders and only return the `id`
     * const deciderWithIdOnly = await prisma.decider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeciderCreateManyAndReturnArgs>(args?: SelectSubset<T, DeciderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Decider.
     * @param {DeciderDeleteArgs} args - Arguments to delete one Decider.
     * @example
     * // Delete one Decider
     * const Decider = await prisma.decider.delete({
     *   where: {
     *     // ... filter to delete one Decider
     *   }
     * })
     * 
     */
    delete<T extends DeciderDeleteArgs>(args: SelectSubset<T, DeciderDeleteArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Decider.
     * @param {DeciderUpdateArgs} args - Arguments to update one Decider.
     * @example
     * // Update one Decider
     * const decider = await prisma.decider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeciderUpdateArgs>(args: SelectSubset<T, DeciderUpdateArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Deciders.
     * @param {DeciderDeleteManyArgs} args - Arguments to filter Deciders to delete.
     * @example
     * // Delete a few Deciders
     * const { count } = await prisma.decider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeciderDeleteManyArgs>(args?: SelectSubset<T, DeciderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deciders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deciders
     * const decider = await prisma.decider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeciderUpdateManyArgs>(args: SelectSubset<T, DeciderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deciders and returns the data updated in the database.
     * @param {DeciderUpdateManyAndReturnArgs} args - Arguments to update many Deciders.
     * @example
     * // Update many Deciders
     * const decider = await prisma.decider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deciders and only return the `id`
     * const deciderWithIdOnly = await prisma.decider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeciderUpdateManyAndReturnArgs>(args: SelectSubset<T, DeciderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Decider.
     * @param {DeciderUpsertArgs} args - Arguments to update or create a Decider.
     * @example
     * // Update or create a Decider
     * const decider = await prisma.decider.upsert({
     *   create: {
     *     // ... data to create a Decider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Decider we want to update
     *   }
     * })
     */
    upsert<T extends DeciderUpsertArgs>(args: SelectSubset<T, DeciderUpsertArgs<ExtArgs>>): Prisma__DeciderClient<$Result.GetResult<Prisma.$DeciderPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Deciders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderCountArgs} args - Arguments to filter Deciders to count.
     * @example
     * // Count the number of Deciders
     * const count = await prisma.decider.count({
     *   where: {
     *     // ... the filter for the Deciders we want to count
     *   }
     * })
    **/
    count<T extends DeciderCountArgs>(
      args?: Subset<T, DeciderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeciderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Decider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeciderAggregateArgs>(args: Subset<T, DeciderAggregateArgs>): Prisma.PrismaPromise<GetDeciderAggregateType<T>>

    /**
     * Group by Decider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeciderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeciderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeciderGroupByArgs['orderBy'] }
        : { orderBy?: DeciderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeciderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeciderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Decider model
   */
  readonly fields: DeciderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Decider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeciderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Decider model
   */ 
  interface DeciderFieldRefs {
    readonly id: FieldRef<"Decider", 'Int'>
    readonly userId: FieldRef<"Decider", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Decider findUnique
   */
  export type DeciderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    /**
     * Filter, which Decider to fetch.
     */
    where: DeciderWhereUniqueInput
  }

  /**
   * Decider findUniqueOrThrow
   */
  export type DeciderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    /**
     * Filter, which Decider to fetch.
     */
    where: DeciderWhereUniqueInput
  }

  /**
   * Decider findFirst
   */
  export type DeciderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    /**
     * Filter, which Decider to fetch.
     */
    where?: DeciderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deciders to fetch.
     */
    orderBy?: DeciderOrderByWithRelationInput | DeciderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deciders.
     */
    cursor?: DeciderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deciders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deciders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deciders.
     */
    distinct?: DeciderScalarFieldEnum | DeciderScalarFieldEnum[]
  }

  /**
   * Decider findFirstOrThrow
   */
  export type DeciderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    /**
     * Filter, which Decider to fetch.
     */
    where?: DeciderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deciders to fetch.
     */
    orderBy?: DeciderOrderByWithRelationInput | DeciderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deciders.
     */
    cursor?: DeciderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deciders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deciders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deciders.
     */
    distinct?: DeciderScalarFieldEnum | DeciderScalarFieldEnum[]
  }

  /**
   * Decider findMany
   */
  export type DeciderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    /**
     * Filter, which Deciders to fetch.
     */
    where?: DeciderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deciders to fetch.
     */
    orderBy?: DeciderOrderByWithRelationInput | DeciderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deciders.
     */
    cursor?: DeciderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deciders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deciders.
     */
    skip?: number
    distinct?: DeciderScalarFieldEnum | DeciderScalarFieldEnum[]
  }

  /**
   * Decider create
   */
  export type DeciderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    /**
     * The data needed to create a Decider.
     */
    data: XOR<DeciderCreateInput, DeciderUncheckedCreateInput>
  }

  /**
   * Decider createMany
   */
  export type DeciderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deciders.
     */
    data: DeciderCreateManyInput | DeciderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Decider createManyAndReturn
   */
  export type DeciderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * The data used to create many Deciders.
     */
    data: DeciderCreateManyInput | DeciderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Decider update
   */
  export type DeciderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    /**
     * The data needed to update a Decider.
     */
    data: XOR<DeciderUpdateInput, DeciderUncheckedUpdateInput>
    /**
     * Choose, which Decider to update.
     */
    where: DeciderWhereUniqueInput
  }

  /**
   * Decider updateMany
   */
  export type DeciderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deciders.
     */
    data: XOR<DeciderUpdateManyMutationInput, DeciderUncheckedUpdateManyInput>
    /**
     * Filter which Deciders to update
     */
    where?: DeciderWhereInput
    /**
     * Limit how many Deciders to update.
     */
    limit?: number
  }

  /**
   * Decider updateManyAndReturn
   */
  export type DeciderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * The data used to update Deciders.
     */
    data: XOR<DeciderUpdateManyMutationInput, DeciderUncheckedUpdateManyInput>
    /**
     * Filter which Deciders to update
     */
    where?: DeciderWhereInput
    /**
     * Limit how many Deciders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Decider upsert
   */
  export type DeciderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    /**
     * The filter to search for the Decider to update in case it exists.
     */
    where: DeciderWhereUniqueInput
    /**
     * In case the Decider found by the `where` argument doesn't exist, create a new Decider with this data.
     */
    create: XOR<DeciderCreateInput, DeciderUncheckedCreateInput>
    /**
     * In case the Decider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeciderUpdateInput, DeciderUncheckedUpdateInput>
  }

  /**
   * Decider delete
   */
  export type DeciderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
    /**
     * Filter which Decider to delete.
     */
    where: DeciderWhereUniqueInput
  }

  /**
   * Decider deleteMany
   */
  export type DeciderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deciders to delete
     */
    where?: DeciderWhereInput
    /**
     * Limit how many Deciders to delete.
     */
    limit?: number
  }

  /**
   * Decider without action
   */
  export type DeciderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decider
     */
    select?: DeciderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decider
     */
    omit?: DeciderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeciderInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    id: number | null
    battery: number | null
    price: number | null
    userId: number | null
  }

  export type DeviceSumAggregateOutputType = {
    id: number | null
    battery: number | null
    price: number | null
    userId: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: number | null
    type: string | null
    version: string | null
    macAdr: string | null
    status: $Enums.DeviceStatus | null
    battery: number | null
    price: number | null
    createdAt: Date | null
    userId: number | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: number | null
    type: string | null
    version: string | null
    macAdr: string | null
    status: $Enums.DeviceStatus | null
    battery: number | null
    price: number | null
    createdAt: Date | null
    userId: number | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    type: number
    version: number
    macAdr: number
    status: number
    battery: number
    lastPos: number
    price: number
    createdAt: number
    userId: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    id?: true
    battery?: true
    price?: true
    userId?: true
  }

  export type DeviceSumAggregateInputType = {
    id?: true
    battery?: true
    price?: true
    userId?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    type?: true
    version?: true
    macAdr?: true
    status?: true
    battery?: true
    price?: true
    createdAt?: true
    userId?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    type?: true
    version?: true
    macAdr?: true
    status?: true
    battery?: true
    price?: true
    createdAt?: true
    userId?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    type?: true
    version?: true
    macAdr?: true
    status?: true
    battery?: true
    lastPos?: true
    price?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: number
    type: string
    version: string
    macAdr: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos: JsonValue | null
    price: number | null
    createdAt: Date
    userId: number | null
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    version?: boolean
    macAdr?: boolean
    status?: boolean
    battery?: boolean
    lastPos?: boolean
    price?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | Device$userArgs<ExtArgs>
    sales?: boolean | Device$salesArgs<ExtArgs>
    userDeviceHistories?: boolean | Device$userDeviceHistoriesArgs<ExtArgs>
    interventions?: boolean | Device$interventionsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    version?: boolean
    macAdr?: boolean
    status?: boolean
    battery?: boolean
    lastPos?: boolean
    price?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | Device$userArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    version?: boolean
    macAdr?: boolean
    status?: boolean
    battery?: boolean
    lastPos?: boolean
    price?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | Device$userArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    type?: boolean
    version?: boolean
    macAdr?: boolean
    status?: boolean
    battery?: boolean
    lastPos?: boolean
    price?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type DeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "version" | "macAdr" | "status" | "battery" | "lastPos" | "price" | "createdAt" | "userId", ExtArgs["result"]["device"]>
  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Device$userArgs<ExtArgs>
    sales?: boolean | Device$salesArgs<ExtArgs>
    userDeviceHistories?: boolean | Device$userDeviceHistoriesArgs<ExtArgs>
    interventions?: boolean | Device$interventionsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Device$userArgs<ExtArgs>
  }
  export type DeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Device$userArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      user: Prisma.$EndUserPayload<ExtArgs> | null
      sales: Prisma.$SalePayload<ExtArgs>[]
      userDeviceHistories: Prisma.$UserDeviceHistoryPayload<ExtArgs>[]
      interventions: Prisma.$InterventionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      version: string
      macAdr: string | null
      status: $Enums.DeviceStatus
      battery: number
      lastPos: Prisma.JsonValue | null
      price: number | null
      createdAt: Date
      userId: number | null
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices and returns the data updated in the database.
     * @param {DeviceUpdateManyAndReturnArgs} args - Arguments to update many Devices.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Device$userArgs<ExtArgs> = {}>(args?: Subset<T, Device$userArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    sales<T extends Device$salesArgs<ExtArgs> = {}>(args?: Subset<T, Device$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    userDeviceHistories<T extends Device$userDeviceHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Device$userDeviceHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    interventions<T extends Device$interventionsArgs<ExtArgs> = {}>(args?: Subset<T, Device$interventionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */ 
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'Int'>
    readonly type: FieldRef<"Device", 'String'>
    readonly version: FieldRef<"Device", 'String'>
    readonly macAdr: FieldRef<"Device", 'String'>
    readonly status: FieldRef<"Device", 'DeviceStatus'>
    readonly battery: FieldRef<"Device", 'Int'>
    readonly lastPos: FieldRef<"Device", 'Json'>
    readonly price: FieldRef<"Device", 'Int'>
    readonly createdAt: FieldRef<"Device", 'DateTime'>
    readonly userId: FieldRef<"Device", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
  }

  /**
   * Device updateManyAndReturn
   */
  export type DeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to delete.
     */
    limit?: number
  }

  /**
   * Device.user
   */
  export type Device$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EndUser
     */
    select?: EndUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EndUser
     */
    omit?: EndUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EndUserInclude<ExtArgs> | null
    where?: EndUserWhereInput
  }

  /**
   * Device.sales
   */
  export type Device$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Device.userDeviceHistories
   */
  export type Device$userDeviceHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    where?: UserDeviceHistoryWhereInput
    orderBy?: UserDeviceHistoryOrderByWithRelationInput | UserDeviceHistoryOrderByWithRelationInput[]
    cursor?: UserDeviceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDeviceHistoryScalarFieldEnum | UserDeviceHistoryScalarFieldEnum[]
  }

  /**
   * Device.interventions
   */
  export type Device$interventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    cursor?: InterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: number | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: number | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    content: number
    isRead: number
    createdAt: number
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    content: string
    isRead: boolean
    createdAt: Date
    userId: number
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "isRead" | "createdAt" | "userId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      isRead: boolean
      createdAt: Date
      userId: number
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model UserDeviceHistory
   */

  export type AggregateUserDeviceHistory = {
    _count: UserDeviceHistoryCountAggregateOutputType | null
    _avg: UserDeviceHistoryAvgAggregateOutputType | null
    _sum: UserDeviceHistorySumAggregateOutputType | null
    _min: UserDeviceHistoryMinAggregateOutputType | null
    _max: UserDeviceHistoryMaxAggregateOutputType | null
  }

  export type UserDeviceHistoryAvgAggregateOutputType = {
    id: number | null
    deviceId: number | null
    userId: number | null
  }

  export type UserDeviceHistorySumAggregateOutputType = {
    id: number | null
    deviceId: number | null
    userId: number | null
  }

  export type UserDeviceHistoryMinAggregateOutputType = {
    id: number | null
    deviceId: number | null
    userId: number | null
    useDate: Date | null
  }

  export type UserDeviceHistoryMaxAggregateOutputType = {
    id: number | null
    deviceId: number | null
    userId: number | null
    useDate: Date | null
  }

  export type UserDeviceHistoryCountAggregateOutputType = {
    id: number
    deviceId: number
    userId: number
    useDate: number
    _all: number
  }


  export type UserDeviceHistoryAvgAggregateInputType = {
    id?: true
    deviceId?: true
    userId?: true
  }

  export type UserDeviceHistorySumAggregateInputType = {
    id?: true
    deviceId?: true
    userId?: true
  }

  export type UserDeviceHistoryMinAggregateInputType = {
    id?: true
    deviceId?: true
    userId?: true
    useDate?: true
  }

  export type UserDeviceHistoryMaxAggregateInputType = {
    id?: true
    deviceId?: true
    userId?: true
    useDate?: true
  }

  export type UserDeviceHistoryCountAggregateInputType = {
    id?: true
    deviceId?: true
    userId?: true
    useDate?: true
    _all?: true
  }

  export type UserDeviceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDeviceHistory to aggregate.
     */
    where?: UserDeviceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceHistories to fetch.
     */
    orderBy?: UserDeviceHistoryOrderByWithRelationInput | UserDeviceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDeviceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDeviceHistories
    **/
    _count?: true | UserDeviceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserDeviceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserDeviceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDeviceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDeviceHistoryMaxAggregateInputType
  }

  export type GetUserDeviceHistoryAggregateType<T extends UserDeviceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDeviceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDeviceHistory[P]>
      : GetScalarType<T[P], AggregateUserDeviceHistory[P]>
  }




  export type UserDeviceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDeviceHistoryWhereInput
    orderBy?: UserDeviceHistoryOrderByWithAggregationInput | UserDeviceHistoryOrderByWithAggregationInput[]
    by: UserDeviceHistoryScalarFieldEnum[] | UserDeviceHistoryScalarFieldEnum
    having?: UserDeviceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDeviceHistoryCountAggregateInputType | true
    _avg?: UserDeviceHistoryAvgAggregateInputType
    _sum?: UserDeviceHistorySumAggregateInputType
    _min?: UserDeviceHistoryMinAggregateInputType
    _max?: UserDeviceHistoryMaxAggregateInputType
  }

  export type UserDeviceHistoryGroupByOutputType = {
    id: number
    deviceId: number
    userId: number
    useDate: Date
    _count: UserDeviceHistoryCountAggregateOutputType | null
    _avg: UserDeviceHistoryAvgAggregateOutputType | null
    _sum: UserDeviceHistorySumAggregateOutputType | null
    _min: UserDeviceHistoryMinAggregateOutputType | null
    _max: UserDeviceHistoryMaxAggregateOutputType | null
  }

  type GetUserDeviceHistoryGroupByPayload<T extends UserDeviceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDeviceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDeviceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDeviceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserDeviceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserDeviceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    userId?: boolean
    useDate?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDeviceHistory"]>

  export type UserDeviceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    userId?: boolean
    useDate?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDeviceHistory"]>

  export type UserDeviceHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    userId?: boolean
    useDate?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDeviceHistory"]>

  export type UserDeviceHistorySelectScalar = {
    id?: boolean
    deviceId?: boolean
    userId?: boolean
    useDate?: boolean
  }

  export type UserDeviceHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deviceId" | "userId" | "useDate", ExtArgs["result"]["userDeviceHistory"]>
  export type UserDeviceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDeviceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDeviceHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserDeviceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDeviceHistory"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deviceId: number
      userId: number
      useDate: Date
    }, ExtArgs["result"]["userDeviceHistory"]>
    composites: {}
  }

  type UserDeviceHistoryGetPayload<S extends boolean | null | undefined | UserDeviceHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserDeviceHistoryPayload, S>

  type UserDeviceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserDeviceHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserDeviceHistoryCountAggregateInputType | true
    }

  export interface UserDeviceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDeviceHistory'], meta: { name: 'UserDeviceHistory' } }
    /**
     * Find zero or one UserDeviceHistory that matches the filter.
     * @param {UserDeviceHistoryFindUniqueArgs} args - Arguments to find a UserDeviceHistory
     * @example
     * // Get one UserDeviceHistory
     * const userDeviceHistory = await prisma.userDeviceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDeviceHistoryFindUniqueArgs>(args: SelectSubset<T, UserDeviceHistoryFindUniqueArgs<ExtArgs>>): Prisma__UserDeviceHistoryClient<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserDeviceHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserDeviceHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserDeviceHistory
     * @example
     * // Get one UserDeviceHistory
     * const userDeviceHistory = await prisma.userDeviceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDeviceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDeviceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDeviceHistoryClient<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserDeviceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceHistoryFindFirstArgs} args - Arguments to find a UserDeviceHistory
     * @example
     * // Get one UserDeviceHistory
     * const userDeviceHistory = await prisma.userDeviceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDeviceHistoryFindFirstArgs>(args?: SelectSubset<T, UserDeviceHistoryFindFirstArgs<ExtArgs>>): Prisma__UserDeviceHistoryClient<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserDeviceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceHistoryFindFirstOrThrowArgs} args - Arguments to find a UserDeviceHistory
     * @example
     * // Get one UserDeviceHistory
     * const userDeviceHistory = await prisma.userDeviceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDeviceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDeviceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDeviceHistoryClient<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserDeviceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDeviceHistories
     * const userDeviceHistories = await prisma.userDeviceHistory.findMany()
     * 
     * // Get first 10 UserDeviceHistories
     * const userDeviceHistories = await prisma.userDeviceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDeviceHistoryWithIdOnly = await prisma.userDeviceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserDeviceHistoryFindManyArgs>(args?: SelectSubset<T, UserDeviceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserDeviceHistory.
     * @param {UserDeviceHistoryCreateArgs} args - Arguments to create a UserDeviceHistory.
     * @example
     * // Create one UserDeviceHistory
     * const UserDeviceHistory = await prisma.userDeviceHistory.create({
     *   data: {
     *     // ... data to create a UserDeviceHistory
     *   }
     * })
     * 
     */
    create<T extends UserDeviceHistoryCreateArgs>(args: SelectSubset<T, UserDeviceHistoryCreateArgs<ExtArgs>>): Prisma__UserDeviceHistoryClient<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserDeviceHistories.
     * @param {UserDeviceHistoryCreateManyArgs} args - Arguments to create many UserDeviceHistories.
     * @example
     * // Create many UserDeviceHistories
     * const userDeviceHistory = await prisma.userDeviceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDeviceHistoryCreateManyArgs>(args?: SelectSubset<T, UserDeviceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDeviceHistories and returns the data saved in the database.
     * @param {UserDeviceHistoryCreateManyAndReturnArgs} args - Arguments to create many UserDeviceHistories.
     * @example
     * // Create many UserDeviceHistories
     * const userDeviceHistory = await prisma.userDeviceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDeviceHistories and only return the `id`
     * const userDeviceHistoryWithIdOnly = await prisma.userDeviceHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDeviceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDeviceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserDeviceHistory.
     * @param {UserDeviceHistoryDeleteArgs} args - Arguments to delete one UserDeviceHistory.
     * @example
     * // Delete one UserDeviceHistory
     * const UserDeviceHistory = await prisma.userDeviceHistory.delete({
     *   where: {
     *     // ... filter to delete one UserDeviceHistory
     *   }
     * })
     * 
     */
    delete<T extends UserDeviceHistoryDeleteArgs>(args: SelectSubset<T, UserDeviceHistoryDeleteArgs<ExtArgs>>): Prisma__UserDeviceHistoryClient<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserDeviceHistory.
     * @param {UserDeviceHistoryUpdateArgs} args - Arguments to update one UserDeviceHistory.
     * @example
     * // Update one UserDeviceHistory
     * const userDeviceHistory = await prisma.userDeviceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDeviceHistoryUpdateArgs>(args: SelectSubset<T, UserDeviceHistoryUpdateArgs<ExtArgs>>): Prisma__UserDeviceHistoryClient<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserDeviceHistories.
     * @param {UserDeviceHistoryDeleteManyArgs} args - Arguments to filter UserDeviceHistories to delete.
     * @example
     * // Delete a few UserDeviceHistories
     * const { count } = await prisma.userDeviceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeviceHistoryDeleteManyArgs>(args?: SelectSubset<T, UserDeviceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDeviceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDeviceHistories
     * const userDeviceHistory = await prisma.userDeviceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDeviceHistoryUpdateManyArgs>(args: SelectSubset<T, UserDeviceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDeviceHistories and returns the data updated in the database.
     * @param {UserDeviceHistoryUpdateManyAndReturnArgs} args - Arguments to update many UserDeviceHistories.
     * @example
     * // Update many UserDeviceHistories
     * const userDeviceHistory = await prisma.userDeviceHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserDeviceHistories and only return the `id`
     * const userDeviceHistoryWithIdOnly = await prisma.userDeviceHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserDeviceHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserDeviceHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserDeviceHistory.
     * @param {UserDeviceHistoryUpsertArgs} args - Arguments to update or create a UserDeviceHistory.
     * @example
     * // Update or create a UserDeviceHistory
     * const userDeviceHistory = await prisma.userDeviceHistory.upsert({
     *   create: {
     *     // ... data to create a UserDeviceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDeviceHistory we want to update
     *   }
     * })
     */
    upsert<T extends UserDeviceHistoryUpsertArgs>(args: SelectSubset<T, UserDeviceHistoryUpsertArgs<ExtArgs>>): Prisma__UserDeviceHistoryClient<$Result.GetResult<Prisma.$UserDeviceHistoryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserDeviceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceHistoryCountArgs} args - Arguments to filter UserDeviceHistories to count.
     * @example
     * // Count the number of UserDeviceHistories
     * const count = await prisma.userDeviceHistory.count({
     *   where: {
     *     // ... the filter for the UserDeviceHistories we want to count
     *   }
     * })
    **/
    count<T extends UserDeviceHistoryCountArgs>(
      args?: Subset<T, UserDeviceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDeviceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDeviceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDeviceHistoryAggregateArgs>(args: Subset<T, UserDeviceHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserDeviceHistoryAggregateType<T>>

    /**
     * Group by UserDeviceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDeviceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDeviceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserDeviceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDeviceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDeviceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDeviceHistory model
   */
  readonly fields: UserDeviceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDeviceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDeviceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDeviceHistory model
   */ 
  interface UserDeviceHistoryFieldRefs {
    readonly id: FieldRef<"UserDeviceHistory", 'Int'>
    readonly deviceId: FieldRef<"UserDeviceHistory", 'Int'>
    readonly userId: FieldRef<"UserDeviceHistory", 'Int'>
    readonly useDate: FieldRef<"UserDeviceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserDeviceHistory findUnique
   */
  export type UserDeviceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceHistory to fetch.
     */
    where: UserDeviceHistoryWhereUniqueInput
  }

  /**
   * UserDeviceHistory findUniqueOrThrow
   */
  export type UserDeviceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceHistory to fetch.
     */
    where: UserDeviceHistoryWhereUniqueInput
  }

  /**
   * UserDeviceHistory findFirst
   */
  export type UserDeviceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceHistory to fetch.
     */
    where?: UserDeviceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceHistories to fetch.
     */
    orderBy?: UserDeviceHistoryOrderByWithRelationInput | UserDeviceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDeviceHistories.
     */
    cursor?: UserDeviceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDeviceHistories.
     */
    distinct?: UserDeviceHistoryScalarFieldEnum | UserDeviceHistoryScalarFieldEnum[]
  }

  /**
   * UserDeviceHistory findFirstOrThrow
   */
  export type UserDeviceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceHistory to fetch.
     */
    where?: UserDeviceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceHistories to fetch.
     */
    orderBy?: UserDeviceHistoryOrderByWithRelationInput | UserDeviceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDeviceHistories.
     */
    cursor?: UserDeviceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDeviceHistories.
     */
    distinct?: UserDeviceHistoryScalarFieldEnum | UserDeviceHistoryScalarFieldEnum[]
  }

  /**
   * UserDeviceHistory findMany
   */
  export type UserDeviceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserDeviceHistories to fetch.
     */
    where?: UserDeviceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDeviceHistories to fetch.
     */
    orderBy?: UserDeviceHistoryOrderByWithRelationInput | UserDeviceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDeviceHistories.
     */
    cursor?: UserDeviceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDeviceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDeviceHistories.
     */
    skip?: number
    distinct?: UserDeviceHistoryScalarFieldEnum | UserDeviceHistoryScalarFieldEnum[]
  }

  /**
   * UserDeviceHistory create
   */
  export type UserDeviceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDeviceHistory.
     */
    data: XOR<UserDeviceHistoryCreateInput, UserDeviceHistoryUncheckedCreateInput>
  }

  /**
   * UserDeviceHistory createMany
   */
  export type UserDeviceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDeviceHistories.
     */
    data: UserDeviceHistoryCreateManyInput | UserDeviceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDeviceHistory createManyAndReturn
   */
  export type UserDeviceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserDeviceHistories.
     */
    data: UserDeviceHistoryCreateManyInput | UserDeviceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDeviceHistory update
   */
  export type UserDeviceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDeviceHistory.
     */
    data: XOR<UserDeviceHistoryUpdateInput, UserDeviceHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserDeviceHistory to update.
     */
    where: UserDeviceHistoryWhereUniqueInput
  }

  /**
   * UserDeviceHistory updateMany
   */
  export type UserDeviceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDeviceHistories.
     */
    data: XOR<UserDeviceHistoryUpdateManyMutationInput, UserDeviceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserDeviceHistories to update
     */
    where?: UserDeviceHistoryWhereInput
    /**
     * Limit how many UserDeviceHistories to update.
     */
    limit?: number
  }

  /**
   * UserDeviceHistory updateManyAndReturn
   */
  export type UserDeviceHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * The data used to update UserDeviceHistories.
     */
    data: XOR<UserDeviceHistoryUpdateManyMutationInput, UserDeviceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserDeviceHistories to update
     */
    where?: UserDeviceHistoryWhereInput
    /**
     * Limit how many UserDeviceHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDeviceHistory upsert
   */
  export type UserDeviceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDeviceHistory to update in case it exists.
     */
    where: UserDeviceHistoryWhereUniqueInput
    /**
     * In case the UserDeviceHistory found by the `where` argument doesn't exist, create a new UserDeviceHistory with this data.
     */
    create: XOR<UserDeviceHistoryCreateInput, UserDeviceHistoryUncheckedCreateInput>
    /**
     * In case the UserDeviceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDeviceHistoryUpdateInput, UserDeviceHistoryUncheckedUpdateInput>
  }

  /**
   * UserDeviceHistory delete
   */
  export type UserDeviceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
    /**
     * Filter which UserDeviceHistory to delete.
     */
    where: UserDeviceHistoryWhereUniqueInput
  }

  /**
   * UserDeviceHistory deleteMany
   */
  export type UserDeviceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDeviceHistories to delete
     */
    where?: UserDeviceHistoryWhereInput
    /**
     * Limit how many UserDeviceHistories to delete.
     */
    limit?: number
  }

  /**
   * UserDeviceHistory without action
   */
  export type UserDeviceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceHistory
     */
    select?: UserDeviceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDeviceHistory
     */
    omit?: UserDeviceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Environment
   */

  export type AggregateEnvironment = {
    _count: EnvironmentCountAggregateOutputType | null
    _avg: EnvironmentAvgAggregateOutputType | null
    _sum: EnvironmentSumAggregateOutputType | null
    _min: EnvironmentMinAggregateOutputType | null
    _max: EnvironmentMaxAggregateOutputType | null
  }

  export type EnvironmentAvgAggregateOutputType = {
    id: number | null
    scale: number | null
  }

  export type EnvironmentSumAggregateOutputType = {
    id: number | null
    scale: number | null
  }

  export type EnvironmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    pathCartographie: string | null
    createdAt: Date | null
    scale: number | null
  }

  export type EnvironmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    pathCartographie: string | null
    createdAt: Date | null
    scale: number | null
  }

  export type EnvironmentCountAggregateOutputType = {
    id: number
    name: number
    address: number
    cords: number
    pathCartographie: number
    createdAt: number
    scale: number
    _all: number
  }


  export type EnvironmentAvgAggregateInputType = {
    id?: true
    scale?: true
  }

  export type EnvironmentSumAggregateInputType = {
    id?: true
    scale?: true
  }

  export type EnvironmentMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    pathCartographie?: true
    createdAt?: true
    scale?: true
  }

  export type EnvironmentMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    pathCartographie?: true
    createdAt?: true
    scale?: true
  }

  export type EnvironmentCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    cords?: true
    pathCartographie?: true
    createdAt?: true
    scale?: true
    _all?: true
  }

  export type EnvironmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Environment to aggregate.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Environments
    **/
    _count?: true | EnvironmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnvironmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnvironmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvironmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvironmentMaxAggregateInputType
  }

  export type GetEnvironmentAggregateType<T extends EnvironmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvironment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvironment[P]>
      : GetScalarType<T[P], AggregateEnvironment[P]>
  }




  export type EnvironmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvironmentWhereInput
    orderBy?: EnvironmentOrderByWithAggregationInput | EnvironmentOrderByWithAggregationInput[]
    by: EnvironmentScalarFieldEnum[] | EnvironmentScalarFieldEnum
    having?: EnvironmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvironmentCountAggregateInputType | true
    _avg?: EnvironmentAvgAggregateInputType
    _sum?: EnvironmentSumAggregateInputType
    _min?: EnvironmentMinAggregateInputType
    _max?: EnvironmentMaxAggregateInputType
  }

  export type EnvironmentGroupByOutputType = {
    id: number
    name: string
    address: string
    cords: JsonValue
    pathCartographie: string
    createdAt: Date
    scale: number
    _count: EnvironmentCountAggregateOutputType | null
    _avg: EnvironmentAvgAggregateOutputType | null
    _sum: EnvironmentSumAggregateOutputType | null
    _min: EnvironmentMinAggregateOutputType | null
    _max: EnvironmentMaxAggregateOutputType | null
  }

  type GetEnvironmentGroupByPayload<T extends EnvironmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvironmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvironmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
        }
      >
    >


  export type EnvironmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    cords?: boolean
    pathCartographie?: boolean
    createdAt?: boolean
    scale?: boolean
    zones?: boolean | Environment$zonesArgs<ExtArgs>
    obstacles?: boolean | Environment$obstaclesArgs<ExtArgs>
    envUsers?: boolean | Environment$envUsersArgs<ExtArgs>
    routes?: boolean | Environment$routesArgs<ExtArgs>
    _count?: boolean | EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["environment"]>

  export type EnvironmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    cords?: boolean
    pathCartographie?: boolean
    createdAt?: boolean
    scale?: boolean
  }, ExtArgs["result"]["environment"]>

  export type EnvironmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    cords?: boolean
    pathCartographie?: boolean
    createdAt?: boolean
    scale?: boolean
  }, ExtArgs["result"]["environment"]>

  export type EnvironmentSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    cords?: boolean
    pathCartographie?: boolean
    createdAt?: boolean
    scale?: boolean
  }

  export type EnvironmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "cords" | "pathCartographie" | "createdAt" | "scale", ExtArgs["result"]["environment"]>
  export type EnvironmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | Environment$zonesArgs<ExtArgs>
    obstacles?: boolean | Environment$obstaclesArgs<ExtArgs>
    envUsers?: boolean | Environment$envUsersArgs<ExtArgs>
    routes?: boolean | Environment$routesArgs<ExtArgs>
    _count?: boolean | EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnvironmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EnvironmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EnvironmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Environment"
    objects: {
      zones: Prisma.$ZonePayload<ExtArgs>[]
      obstacles: Prisma.$ObstaclePayload<ExtArgs>[]
      envUsers: Prisma.$EnvUserPayload<ExtArgs>[]
      routes: Prisma.$ItineraryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
      cords: Prisma.JsonValue
      pathCartographie: string
      createdAt: Date
      scale: number
    }, ExtArgs["result"]["environment"]>
    composites: {}
  }

  type EnvironmentGetPayload<S extends boolean | null | undefined | EnvironmentDefaultArgs> = $Result.GetResult<Prisma.$EnvironmentPayload, S>

  type EnvironmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnvironmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnvironmentCountAggregateInputType | true
    }

  export interface EnvironmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Environment'], meta: { name: 'Environment' } }
    /**
     * Find zero or one Environment that matches the filter.
     * @param {EnvironmentFindUniqueArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnvironmentFindUniqueArgs>(args: SelectSubset<T, EnvironmentFindUniqueArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Environment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnvironmentFindUniqueOrThrowArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnvironmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnvironmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Environment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentFindFirstArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnvironmentFindFirstArgs>(args?: SelectSubset<T, EnvironmentFindFirstArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Environment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentFindFirstOrThrowArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnvironmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnvironmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Environments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Environments
     * const environments = await prisma.environment.findMany()
     * 
     * // Get first 10 Environments
     * const environments = await prisma.environment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const environmentWithIdOnly = await prisma.environment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnvironmentFindManyArgs>(args?: SelectSubset<T, EnvironmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Environment.
     * @param {EnvironmentCreateArgs} args - Arguments to create a Environment.
     * @example
     * // Create one Environment
     * const Environment = await prisma.environment.create({
     *   data: {
     *     // ... data to create a Environment
     *   }
     * })
     * 
     */
    create<T extends EnvironmentCreateArgs>(args: SelectSubset<T, EnvironmentCreateArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Environments.
     * @param {EnvironmentCreateManyArgs} args - Arguments to create many Environments.
     * @example
     * // Create many Environments
     * const environment = await prisma.environment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnvironmentCreateManyArgs>(args?: SelectSubset<T, EnvironmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Environments and returns the data saved in the database.
     * @param {EnvironmentCreateManyAndReturnArgs} args - Arguments to create many Environments.
     * @example
     * // Create many Environments
     * const environment = await prisma.environment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Environments and only return the `id`
     * const environmentWithIdOnly = await prisma.environment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnvironmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnvironmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Environment.
     * @param {EnvironmentDeleteArgs} args - Arguments to delete one Environment.
     * @example
     * // Delete one Environment
     * const Environment = await prisma.environment.delete({
     *   where: {
     *     // ... filter to delete one Environment
     *   }
     * })
     * 
     */
    delete<T extends EnvironmentDeleteArgs>(args: SelectSubset<T, EnvironmentDeleteArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Environment.
     * @param {EnvironmentUpdateArgs} args - Arguments to update one Environment.
     * @example
     * // Update one Environment
     * const environment = await prisma.environment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnvironmentUpdateArgs>(args: SelectSubset<T, EnvironmentUpdateArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Environments.
     * @param {EnvironmentDeleteManyArgs} args - Arguments to filter Environments to delete.
     * @example
     * // Delete a few Environments
     * const { count } = await prisma.environment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnvironmentDeleteManyArgs>(args?: SelectSubset<T, EnvironmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Environments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Environments
     * const environment = await prisma.environment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnvironmentUpdateManyArgs>(args: SelectSubset<T, EnvironmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Environments and returns the data updated in the database.
     * @param {EnvironmentUpdateManyAndReturnArgs} args - Arguments to update many Environments.
     * @example
     * // Update many Environments
     * const environment = await prisma.environment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Environments and only return the `id`
     * const environmentWithIdOnly = await prisma.environment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnvironmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EnvironmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Environment.
     * @param {EnvironmentUpsertArgs} args - Arguments to update or create a Environment.
     * @example
     * // Update or create a Environment
     * const environment = await prisma.environment.upsert({
     *   create: {
     *     // ... data to create a Environment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Environment we want to update
     *   }
     * })
     */
    upsert<T extends EnvironmentUpsertArgs>(args: SelectSubset<T, EnvironmentUpsertArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Environments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentCountArgs} args - Arguments to filter Environments to count.
     * @example
     * // Count the number of Environments
     * const count = await prisma.environment.count({
     *   where: {
     *     // ... the filter for the Environments we want to count
     *   }
     * })
    **/
    count<T extends EnvironmentCountArgs>(
      args?: Subset<T, EnvironmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvironmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Environment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvironmentAggregateArgs>(args: Subset<T, EnvironmentAggregateArgs>): Prisma.PrismaPromise<GetEnvironmentAggregateType<T>>

    /**
     * Group by Environment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvironmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvironmentGroupByArgs['orderBy'] }
        : { orderBy?: EnvironmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvironmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvironmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Environment model
   */
  readonly fields: EnvironmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Environment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnvironmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zones<T extends Environment$zonesArgs<ExtArgs> = {}>(args?: Subset<T, Environment$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    obstacles<T extends Environment$obstaclesArgs<ExtArgs> = {}>(args?: Subset<T, Environment$obstaclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    envUsers<T extends Environment$envUsersArgs<ExtArgs> = {}>(args?: Subset<T, Environment$envUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    routes<T extends Environment$routesArgs<ExtArgs> = {}>(args?: Subset<T, Environment$routesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Environment model
   */ 
  interface EnvironmentFieldRefs {
    readonly id: FieldRef<"Environment", 'Int'>
    readonly name: FieldRef<"Environment", 'String'>
    readonly address: FieldRef<"Environment", 'String'>
    readonly cords: FieldRef<"Environment", 'Json'>
    readonly pathCartographie: FieldRef<"Environment", 'String'>
    readonly createdAt: FieldRef<"Environment", 'DateTime'>
    readonly scale: FieldRef<"Environment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Environment findUnique
   */
  export type EnvironmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where: EnvironmentWhereUniqueInput
  }

  /**
   * Environment findUniqueOrThrow
   */
  export type EnvironmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where: EnvironmentWhereUniqueInput
  }

  /**
   * Environment findFirst
   */
  export type EnvironmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Environments.
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Environments.
     */
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * Environment findFirstOrThrow
   */
  export type EnvironmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Environments.
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Environments.
     */
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * Environment findMany
   */
  export type EnvironmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environments to fetch.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Environments.
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * Environment create
   */
  export type EnvironmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Environment.
     */
    data: XOR<EnvironmentCreateInput, EnvironmentUncheckedCreateInput>
  }

  /**
   * Environment createMany
   */
  export type EnvironmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Environments.
     */
    data: EnvironmentCreateManyInput | EnvironmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Environment createManyAndReturn
   */
  export type EnvironmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * The data used to create many Environments.
     */
    data: EnvironmentCreateManyInput | EnvironmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Environment update
   */
  export type EnvironmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Environment.
     */
    data: XOR<EnvironmentUpdateInput, EnvironmentUncheckedUpdateInput>
    /**
     * Choose, which Environment to update.
     */
    where: EnvironmentWhereUniqueInput
  }

  /**
   * Environment updateMany
   */
  export type EnvironmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Environments.
     */
    data: XOR<EnvironmentUpdateManyMutationInput, EnvironmentUncheckedUpdateManyInput>
    /**
     * Filter which Environments to update
     */
    where?: EnvironmentWhereInput
    /**
     * Limit how many Environments to update.
     */
    limit?: number
  }

  /**
   * Environment updateManyAndReturn
   */
  export type EnvironmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * The data used to update Environments.
     */
    data: XOR<EnvironmentUpdateManyMutationInput, EnvironmentUncheckedUpdateManyInput>
    /**
     * Filter which Environments to update
     */
    where?: EnvironmentWhereInput
    /**
     * Limit how many Environments to update.
     */
    limit?: number
  }

  /**
   * Environment upsert
   */
  export type EnvironmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Environment to update in case it exists.
     */
    where: EnvironmentWhereUniqueInput
    /**
     * In case the Environment found by the `where` argument doesn't exist, create a new Environment with this data.
     */
    create: XOR<EnvironmentCreateInput, EnvironmentUncheckedCreateInput>
    /**
     * In case the Environment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvironmentUpdateInput, EnvironmentUncheckedUpdateInput>
  }

  /**
   * Environment delete
   */
  export type EnvironmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter which Environment to delete.
     */
    where: EnvironmentWhereUniqueInput
  }

  /**
   * Environment deleteMany
   */
  export type EnvironmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Environments to delete
     */
    where?: EnvironmentWhereInput
    /**
     * Limit how many Environments to delete.
     */
    limit?: number
  }

  /**
   * Environment.zones
   */
  export type Environment$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    cursor?: ZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Environment.obstacles
   */
  export type Environment$obstaclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    where?: ObstacleWhereInput
    orderBy?: ObstacleOrderByWithRelationInput | ObstacleOrderByWithRelationInput[]
    cursor?: ObstacleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObstacleScalarFieldEnum | ObstacleScalarFieldEnum[]
  }

  /**
   * Environment.envUsers
   */
  export type Environment$envUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    where?: EnvUserWhereInput
    orderBy?: EnvUserOrderByWithRelationInput | EnvUserOrderByWithRelationInput[]
    cursor?: EnvUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvUserScalarFieldEnum | EnvUserScalarFieldEnum[]
  }

  /**
   * Environment.routes
   */
  export type Environment$routesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Environment without action
   */
  export type EnvironmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Environment
     */
    omit?: EnvironmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
  }


  /**
   * Model EnvUser
   */

  export type AggregateEnvUser = {
    _count: EnvUserCountAggregateOutputType | null
    _avg: EnvUserAvgAggregateOutputType | null
    _sum: EnvUserSumAggregateOutputType | null
    _min: EnvUserMinAggregateOutputType | null
    _max: EnvUserMaxAggregateOutputType | null
  }

  export type EnvUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    envId: number | null
  }

  export type EnvUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
    envId: number | null
  }

  export type EnvUserMinAggregateOutputType = {
    id: number | null
    userId: number | null
    envId: number | null
  }

  export type EnvUserMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    envId: number | null
  }

  export type EnvUserCountAggregateOutputType = {
    id: number
    userId: number
    envId: number
    _all: number
  }


  export type EnvUserAvgAggregateInputType = {
    id?: true
    userId?: true
    envId?: true
  }

  export type EnvUserSumAggregateInputType = {
    id?: true
    userId?: true
    envId?: true
  }

  export type EnvUserMinAggregateInputType = {
    id?: true
    userId?: true
    envId?: true
  }

  export type EnvUserMaxAggregateInputType = {
    id?: true
    userId?: true
    envId?: true
  }

  export type EnvUserCountAggregateInputType = {
    id?: true
    userId?: true
    envId?: true
    _all?: true
  }

  export type EnvUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnvUser to aggregate.
     */
    where?: EnvUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvUsers to fetch.
     */
    orderBy?: EnvUserOrderByWithRelationInput | EnvUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnvUsers
    **/
    _count?: true | EnvUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnvUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnvUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvUserMaxAggregateInputType
  }

  export type GetEnvUserAggregateType<T extends EnvUserAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvUser[P]>
      : GetScalarType<T[P], AggregateEnvUser[P]>
  }




  export type EnvUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvUserWhereInput
    orderBy?: EnvUserOrderByWithAggregationInput | EnvUserOrderByWithAggregationInput[]
    by: EnvUserScalarFieldEnum[] | EnvUserScalarFieldEnum
    having?: EnvUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvUserCountAggregateInputType | true
    _avg?: EnvUserAvgAggregateInputType
    _sum?: EnvUserSumAggregateInputType
    _min?: EnvUserMinAggregateInputType
    _max?: EnvUserMaxAggregateInputType
  }

  export type EnvUserGroupByOutputType = {
    id: number
    userId: number
    envId: number
    _count: EnvUserCountAggregateOutputType | null
    _avg: EnvUserAvgAggregateOutputType | null
    _sum: EnvUserSumAggregateOutputType | null
    _min: EnvUserMinAggregateOutputType | null
    _max: EnvUserMaxAggregateOutputType | null
  }

  type GetEnvUserGroupByPayload<T extends EnvUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvUserGroupByOutputType[P]>
            : GetScalarType<T[P], EnvUserGroupByOutputType[P]>
        }
      >
    >


  export type EnvUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    envId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["envUser"]>

  export type EnvUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    envId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["envUser"]>

  export type EnvUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    envId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["envUser"]>

  export type EnvUserSelectScalar = {
    id?: boolean
    userId?: boolean
    envId?: boolean
  }

  export type EnvUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "envId", ExtArgs["result"]["envUser"]>
  export type EnvUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }
  export type EnvUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }
  export type EnvUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }

  export type $EnvUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnvUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      environment: Prisma.$EnvironmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      envId: number
    }, ExtArgs["result"]["envUser"]>
    composites: {}
  }

  type EnvUserGetPayload<S extends boolean | null | undefined | EnvUserDefaultArgs> = $Result.GetResult<Prisma.$EnvUserPayload, S>

  type EnvUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnvUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnvUserCountAggregateInputType | true
    }

  export interface EnvUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnvUser'], meta: { name: 'EnvUser' } }
    /**
     * Find zero or one EnvUser that matches the filter.
     * @param {EnvUserFindUniqueArgs} args - Arguments to find a EnvUser
     * @example
     * // Get one EnvUser
     * const envUser = await prisma.envUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnvUserFindUniqueArgs>(args: SelectSubset<T, EnvUserFindUniqueArgs<ExtArgs>>): Prisma__EnvUserClient<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EnvUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnvUserFindUniqueOrThrowArgs} args - Arguments to find a EnvUser
     * @example
     * // Get one EnvUser
     * const envUser = await prisma.envUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnvUserFindUniqueOrThrowArgs>(args: SelectSubset<T, EnvUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnvUserClient<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EnvUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvUserFindFirstArgs} args - Arguments to find a EnvUser
     * @example
     * // Get one EnvUser
     * const envUser = await prisma.envUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnvUserFindFirstArgs>(args?: SelectSubset<T, EnvUserFindFirstArgs<ExtArgs>>): Prisma__EnvUserClient<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EnvUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvUserFindFirstOrThrowArgs} args - Arguments to find a EnvUser
     * @example
     * // Get one EnvUser
     * const envUser = await prisma.envUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnvUserFindFirstOrThrowArgs>(args?: SelectSubset<T, EnvUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnvUserClient<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EnvUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnvUsers
     * const envUsers = await prisma.envUser.findMany()
     * 
     * // Get first 10 EnvUsers
     * const envUsers = await prisma.envUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const envUserWithIdOnly = await prisma.envUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnvUserFindManyArgs>(args?: SelectSubset<T, EnvUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EnvUser.
     * @param {EnvUserCreateArgs} args - Arguments to create a EnvUser.
     * @example
     * // Create one EnvUser
     * const EnvUser = await prisma.envUser.create({
     *   data: {
     *     // ... data to create a EnvUser
     *   }
     * })
     * 
     */
    create<T extends EnvUserCreateArgs>(args: SelectSubset<T, EnvUserCreateArgs<ExtArgs>>): Prisma__EnvUserClient<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EnvUsers.
     * @param {EnvUserCreateManyArgs} args - Arguments to create many EnvUsers.
     * @example
     * // Create many EnvUsers
     * const envUser = await prisma.envUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnvUserCreateManyArgs>(args?: SelectSubset<T, EnvUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnvUsers and returns the data saved in the database.
     * @param {EnvUserCreateManyAndReturnArgs} args - Arguments to create many EnvUsers.
     * @example
     * // Create many EnvUsers
     * const envUser = await prisma.envUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnvUsers and only return the `id`
     * const envUserWithIdOnly = await prisma.envUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnvUserCreateManyAndReturnArgs>(args?: SelectSubset<T, EnvUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EnvUser.
     * @param {EnvUserDeleteArgs} args - Arguments to delete one EnvUser.
     * @example
     * // Delete one EnvUser
     * const EnvUser = await prisma.envUser.delete({
     *   where: {
     *     // ... filter to delete one EnvUser
     *   }
     * })
     * 
     */
    delete<T extends EnvUserDeleteArgs>(args: SelectSubset<T, EnvUserDeleteArgs<ExtArgs>>): Prisma__EnvUserClient<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EnvUser.
     * @param {EnvUserUpdateArgs} args - Arguments to update one EnvUser.
     * @example
     * // Update one EnvUser
     * const envUser = await prisma.envUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnvUserUpdateArgs>(args: SelectSubset<T, EnvUserUpdateArgs<ExtArgs>>): Prisma__EnvUserClient<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EnvUsers.
     * @param {EnvUserDeleteManyArgs} args - Arguments to filter EnvUsers to delete.
     * @example
     * // Delete a few EnvUsers
     * const { count } = await prisma.envUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnvUserDeleteManyArgs>(args?: SelectSubset<T, EnvUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnvUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnvUsers
     * const envUser = await prisma.envUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnvUserUpdateManyArgs>(args: SelectSubset<T, EnvUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnvUsers and returns the data updated in the database.
     * @param {EnvUserUpdateManyAndReturnArgs} args - Arguments to update many EnvUsers.
     * @example
     * // Update many EnvUsers
     * const envUser = await prisma.envUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EnvUsers and only return the `id`
     * const envUserWithIdOnly = await prisma.envUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnvUserUpdateManyAndReturnArgs>(args: SelectSubset<T, EnvUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EnvUser.
     * @param {EnvUserUpsertArgs} args - Arguments to update or create a EnvUser.
     * @example
     * // Update or create a EnvUser
     * const envUser = await prisma.envUser.upsert({
     *   create: {
     *     // ... data to create a EnvUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnvUser we want to update
     *   }
     * })
     */
    upsert<T extends EnvUserUpsertArgs>(args: SelectSubset<T, EnvUserUpsertArgs<ExtArgs>>): Prisma__EnvUserClient<$Result.GetResult<Prisma.$EnvUserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EnvUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvUserCountArgs} args - Arguments to filter EnvUsers to count.
     * @example
     * // Count the number of EnvUsers
     * const count = await prisma.envUser.count({
     *   where: {
     *     // ... the filter for the EnvUsers we want to count
     *   }
     * })
    **/
    count<T extends EnvUserCountArgs>(
      args?: Subset<T, EnvUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnvUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvUserAggregateArgs>(args: Subset<T, EnvUserAggregateArgs>): Prisma.PrismaPromise<GetEnvUserAggregateType<T>>

    /**
     * Group by EnvUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvUserGroupByArgs['orderBy'] }
        : { orderBy?: EnvUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnvUser model
   */
  readonly fields: EnvUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnvUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnvUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    environment<T extends EnvironmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvironmentDefaultArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnvUser model
   */ 
  interface EnvUserFieldRefs {
    readonly id: FieldRef<"EnvUser", 'Int'>
    readonly userId: FieldRef<"EnvUser", 'Int'>
    readonly envId: FieldRef<"EnvUser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EnvUser findUnique
   */
  export type EnvUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    /**
     * Filter, which EnvUser to fetch.
     */
    where: EnvUserWhereUniqueInput
  }

  /**
   * EnvUser findUniqueOrThrow
   */
  export type EnvUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    /**
     * Filter, which EnvUser to fetch.
     */
    where: EnvUserWhereUniqueInput
  }

  /**
   * EnvUser findFirst
   */
  export type EnvUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    /**
     * Filter, which EnvUser to fetch.
     */
    where?: EnvUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvUsers to fetch.
     */
    orderBy?: EnvUserOrderByWithRelationInput | EnvUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnvUsers.
     */
    cursor?: EnvUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnvUsers.
     */
    distinct?: EnvUserScalarFieldEnum | EnvUserScalarFieldEnum[]
  }

  /**
   * EnvUser findFirstOrThrow
   */
  export type EnvUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    /**
     * Filter, which EnvUser to fetch.
     */
    where?: EnvUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvUsers to fetch.
     */
    orderBy?: EnvUserOrderByWithRelationInput | EnvUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnvUsers.
     */
    cursor?: EnvUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnvUsers.
     */
    distinct?: EnvUserScalarFieldEnum | EnvUserScalarFieldEnum[]
  }

  /**
   * EnvUser findMany
   */
  export type EnvUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    /**
     * Filter, which EnvUsers to fetch.
     */
    where?: EnvUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvUsers to fetch.
     */
    orderBy?: EnvUserOrderByWithRelationInput | EnvUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnvUsers.
     */
    cursor?: EnvUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvUsers.
     */
    skip?: number
    distinct?: EnvUserScalarFieldEnum | EnvUserScalarFieldEnum[]
  }

  /**
   * EnvUser create
   */
  export type EnvUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    /**
     * The data needed to create a EnvUser.
     */
    data: XOR<EnvUserCreateInput, EnvUserUncheckedCreateInput>
  }

  /**
   * EnvUser createMany
   */
  export type EnvUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnvUsers.
     */
    data: EnvUserCreateManyInput | EnvUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnvUser createManyAndReturn
   */
  export type EnvUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * The data used to create many EnvUsers.
     */
    data: EnvUserCreateManyInput | EnvUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnvUser update
   */
  export type EnvUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    /**
     * The data needed to update a EnvUser.
     */
    data: XOR<EnvUserUpdateInput, EnvUserUncheckedUpdateInput>
    /**
     * Choose, which EnvUser to update.
     */
    where: EnvUserWhereUniqueInput
  }

  /**
   * EnvUser updateMany
   */
  export type EnvUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnvUsers.
     */
    data: XOR<EnvUserUpdateManyMutationInput, EnvUserUncheckedUpdateManyInput>
    /**
     * Filter which EnvUsers to update
     */
    where?: EnvUserWhereInput
    /**
     * Limit how many EnvUsers to update.
     */
    limit?: number
  }

  /**
   * EnvUser updateManyAndReturn
   */
  export type EnvUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * The data used to update EnvUsers.
     */
    data: XOR<EnvUserUpdateManyMutationInput, EnvUserUncheckedUpdateManyInput>
    /**
     * Filter which EnvUsers to update
     */
    where?: EnvUserWhereInput
    /**
     * Limit how many EnvUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnvUser upsert
   */
  export type EnvUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    /**
     * The filter to search for the EnvUser to update in case it exists.
     */
    where: EnvUserWhereUniqueInput
    /**
     * In case the EnvUser found by the `where` argument doesn't exist, create a new EnvUser with this data.
     */
    create: XOR<EnvUserCreateInput, EnvUserUncheckedCreateInput>
    /**
     * In case the EnvUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvUserUpdateInput, EnvUserUncheckedUpdateInput>
  }

  /**
   * EnvUser delete
   */
  export type EnvUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
    /**
     * Filter which EnvUser to delete.
     */
    where: EnvUserWhereUniqueInput
  }

  /**
   * EnvUser deleteMany
   */
  export type EnvUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnvUsers to delete
     */
    where?: EnvUserWhereInput
    /**
     * Limit how many EnvUsers to delete.
     */
    limit?: number
  }

  /**
   * EnvUser without action
   */
  export type EnvUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvUser
     */
    select?: EnvUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvUser
     */
    omit?: EnvUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvUserInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneAvgAggregateOutputType = {
    id: number | null
    envId: number | null
  }

  export type ZoneSumAggregateOutputType = {
    id: number | null
    envId: number | null
  }

  export type ZoneMinAggregateOutputType = {
    id: number | null
    envId: number | null
    name: string | null
    type: $Enums.ZoneType | null
    createdAt: Date | null
    color: string | null
    icon: string | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: number | null
    envId: number | null
    name: string | null
    type: $Enums.ZoneType | null
    createdAt: Date | null
    color: string | null
    icon: string | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    envId: number
    name: number
    type: number
    createdAt: number
    color: number
    icon: number
    cords: number
    _all: number
  }


  export type ZoneAvgAggregateInputType = {
    id?: true
    envId?: true
  }

  export type ZoneSumAggregateInputType = {
    id?: true
    envId?: true
  }

  export type ZoneMinAggregateInputType = {
    id?: true
    envId?: true
    name?: true
    type?: true
    createdAt?: true
    color?: true
    icon?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    envId?: true
    name?: true
    type?: true
    createdAt?: true
    color?: true
    icon?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    envId?: true
    name?: true
    type?: true
    createdAt?: true
    color?: true
    icon?: true
    cords?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _avg?: ZoneAvgAggregateInputType
    _sum?: ZoneSumAggregateInputType
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: number
    envId: number
    name: string
    type: $Enums.ZoneType
    createdAt: Date
    color: string
    icon: string
    cords: JsonValue
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envId?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    color?: boolean
    icon?: boolean
    cords?: boolean
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
    pois?: boolean | Zone$poisArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envId?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    color?: boolean
    icon?: boolean
    cords?: boolean
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envId?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    color?: boolean
    icon?: boolean
    cords?: boolean
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    envId?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    color?: boolean
    icon?: boolean
    cords?: boolean
  }

  export type ZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "envId" | "name" | "type" | "createdAt" | "color" | "icon" | "cords", ExtArgs["result"]["zone"]>
  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
    pois?: boolean | Zone$poisArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      environment: Prisma.$EnvironmentPayload<ExtArgs>
      pois: Prisma.$POIPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      envId: number
      name: string
      type: $Enums.ZoneType
      createdAt: Date
      color: string
      icon: string
      cords: Prisma.JsonValue
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {ZoneUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    environment<T extends EnvironmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvironmentDefaultArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    pois<T extends Zone$poisArgs<ExtArgs> = {}>(args?: Subset<T, Zone$poisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */ 
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'Int'>
    readonly envId: FieldRef<"Zone", 'Int'>
    readonly name: FieldRef<"Zone", 'String'>
    readonly type: FieldRef<"Zone", 'ZoneType'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly color: FieldRef<"Zone", 'String'>
    readonly icon: FieldRef<"Zone", 'String'>
    readonly cords: FieldRef<"Zone", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
  }

  /**
   * Zone updateManyAndReturn
   */
  export type ZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to delete.
     */
    limit?: number
  }

  /**
   * Zone.pois
   */
  export type Zone$poisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    where?: POIWhereInput
    orderBy?: POIOrderByWithRelationInput | POIOrderByWithRelationInput[]
    cursor?: POIWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POIScalarFieldEnum | POIScalarFieldEnum[]
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model POI
   */

  export type AggregatePOI = {
    _count: POICountAggregateOutputType | null
    _avg: POIAvgAggregateOutputType | null
    _sum: POISumAggregateOutputType | null
    _min: POIMinAggregateOutputType | null
    _max: POIMaxAggregateOutputType | null
  }

  export type POIAvgAggregateOutputType = {
    id: number | null
    zoneId: number | null
  }

  export type POISumAggregateOutputType = {
    id: number | null
    zoneId: number | null
  }

  export type POIMinAggregateOutputType = {
    id: number | null
    zoneId: number | null
    name: string | null
    category: $Enums.POICategory | null
    description: string | null
  }

  export type POIMaxAggregateOutputType = {
    id: number | null
    zoneId: number | null
    name: string | null
    category: $Enums.POICategory | null
    description: string | null
  }

  export type POICountAggregateOutputType = {
    id: number
    zoneId: number
    name: number
    category: number
    description: number
    location: number
    _all: number
  }


  export type POIAvgAggregateInputType = {
    id?: true
    zoneId?: true
  }

  export type POISumAggregateInputType = {
    id?: true
    zoneId?: true
  }

  export type POIMinAggregateInputType = {
    id?: true
    zoneId?: true
    name?: true
    category?: true
    description?: true
  }

  export type POIMaxAggregateInputType = {
    id?: true
    zoneId?: true
    name?: true
    category?: true
    description?: true
  }

  export type POICountAggregateInputType = {
    id?: true
    zoneId?: true
    name?: true
    category?: true
    description?: true
    location?: true
    _all?: true
  }

  export type POIAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POI to aggregate.
     */
    where?: POIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POIS to fetch.
     */
    orderBy?: POIOrderByWithRelationInput | POIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POIS
    **/
    _count?: true | POICountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POIAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POISumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POIMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POIMaxAggregateInputType
  }

  export type GetPOIAggregateType<T extends POIAggregateArgs> = {
        [P in keyof T & keyof AggregatePOI]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOI[P]>
      : GetScalarType<T[P], AggregatePOI[P]>
  }




  export type POIGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POIWhereInput
    orderBy?: POIOrderByWithAggregationInput | POIOrderByWithAggregationInput[]
    by: POIScalarFieldEnum[] | POIScalarFieldEnum
    having?: POIScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POICountAggregateInputType | true
    _avg?: POIAvgAggregateInputType
    _sum?: POISumAggregateInputType
    _min?: POIMinAggregateInputType
    _max?: POIMaxAggregateInputType
  }

  export type POIGroupByOutputType = {
    id: number
    zoneId: number
    name: string
    category: $Enums.POICategory
    description: string
    location: JsonValue
    _count: POICountAggregateOutputType | null
    _avg: POIAvgAggregateOutputType | null
    _sum: POISumAggregateOutputType | null
    _min: POIMinAggregateOutputType | null
    _max: POIMaxAggregateOutputType | null
  }

  type GetPOIGroupByPayload<T extends POIGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POIGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POIGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POIGroupByOutputType[P]>
            : GetScalarType<T[P], POIGroupByOutputType[P]>
        }
      >
    >


  export type POISelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    location?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOI"]>

  export type POISelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    location?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOI"]>

  export type POISelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    location?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOI"]>

  export type POISelectScalar = {
    id?: boolean
    zoneId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    location?: boolean
  }

  export type POIOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zoneId" | "name" | "category" | "description" | "location", ExtArgs["result"]["pOI"]>
  export type POIInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type POIIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type POIIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $POIPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POI"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      zoneId: number
      name: string
      category: $Enums.POICategory
      description: string
      location: Prisma.JsonValue
    }, ExtArgs["result"]["pOI"]>
    composites: {}
  }

  type POIGetPayload<S extends boolean | null | undefined | POIDefaultArgs> = $Result.GetResult<Prisma.$POIPayload, S>

  type POICountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POIFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POICountAggregateInputType | true
    }

  export interface POIDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POI'], meta: { name: 'POI' } }
    /**
     * Find zero or one POI that matches the filter.
     * @param {POIFindUniqueArgs} args - Arguments to find a POI
     * @example
     * // Get one POI
     * const pOI = await prisma.pOI.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POIFindUniqueArgs>(args: SelectSubset<T, POIFindUniqueArgs<ExtArgs>>): Prisma__POIClient<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one POI that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POIFindUniqueOrThrowArgs} args - Arguments to find a POI
     * @example
     * // Get one POI
     * const pOI = await prisma.pOI.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POIFindUniqueOrThrowArgs>(args: SelectSubset<T, POIFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POIClient<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first POI that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POIFindFirstArgs} args - Arguments to find a POI
     * @example
     * // Get one POI
     * const pOI = await prisma.pOI.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POIFindFirstArgs>(args?: SelectSubset<T, POIFindFirstArgs<ExtArgs>>): Prisma__POIClient<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first POI that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POIFindFirstOrThrowArgs} args - Arguments to find a POI
     * @example
     * // Get one POI
     * const pOI = await prisma.pOI.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POIFindFirstOrThrowArgs>(args?: SelectSubset<T, POIFindFirstOrThrowArgs<ExtArgs>>): Prisma__POIClient<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more POIS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POIFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POIS
     * const pOIS = await prisma.pOI.findMany()
     * 
     * // Get first 10 POIS
     * const pOIS = await prisma.pOI.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOIWithIdOnly = await prisma.pOI.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POIFindManyArgs>(args?: SelectSubset<T, POIFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a POI.
     * @param {POICreateArgs} args - Arguments to create a POI.
     * @example
     * // Create one POI
     * const POI = await prisma.pOI.create({
     *   data: {
     *     // ... data to create a POI
     *   }
     * })
     * 
     */
    create<T extends POICreateArgs>(args: SelectSubset<T, POICreateArgs<ExtArgs>>): Prisma__POIClient<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many POIS.
     * @param {POICreateManyArgs} args - Arguments to create many POIS.
     * @example
     * // Create many POIS
     * const pOI = await prisma.pOI.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POICreateManyArgs>(args?: SelectSubset<T, POICreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POIS and returns the data saved in the database.
     * @param {POICreateManyAndReturnArgs} args - Arguments to create many POIS.
     * @example
     * // Create many POIS
     * const pOI = await prisma.pOI.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POIS and only return the `id`
     * const pOIWithIdOnly = await prisma.pOI.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POICreateManyAndReturnArgs>(args?: SelectSubset<T, POICreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a POI.
     * @param {POIDeleteArgs} args - Arguments to delete one POI.
     * @example
     * // Delete one POI
     * const POI = await prisma.pOI.delete({
     *   where: {
     *     // ... filter to delete one POI
     *   }
     * })
     * 
     */
    delete<T extends POIDeleteArgs>(args: SelectSubset<T, POIDeleteArgs<ExtArgs>>): Prisma__POIClient<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one POI.
     * @param {POIUpdateArgs} args - Arguments to update one POI.
     * @example
     * // Update one POI
     * const pOI = await prisma.pOI.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POIUpdateArgs>(args: SelectSubset<T, POIUpdateArgs<ExtArgs>>): Prisma__POIClient<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more POIS.
     * @param {POIDeleteManyArgs} args - Arguments to filter POIS to delete.
     * @example
     * // Delete a few POIS
     * const { count } = await prisma.pOI.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POIDeleteManyArgs>(args?: SelectSubset<T, POIDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POIUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POIS
     * const pOI = await prisma.pOI.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POIUpdateManyArgs>(args: SelectSubset<T, POIUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POIS and returns the data updated in the database.
     * @param {POIUpdateManyAndReturnArgs} args - Arguments to update many POIS.
     * @example
     * // Update many POIS
     * const pOI = await prisma.pOI.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more POIS and only return the `id`
     * const pOIWithIdOnly = await prisma.pOI.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends POIUpdateManyAndReturnArgs>(args: SelectSubset<T, POIUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one POI.
     * @param {POIUpsertArgs} args - Arguments to update or create a POI.
     * @example
     * // Update or create a POI
     * const pOI = await prisma.pOI.upsert({
     *   create: {
     *     // ... data to create a POI
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POI we want to update
     *   }
     * })
     */
    upsert<T extends POIUpsertArgs>(args: SelectSubset<T, POIUpsertArgs<ExtArgs>>): Prisma__POIClient<$Result.GetResult<Prisma.$POIPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of POIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POICountArgs} args - Arguments to filter POIS to count.
     * @example
     * // Count the number of POIS
     * const count = await prisma.pOI.count({
     *   where: {
     *     // ... the filter for the POIS we want to count
     *   }
     * })
    **/
    count<T extends POICountArgs>(
      args?: Subset<T, POICountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POICountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POIAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POIAggregateArgs>(args: Subset<T, POIAggregateArgs>): Prisma.PrismaPromise<GetPOIAggregateType<T>>

    /**
     * Group by POI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POIGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POIGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POIGroupByArgs['orderBy'] }
        : { orderBy?: POIGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POIGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOIGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POI model
   */
  readonly fields: POIFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POI.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POIClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POI model
   */ 
  interface POIFieldRefs {
    readonly id: FieldRef<"POI", 'Int'>
    readonly zoneId: FieldRef<"POI", 'Int'>
    readonly name: FieldRef<"POI", 'String'>
    readonly category: FieldRef<"POI", 'POICategory'>
    readonly description: FieldRef<"POI", 'String'>
    readonly location: FieldRef<"POI", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * POI findUnique
   */
  export type POIFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    /**
     * Filter, which POI to fetch.
     */
    where: POIWhereUniqueInput
  }

  /**
   * POI findUniqueOrThrow
   */
  export type POIFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    /**
     * Filter, which POI to fetch.
     */
    where: POIWhereUniqueInput
  }

  /**
   * POI findFirst
   */
  export type POIFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    /**
     * Filter, which POI to fetch.
     */
    where?: POIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POIS to fetch.
     */
    orderBy?: POIOrderByWithRelationInput | POIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POIS.
     */
    cursor?: POIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POIS.
     */
    distinct?: POIScalarFieldEnum | POIScalarFieldEnum[]
  }

  /**
   * POI findFirstOrThrow
   */
  export type POIFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    /**
     * Filter, which POI to fetch.
     */
    where?: POIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POIS to fetch.
     */
    orderBy?: POIOrderByWithRelationInput | POIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POIS.
     */
    cursor?: POIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POIS.
     */
    distinct?: POIScalarFieldEnum | POIScalarFieldEnum[]
  }

  /**
   * POI findMany
   */
  export type POIFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    /**
     * Filter, which POIS to fetch.
     */
    where?: POIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POIS to fetch.
     */
    orderBy?: POIOrderByWithRelationInput | POIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POIS.
     */
    cursor?: POIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POIS.
     */
    skip?: number
    distinct?: POIScalarFieldEnum | POIScalarFieldEnum[]
  }

  /**
   * POI create
   */
  export type POICreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    /**
     * The data needed to create a POI.
     */
    data: XOR<POICreateInput, POIUncheckedCreateInput>
  }

  /**
   * POI createMany
   */
  export type POICreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POIS.
     */
    data: POICreateManyInput | POICreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POI createManyAndReturn
   */
  export type POICreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * The data used to create many POIS.
     */
    data: POICreateManyInput | POICreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POI update
   */
  export type POIUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    /**
     * The data needed to update a POI.
     */
    data: XOR<POIUpdateInput, POIUncheckedUpdateInput>
    /**
     * Choose, which POI to update.
     */
    where: POIWhereUniqueInput
  }

  /**
   * POI updateMany
   */
  export type POIUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POIS.
     */
    data: XOR<POIUpdateManyMutationInput, POIUncheckedUpdateManyInput>
    /**
     * Filter which POIS to update
     */
    where?: POIWhereInput
    /**
     * Limit how many POIS to update.
     */
    limit?: number
  }

  /**
   * POI updateManyAndReturn
   */
  export type POIUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * The data used to update POIS.
     */
    data: XOR<POIUpdateManyMutationInput, POIUncheckedUpdateManyInput>
    /**
     * Filter which POIS to update
     */
    where?: POIWhereInput
    /**
     * Limit how many POIS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * POI upsert
   */
  export type POIUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    /**
     * The filter to search for the POI to update in case it exists.
     */
    where: POIWhereUniqueInput
    /**
     * In case the POI found by the `where` argument doesn't exist, create a new POI with this data.
     */
    create: XOR<POICreateInput, POIUncheckedCreateInput>
    /**
     * In case the POI was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POIUpdateInput, POIUncheckedUpdateInput>
  }

  /**
   * POI delete
   */
  export type POIDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
    /**
     * Filter which POI to delete.
     */
    where: POIWhereUniqueInput
  }

  /**
   * POI deleteMany
   */
  export type POIDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POIS to delete
     */
    where?: POIWhereInput
    /**
     * Limit how many POIS to delete.
     */
    limit?: number
  }

  /**
   * POI without action
   */
  export type POIDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POI
     */
    select?: POISelect<ExtArgs> | null
    /**
     * Omit specific fields from the POI
     */
    omit?: POIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POIInclude<ExtArgs> | null
  }


  /**
   * Model Obstacle
   */

  export type AggregateObstacle = {
    _count: ObstacleCountAggregateOutputType | null
    _avg: ObstacleAvgAggregateOutputType | null
    _sum: ObstacleSumAggregateOutputType | null
    _min: ObstacleMinAggregateOutputType | null
    _max: ObstacleMaxAggregateOutputType | null
  }

  export type ObstacleAvgAggregateOutputType = {
    id: number | null
    envId: number | null
  }

  export type ObstacleSumAggregateOutputType = {
    id: number | null
    envId: number | null
  }

  export type ObstacleMinAggregateOutputType = {
    id: number | null
    envId: number | null
    name: string | null
    description: string | null
  }

  export type ObstacleMaxAggregateOutputType = {
    id: number | null
    envId: number | null
    name: string | null
    description: string | null
  }

  export type ObstacleCountAggregateOutputType = {
    id: number
    envId: number
    name: number
    description: number
    cords: number
    _all: number
  }


  export type ObstacleAvgAggregateInputType = {
    id?: true
    envId?: true
  }

  export type ObstacleSumAggregateInputType = {
    id?: true
    envId?: true
  }

  export type ObstacleMinAggregateInputType = {
    id?: true
    envId?: true
    name?: true
    description?: true
  }

  export type ObstacleMaxAggregateInputType = {
    id?: true
    envId?: true
    name?: true
    description?: true
  }

  export type ObstacleCountAggregateInputType = {
    id?: true
    envId?: true
    name?: true
    description?: true
    cords?: true
    _all?: true
  }

  export type ObstacleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obstacle to aggregate.
     */
    where?: ObstacleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obstacles to fetch.
     */
    orderBy?: ObstacleOrderByWithRelationInput | ObstacleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObstacleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obstacles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obstacles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Obstacles
    **/
    _count?: true | ObstacleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObstacleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObstacleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObstacleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObstacleMaxAggregateInputType
  }

  export type GetObstacleAggregateType<T extends ObstacleAggregateArgs> = {
        [P in keyof T & keyof AggregateObstacle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObstacle[P]>
      : GetScalarType<T[P], AggregateObstacle[P]>
  }




  export type ObstacleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObstacleWhereInput
    orderBy?: ObstacleOrderByWithAggregationInput | ObstacleOrderByWithAggregationInput[]
    by: ObstacleScalarFieldEnum[] | ObstacleScalarFieldEnum
    having?: ObstacleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObstacleCountAggregateInputType | true
    _avg?: ObstacleAvgAggregateInputType
    _sum?: ObstacleSumAggregateInputType
    _min?: ObstacleMinAggregateInputType
    _max?: ObstacleMaxAggregateInputType
  }

  export type ObstacleGroupByOutputType = {
    id: number
    envId: number
    name: string
    description: string
    cords: JsonValue
    _count: ObstacleCountAggregateOutputType | null
    _avg: ObstacleAvgAggregateOutputType | null
    _sum: ObstacleSumAggregateOutputType | null
    _min: ObstacleMinAggregateOutputType | null
    _max: ObstacleMaxAggregateOutputType | null
  }

  type GetObstacleGroupByPayload<T extends ObstacleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObstacleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObstacleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObstacleGroupByOutputType[P]>
            : GetScalarType<T[P], ObstacleGroupByOutputType[P]>
        }
      >
    >


  export type ObstacleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envId?: boolean
    name?: boolean
    description?: boolean
    cords?: boolean
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["obstacle"]>

  export type ObstacleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envId?: boolean
    name?: boolean
    description?: boolean
    cords?: boolean
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["obstacle"]>

  export type ObstacleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    envId?: boolean
    name?: boolean
    description?: boolean
    cords?: boolean
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["obstacle"]>

  export type ObstacleSelectScalar = {
    id?: boolean
    envId?: boolean
    name?: boolean
    description?: boolean
    cords?: boolean
  }

  export type ObstacleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "envId" | "name" | "description" | "cords", ExtArgs["result"]["obstacle"]>
  export type ObstacleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }
  export type ObstacleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }
  export type ObstacleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }

  export type $ObstaclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Obstacle"
    objects: {
      environment: Prisma.$EnvironmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      envId: number
      name: string
      description: string
      cords: Prisma.JsonValue
    }, ExtArgs["result"]["obstacle"]>
    composites: {}
  }

  type ObstacleGetPayload<S extends boolean | null | undefined | ObstacleDefaultArgs> = $Result.GetResult<Prisma.$ObstaclePayload, S>

  type ObstacleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ObstacleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObstacleCountAggregateInputType | true
    }

  export interface ObstacleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Obstacle'], meta: { name: 'Obstacle' } }
    /**
     * Find zero or one Obstacle that matches the filter.
     * @param {ObstacleFindUniqueArgs} args - Arguments to find a Obstacle
     * @example
     * // Get one Obstacle
     * const obstacle = await prisma.obstacle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObstacleFindUniqueArgs>(args: SelectSubset<T, ObstacleFindUniqueArgs<ExtArgs>>): Prisma__ObstacleClient<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Obstacle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ObstacleFindUniqueOrThrowArgs} args - Arguments to find a Obstacle
     * @example
     * // Get one Obstacle
     * const obstacle = await prisma.obstacle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObstacleFindUniqueOrThrowArgs>(args: SelectSubset<T, ObstacleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObstacleClient<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Obstacle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObstacleFindFirstArgs} args - Arguments to find a Obstacle
     * @example
     * // Get one Obstacle
     * const obstacle = await prisma.obstacle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObstacleFindFirstArgs>(args?: SelectSubset<T, ObstacleFindFirstArgs<ExtArgs>>): Prisma__ObstacleClient<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Obstacle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObstacleFindFirstOrThrowArgs} args - Arguments to find a Obstacle
     * @example
     * // Get one Obstacle
     * const obstacle = await prisma.obstacle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObstacleFindFirstOrThrowArgs>(args?: SelectSubset<T, ObstacleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObstacleClient<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Obstacles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObstacleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Obstacles
     * const obstacles = await prisma.obstacle.findMany()
     * 
     * // Get first 10 Obstacles
     * const obstacles = await prisma.obstacle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const obstacleWithIdOnly = await prisma.obstacle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObstacleFindManyArgs>(args?: SelectSubset<T, ObstacleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Obstacle.
     * @param {ObstacleCreateArgs} args - Arguments to create a Obstacle.
     * @example
     * // Create one Obstacle
     * const Obstacle = await prisma.obstacle.create({
     *   data: {
     *     // ... data to create a Obstacle
     *   }
     * })
     * 
     */
    create<T extends ObstacleCreateArgs>(args: SelectSubset<T, ObstacleCreateArgs<ExtArgs>>): Prisma__ObstacleClient<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Obstacles.
     * @param {ObstacleCreateManyArgs} args - Arguments to create many Obstacles.
     * @example
     * // Create many Obstacles
     * const obstacle = await prisma.obstacle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObstacleCreateManyArgs>(args?: SelectSubset<T, ObstacleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Obstacles and returns the data saved in the database.
     * @param {ObstacleCreateManyAndReturnArgs} args - Arguments to create many Obstacles.
     * @example
     * // Create many Obstacles
     * const obstacle = await prisma.obstacle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Obstacles and only return the `id`
     * const obstacleWithIdOnly = await prisma.obstacle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObstacleCreateManyAndReturnArgs>(args?: SelectSubset<T, ObstacleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Obstacle.
     * @param {ObstacleDeleteArgs} args - Arguments to delete one Obstacle.
     * @example
     * // Delete one Obstacle
     * const Obstacle = await prisma.obstacle.delete({
     *   where: {
     *     // ... filter to delete one Obstacle
     *   }
     * })
     * 
     */
    delete<T extends ObstacleDeleteArgs>(args: SelectSubset<T, ObstacleDeleteArgs<ExtArgs>>): Prisma__ObstacleClient<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Obstacle.
     * @param {ObstacleUpdateArgs} args - Arguments to update one Obstacle.
     * @example
     * // Update one Obstacle
     * const obstacle = await prisma.obstacle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObstacleUpdateArgs>(args: SelectSubset<T, ObstacleUpdateArgs<ExtArgs>>): Prisma__ObstacleClient<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Obstacles.
     * @param {ObstacleDeleteManyArgs} args - Arguments to filter Obstacles to delete.
     * @example
     * // Delete a few Obstacles
     * const { count } = await prisma.obstacle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObstacleDeleteManyArgs>(args?: SelectSubset<T, ObstacleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Obstacles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObstacleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Obstacles
     * const obstacle = await prisma.obstacle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObstacleUpdateManyArgs>(args: SelectSubset<T, ObstacleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Obstacles and returns the data updated in the database.
     * @param {ObstacleUpdateManyAndReturnArgs} args - Arguments to update many Obstacles.
     * @example
     * // Update many Obstacles
     * const obstacle = await prisma.obstacle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Obstacles and only return the `id`
     * const obstacleWithIdOnly = await prisma.obstacle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ObstacleUpdateManyAndReturnArgs>(args: SelectSubset<T, ObstacleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Obstacle.
     * @param {ObstacleUpsertArgs} args - Arguments to update or create a Obstacle.
     * @example
     * // Update or create a Obstacle
     * const obstacle = await prisma.obstacle.upsert({
     *   create: {
     *     // ... data to create a Obstacle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Obstacle we want to update
     *   }
     * })
     */
    upsert<T extends ObstacleUpsertArgs>(args: SelectSubset<T, ObstacleUpsertArgs<ExtArgs>>): Prisma__ObstacleClient<$Result.GetResult<Prisma.$ObstaclePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Obstacles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObstacleCountArgs} args - Arguments to filter Obstacles to count.
     * @example
     * // Count the number of Obstacles
     * const count = await prisma.obstacle.count({
     *   where: {
     *     // ... the filter for the Obstacles we want to count
     *   }
     * })
    **/
    count<T extends ObstacleCountArgs>(
      args?: Subset<T, ObstacleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObstacleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Obstacle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObstacleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObstacleAggregateArgs>(args: Subset<T, ObstacleAggregateArgs>): Prisma.PrismaPromise<GetObstacleAggregateType<T>>

    /**
     * Group by Obstacle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObstacleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObstacleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObstacleGroupByArgs['orderBy'] }
        : { orderBy?: ObstacleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObstacleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObstacleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Obstacle model
   */
  readonly fields: ObstacleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Obstacle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObstacleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    environment<T extends EnvironmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvironmentDefaultArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Obstacle model
   */ 
  interface ObstacleFieldRefs {
    readonly id: FieldRef<"Obstacle", 'Int'>
    readonly envId: FieldRef<"Obstacle", 'Int'>
    readonly name: FieldRef<"Obstacle", 'String'>
    readonly description: FieldRef<"Obstacle", 'String'>
    readonly cords: FieldRef<"Obstacle", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Obstacle findUnique
   */
  export type ObstacleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    /**
     * Filter, which Obstacle to fetch.
     */
    where: ObstacleWhereUniqueInput
  }

  /**
   * Obstacle findUniqueOrThrow
   */
  export type ObstacleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    /**
     * Filter, which Obstacle to fetch.
     */
    where: ObstacleWhereUniqueInput
  }

  /**
   * Obstacle findFirst
   */
  export type ObstacleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    /**
     * Filter, which Obstacle to fetch.
     */
    where?: ObstacleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obstacles to fetch.
     */
    orderBy?: ObstacleOrderByWithRelationInput | ObstacleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obstacles.
     */
    cursor?: ObstacleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obstacles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obstacles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obstacles.
     */
    distinct?: ObstacleScalarFieldEnum | ObstacleScalarFieldEnum[]
  }

  /**
   * Obstacle findFirstOrThrow
   */
  export type ObstacleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    /**
     * Filter, which Obstacle to fetch.
     */
    where?: ObstacleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obstacles to fetch.
     */
    orderBy?: ObstacleOrderByWithRelationInput | ObstacleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obstacles.
     */
    cursor?: ObstacleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obstacles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obstacles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obstacles.
     */
    distinct?: ObstacleScalarFieldEnum | ObstacleScalarFieldEnum[]
  }

  /**
   * Obstacle findMany
   */
  export type ObstacleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    /**
     * Filter, which Obstacles to fetch.
     */
    where?: ObstacleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obstacles to fetch.
     */
    orderBy?: ObstacleOrderByWithRelationInput | ObstacleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Obstacles.
     */
    cursor?: ObstacleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obstacles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obstacles.
     */
    skip?: number
    distinct?: ObstacleScalarFieldEnum | ObstacleScalarFieldEnum[]
  }

  /**
   * Obstacle create
   */
  export type ObstacleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    /**
     * The data needed to create a Obstacle.
     */
    data: XOR<ObstacleCreateInput, ObstacleUncheckedCreateInput>
  }

  /**
   * Obstacle createMany
   */
  export type ObstacleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Obstacles.
     */
    data: ObstacleCreateManyInput | ObstacleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Obstacle createManyAndReturn
   */
  export type ObstacleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * The data used to create many Obstacles.
     */
    data: ObstacleCreateManyInput | ObstacleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Obstacle update
   */
  export type ObstacleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    /**
     * The data needed to update a Obstacle.
     */
    data: XOR<ObstacleUpdateInput, ObstacleUncheckedUpdateInput>
    /**
     * Choose, which Obstacle to update.
     */
    where: ObstacleWhereUniqueInput
  }

  /**
   * Obstacle updateMany
   */
  export type ObstacleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Obstacles.
     */
    data: XOR<ObstacleUpdateManyMutationInput, ObstacleUncheckedUpdateManyInput>
    /**
     * Filter which Obstacles to update
     */
    where?: ObstacleWhereInput
    /**
     * Limit how many Obstacles to update.
     */
    limit?: number
  }

  /**
   * Obstacle updateManyAndReturn
   */
  export type ObstacleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * The data used to update Obstacles.
     */
    data: XOR<ObstacleUpdateManyMutationInput, ObstacleUncheckedUpdateManyInput>
    /**
     * Filter which Obstacles to update
     */
    where?: ObstacleWhereInput
    /**
     * Limit how many Obstacles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Obstacle upsert
   */
  export type ObstacleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    /**
     * The filter to search for the Obstacle to update in case it exists.
     */
    where: ObstacleWhereUniqueInput
    /**
     * In case the Obstacle found by the `where` argument doesn't exist, create a new Obstacle with this data.
     */
    create: XOR<ObstacleCreateInput, ObstacleUncheckedCreateInput>
    /**
     * In case the Obstacle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObstacleUpdateInput, ObstacleUncheckedUpdateInput>
  }

  /**
   * Obstacle delete
   */
  export type ObstacleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
    /**
     * Filter which Obstacle to delete.
     */
    where: ObstacleWhereUniqueInput
  }

  /**
   * Obstacle deleteMany
   */
  export type ObstacleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obstacles to delete
     */
    where?: ObstacleWhereInput
    /**
     * Limit how many Obstacles to delete.
     */
    limit?: number
  }

  /**
   * Obstacle without action
   */
  export type ObstacleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obstacle
     */
    select?: ObstacleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obstacle
     */
    omit?: ObstacleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObstacleInclude<ExtArgs> | null
  }


  /**
   * Model Itinerary
   */

  export type AggregateItinerary = {
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  export type ItineraryAvgAggregateOutputType = {
    id: number | null
    envId: number | null
  }

  export type ItinerarySumAggregateOutputType = {
    id: number | null
    envId: number | null
  }

  export type ItineraryMinAggregateOutputType = {
    id: number | null
    envId: number | null
  }

  export type ItineraryMaxAggregateOutputType = {
    id: number | null
    envId: number | null
  }

  export type ItineraryCountAggregateOutputType = {
    id: number
    startPoint: number
    endPoint: number
    envId: number
    _all: number
  }


  export type ItineraryAvgAggregateInputType = {
    id?: true
    envId?: true
  }

  export type ItinerarySumAggregateInputType = {
    id?: true
    envId?: true
  }

  export type ItineraryMinAggregateInputType = {
    id?: true
    envId?: true
  }

  export type ItineraryMaxAggregateInputType = {
    id?: true
    envId?: true
  }

  export type ItineraryCountAggregateInputType = {
    id?: true
    startPoint?: true
    endPoint?: true
    envId?: true
    _all?: true
  }

  export type ItineraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itinerary to aggregate.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Itineraries
    **/
    _count?: true | ItineraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItineraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItinerarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItineraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItineraryMaxAggregateInputType
  }

  export type GetItineraryAggregateType<T extends ItineraryAggregateArgs> = {
        [P in keyof T & keyof AggregateItinerary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItinerary[P]>
      : GetScalarType<T[P], AggregateItinerary[P]>
  }




  export type ItineraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithAggregationInput | ItineraryOrderByWithAggregationInput[]
    by: ItineraryScalarFieldEnum[] | ItineraryScalarFieldEnum
    having?: ItineraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItineraryCountAggregateInputType | true
    _avg?: ItineraryAvgAggregateInputType
    _sum?: ItinerarySumAggregateInputType
    _min?: ItineraryMinAggregateInputType
    _max?: ItineraryMaxAggregateInputType
  }

  export type ItineraryGroupByOutputType = {
    id: number
    startPoint: JsonValue
    endPoint: JsonValue
    envId: number
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  type GetItineraryGroupByPayload<T extends ItineraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItineraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItineraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
            : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
        }
      >
    >


  export type ItinerarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startPoint?: boolean
    endPoint?: boolean
    envId?: boolean
    environement?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startPoint?: boolean
    endPoint?: boolean
    envId?: boolean
    environement?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startPoint?: boolean
    endPoint?: boolean
    envId?: boolean
    environement?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectScalar = {
    id?: boolean
    startPoint?: boolean
    endPoint?: boolean
    envId?: boolean
  }

  export type ItineraryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startPoint" | "endPoint" | "envId", ExtArgs["result"]["itinerary"]>
  export type ItineraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environement?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }
  export type ItineraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environement?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }
  export type ItineraryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environement?: boolean | EnvironmentDefaultArgs<ExtArgs>
  }

  export type $ItineraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Itinerary"
    objects: {
      environement: Prisma.$EnvironmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      startPoint: Prisma.JsonValue
      endPoint: Prisma.JsonValue
      envId: number
    }, ExtArgs["result"]["itinerary"]>
    composites: {}
  }

  type ItineraryGetPayload<S extends boolean | null | undefined | ItineraryDefaultArgs> = $Result.GetResult<Prisma.$ItineraryPayload, S>

  type ItineraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItineraryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItineraryCountAggregateInputType | true
    }

  export interface ItineraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Itinerary'], meta: { name: 'Itinerary' } }
    /**
     * Find zero or one Itinerary that matches the filter.
     * @param {ItineraryFindUniqueArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItineraryFindUniqueArgs>(args: SelectSubset<T, ItineraryFindUniqueArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Itinerary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItineraryFindUniqueOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItineraryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItineraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Itinerary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItineraryFindFirstArgs>(args?: SelectSubset<T, ItineraryFindFirstArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Itinerary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItineraryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItineraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Itineraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itineraries
     * const itineraries = await prisma.itinerary.findMany()
     * 
     * // Get first 10 Itineraries
     * const itineraries = await prisma.itinerary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItineraryFindManyArgs>(args?: SelectSubset<T, ItineraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Itinerary.
     * @param {ItineraryCreateArgs} args - Arguments to create a Itinerary.
     * @example
     * // Create one Itinerary
     * const Itinerary = await prisma.itinerary.create({
     *   data: {
     *     // ... data to create a Itinerary
     *   }
     * })
     * 
     */
    create<T extends ItineraryCreateArgs>(args: SelectSubset<T, ItineraryCreateArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Itineraries.
     * @param {ItineraryCreateManyArgs} args - Arguments to create many Itineraries.
     * @example
     * // Create many Itineraries
     * const itinerary = await prisma.itinerary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItineraryCreateManyArgs>(args?: SelectSubset<T, ItineraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Itineraries and returns the data saved in the database.
     * @param {ItineraryCreateManyAndReturnArgs} args - Arguments to create many Itineraries.
     * @example
     * // Create many Itineraries
     * const itinerary = await prisma.itinerary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Itineraries and only return the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItineraryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItineraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Itinerary.
     * @param {ItineraryDeleteArgs} args - Arguments to delete one Itinerary.
     * @example
     * // Delete one Itinerary
     * const Itinerary = await prisma.itinerary.delete({
     *   where: {
     *     // ... filter to delete one Itinerary
     *   }
     * })
     * 
     */
    delete<T extends ItineraryDeleteArgs>(args: SelectSubset<T, ItineraryDeleteArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Itinerary.
     * @param {ItineraryUpdateArgs} args - Arguments to update one Itinerary.
     * @example
     * // Update one Itinerary
     * const itinerary = await prisma.itinerary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItineraryUpdateArgs>(args: SelectSubset<T, ItineraryUpdateArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Itineraries.
     * @param {ItineraryDeleteManyArgs} args - Arguments to filter Itineraries to delete.
     * @example
     * // Delete a few Itineraries
     * const { count } = await prisma.itinerary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItineraryDeleteManyArgs>(args?: SelectSubset<T, ItineraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itineraries
     * const itinerary = await prisma.itinerary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItineraryUpdateManyArgs>(args: SelectSubset<T, ItineraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itineraries and returns the data updated in the database.
     * @param {ItineraryUpdateManyAndReturnArgs} args - Arguments to update many Itineraries.
     * @example
     * // Update many Itineraries
     * const itinerary = await prisma.itinerary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Itineraries and only return the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItineraryUpdateManyAndReturnArgs>(args: SelectSubset<T, ItineraryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Itinerary.
     * @param {ItineraryUpsertArgs} args - Arguments to update or create a Itinerary.
     * @example
     * // Update or create a Itinerary
     * const itinerary = await prisma.itinerary.upsert({
     *   create: {
     *     // ... data to create a Itinerary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itinerary we want to update
     *   }
     * })
     */
    upsert<T extends ItineraryUpsertArgs>(args: SelectSubset<T, ItineraryUpsertArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryCountArgs} args - Arguments to filter Itineraries to count.
     * @example
     * // Count the number of Itineraries
     * const count = await prisma.itinerary.count({
     *   where: {
     *     // ... the filter for the Itineraries we want to count
     *   }
     * })
    **/
    count<T extends ItineraryCountArgs>(
      args?: Subset<T, ItineraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItineraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItineraryAggregateArgs>(args: Subset<T, ItineraryAggregateArgs>): Prisma.PrismaPromise<GetItineraryAggregateType<T>>

    /**
     * Group by Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItineraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItineraryGroupByArgs['orderBy'] }
        : { orderBy?: ItineraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItineraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItineraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Itinerary model
   */
  readonly fields: ItineraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Itinerary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItineraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    environement<T extends EnvironmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvironmentDefaultArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Itinerary model
   */ 
  interface ItineraryFieldRefs {
    readonly id: FieldRef<"Itinerary", 'Int'>
    readonly startPoint: FieldRef<"Itinerary", 'Json'>
    readonly endPoint: FieldRef<"Itinerary", 'Json'>
    readonly envId: FieldRef<"Itinerary", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Itinerary findUnique
   */
  export type ItineraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary findUniqueOrThrow
   */
  export type ItineraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary findFirst
   */
  export type ItineraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary findFirstOrThrow
   */
  export type ItineraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary findMany
   */
  export type ItineraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itineraries to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary create
   */
  export type ItineraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to create a Itinerary.
     */
    data: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
  }

  /**
   * Itinerary createMany
   */
  export type ItineraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Itineraries.
     */
    data: ItineraryCreateManyInput | ItineraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Itinerary createManyAndReturn
   */
  export type ItineraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * The data used to create many Itineraries.
     */
    data: ItineraryCreateManyInput | ItineraryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Itinerary update
   */
  export type ItineraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to update a Itinerary.
     */
    data: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
    /**
     * Choose, which Itinerary to update.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary updateMany
   */
  export type ItineraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Itineraries.
     */
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyInput>
    /**
     * Filter which Itineraries to update
     */
    where?: ItineraryWhereInput
    /**
     * Limit how many Itineraries to update.
     */
    limit?: number
  }

  /**
   * Itinerary updateManyAndReturn
   */
  export type ItineraryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * The data used to update Itineraries.
     */
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyInput>
    /**
     * Filter which Itineraries to update
     */
    where?: ItineraryWhereInput
    /**
     * Limit how many Itineraries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Itinerary upsert
   */
  export type ItineraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The filter to search for the Itinerary to update in case it exists.
     */
    where: ItineraryWhereUniqueInput
    /**
     * In case the Itinerary found by the `where` argument doesn't exist, create a new Itinerary with this data.
     */
    create: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
    /**
     * In case the Itinerary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
  }

  /**
   * Itinerary delete
   */
  export type ItineraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter which Itinerary to delete.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary deleteMany
   */
  export type ItineraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itineraries to delete
     */
    where?: ItineraryWhereInput
    /**
     * Limit how many Itineraries to delete.
     */
    limit?: number
  }

  /**
   * Itinerary without action
   */
  export type ItineraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Itinerary
     */
    omit?: ItineraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
  }


  /**
   * Model HelpRequest
   */

  export type AggregateHelpRequest = {
    _count: HelpRequestCountAggregateOutputType | null
    _avg: HelpRequestAvgAggregateOutputType | null
    _sum: HelpRequestSumAggregateOutputType | null
    _min: HelpRequestMinAggregateOutputType | null
    _max: HelpRequestMaxAggregateOutputType | null
  }

  export type HelpRequestAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    helperId: number | null
  }

  export type HelpRequestSumAggregateOutputType = {
    id: number | null
    userId: number | null
    helperId: number | null
  }

  export type HelpRequestMinAggregateOutputType = {
    id: number | null
    userId: number | null
    helperId: number | null
  }

  export type HelpRequestMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    helperId: number | null
  }

  export type HelpRequestCountAggregateOutputType = {
    id: number
    userId: number
    helperId: number
    _all: number
  }


  export type HelpRequestAvgAggregateInputType = {
    id?: true
    userId?: true
    helperId?: true
  }

  export type HelpRequestSumAggregateInputType = {
    id?: true
    userId?: true
    helperId?: true
  }

  export type HelpRequestMinAggregateInputType = {
    id?: true
    userId?: true
    helperId?: true
  }

  export type HelpRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    helperId?: true
  }

  export type HelpRequestCountAggregateInputType = {
    id?: true
    userId?: true
    helperId?: true
    _all?: true
  }

  export type HelpRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpRequest to aggregate.
     */
    where?: HelpRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpRequests to fetch.
     */
    orderBy?: HelpRequestOrderByWithRelationInput | HelpRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpRequests
    **/
    _count?: true | HelpRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpRequestMaxAggregateInputType
  }

  export type GetHelpRequestAggregateType<T extends HelpRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpRequest[P]>
      : GetScalarType<T[P], AggregateHelpRequest[P]>
  }




  export type HelpRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpRequestWhereInput
    orderBy?: HelpRequestOrderByWithAggregationInput | HelpRequestOrderByWithAggregationInput[]
    by: HelpRequestScalarFieldEnum[] | HelpRequestScalarFieldEnum
    having?: HelpRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpRequestCountAggregateInputType | true
    _avg?: HelpRequestAvgAggregateInputType
    _sum?: HelpRequestSumAggregateInputType
    _min?: HelpRequestMinAggregateInputType
    _max?: HelpRequestMaxAggregateInputType
  }

  export type HelpRequestGroupByOutputType = {
    id: number
    userId: number
    helperId: number
    _count: HelpRequestCountAggregateOutputType | null
    _avg: HelpRequestAvgAggregateOutputType | null
    _sum: HelpRequestSumAggregateOutputType | null
    _min: HelpRequestMinAggregateOutputType | null
    _max: HelpRequestMaxAggregateOutputType | null
  }

  type GetHelpRequestGroupByPayload<T extends HelpRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpRequestGroupByOutputType[P]>
            : GetScalarType<T[P], HelpRequestGroupByOutputType[P]>
        }
      >
    >


  export type HelpRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    helperId?: boolean
    user?: boolean | EndUserDefaultArgs<ExtArgs>
    helper?: boolean | HelperDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpRequest"]>

  export type HelpRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    helperId?: boolean
    user?: boolean | EndUserDefaultArgs<ExtArgs>
    helper?: boolean | HelperDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpRequest"]>

  export type HelpRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    helperId?: boolean
    user?: boolean | EndUserDefaultArgs<ExtArgs>
    helper?: boolean | HelperDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpRequest"]>

  export type HelpRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    helperId?: boolean
  }

  export type HelpRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "helperId", ExtArgs["result"]["helpRequest"]>
  export type HelpRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EndUserDefaultArgs<ExtArgs>
    helper?: boolean | HelperDefaultArgs<ExtArgs>
  }
  export type HelpRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EndUserDefaultArgs<ExtArgs>
    helper?: boolean | HelperDefaultArgs<ExtArgs>
  }
  export type HelpRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | EndUserDefaultArgs<ExtArgs>
    helper?: boolean | HelperDefaultArgs<ExtArgs>
  }

  export type $HelpRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpRequest"
    objects: {
      user: Prisma.$EndUserPayload<ExtArgs>
      helper: Prisma.$HelperPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      helperId: number
    }, ExtArgs["result"]["helpRequest"]>
    composites: {}
  }

  type HelpRequestGetPayload<S extends boolean | null | undefined | HelpRequestDefaultArgs> = $Result.GetResult<Prisma.$HelpRequestPayload, S>

  type HelpRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HelpRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HelpRequestCountAggregateInputType | true
    }

  export interface HelpRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpRequest'], meta: { name: 'HelpRequest' } }
    /**
     * Find zero or one HelpRequest that matches the filter.
     * @param {HelpRequestFindUniqueArgs} args - Arguments to find a HelpRequest
     * @example
     * // Get one HelpRequest
     * const helpRequest = await prisma.helpRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpRequestFindUniqueArgs>(args: SelectSubset<T, HelpRequestFindUniqueArgs<ExtArgs>>): Prisma__HelpRequestClient<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one HelpRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HelpRequestFindUniqueOrThrowArgs} args - Arguments to find a HelpRequest
     * @example
     * // Get one HelpRequest
     * const helpRequest = await prisma.helpRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpRequestClient<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first HelpRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpRequestFindFirstArgs} args - Arguments to find a HelpRequest
     * @example
     * // Get one HelpRequest
     * const helpRequest = await prisma.helpRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpRequestFindFirstArgs>(args?: SelectSubset<T, HelpRequestFindFirstArgs<ExtArgs>>): Prisma__HelpRequestClient<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first HelpRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpRequestFindFirstOrThrowArgs} args - Arguments to find a HelpRequest
     * @example
     * // Get one HelpRequest
     * const helpRequest = await prisma.helpRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpRequestClient<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more HelpRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpRequests
     * const helpRequests = await prisma.helpRequest.findMany()
     * 
     * // Get first 10 HelpRequests
     * const helpRequests = await prisma.helpRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpRequestWithIdOnly = await prisma.helpRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpRequestFindManyArgs>(args?: SelectSubset<T, HelpRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a HelpRequest.
     * @param {HelpRequestCreateArgs} args - Arguments to create a HelpRequest.
     * @example
     * // Create one HelpRequest
     * const HelpRequest = await prisma.helpRequest.create({
     *   data: {
     *     // ... data to create a HelpRequest
     *   }
     * })
     * 
     */
    create<T extends HelpRequestCreateArgs>(args: SelectSubset<T, HelpRequestCreateArgs<ExtArgs>>): Prisma__HelpRequestClient<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many HelpRequests.
     * @param {HelpRequestCreateManyArgs} args - Arguments to create many HelpRequests.
     * @example
     * // Create many HelpRequests
     * const helpRequest = await prisma.helpRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpRequestCreateManyArgs>(args?: SelectSubset<T, HelpRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpRequests and returns the data saved in the database.
     * @param {HelpRequestCreateManyAndReturnArgs} args - Arguments to create many HelpRequests.
     * @example
     * // Create many HelpRequests
     * const helpRequest = await prisma.helpRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpRequests and only return the `id`
     * const helpRequestWithIdOnly = await prisma.helpRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a HelpRequest.
     * @param {HelpRequestDeleteArgs} args - Arguments to delete one HelpRequest.
     * @example
     * // Delete one HelpRequest
     * const HelpRequest = await prisma.helpRequest.delete({
     *   where: {
     *     // ... filter to delete one HelpRequest
     *   }
     * })
     * 
     */
    delete<T extends HelpRequestDeleteArgs>(args: SelectSubset<T, HelpRequestDeleteArgs<ExtArgs>>): Prisma__HelpRequestClient<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one HelpRequest.
     * @param {HelpRequestUpdateArgs} args - Arguments to update one HelpRequest.
     * @example
     * // Update one HelpRequest
     * const helpRequest = await prisma.helpRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpRequestUpdateArgs>(args: SelectSubset<T, HelpRequestUpdateArgs<ExtArgs>>): Prisma__HelpRequestClient<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more HelpRequests.
     * @param {HelpRequestDeleteManyArgs} args - Arguments to filter HelpRequests to delete.
     * @example
     * // Delete a few HelpRequests
     * const { count } = await prisma.helpRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpRequestDeleteManyArgs>(args?: SelectSubset<T, HelpRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpRequests
     * const helpRequest = await prisma.helpRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpRequestUpdateManyArgs>(args: SelectSubset<T, HelpRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpRequests and returns the data updated in the database.
     * @param {HelpRequestUpdateManyAndReturnArgs} args - Arguments to update many HelpRequests.
     * @example
     * // Update many HelpRequests
     * const helpRequest = await prisma.helpRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HelpRequests and only return the `id`
     * const helpRequestWithIdOnly = await prisma.helpRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HelpRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, HelpRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one HelpRequest.
     * @param {HelpRequestUpsertArgs} args - Arguments to update or create a HelpRequest.
     * @example
     * // Update or create a HelpRequest
     * const helpRequest = await prisma.helpRequest.upsert({
     *   create: {
     *     // ... data to create a HelpRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpRequest we want to update
     *   }
     * })
     */
    upsert<T extends HelpRequestUpsertArgs>(args: SelectSubset<T, HelpRequestUpsertArgs<ExtArgs>>): Prisma__HelpRequestClient<$Result.GetResult<Prisma.$HelpRequestPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of HelpRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpRequestCountArgs} args - Arguments to filter HelpRequests to count.
     * @example
     * // Count the number of HelpRequests
     * const count = await prisma.helpRequest.count({
     *   where: {
     *     // ... the filter for the HelpRequests we want to count
     *   }
     * })
    **/
    count<T extends HelpRequestCountArgs>(
      args?: Subset<T, HelpRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpRequestAggregateArgs>(args: Subset<T, HelpRequestAggregateArgs>): Prisma.PrismaPromise<GetHelpRequestAggregateType<T>>

    /**
     * Group by HelpRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpRequestGroupByArgs['orderBy'] }
        : { orderBy?: HelpRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpRequest model
   */
  readonly fields: HelpRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends EndUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EndUserDefaultArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    helper<T extends HelperDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HelperDefaultArgs<ExtArgs>>): Prisma__HelperClient<$Result.GetResult<Prisma.$HelperPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpRequest model
   */ 
  interface HelpRequestFieldRefs {
    readonly id: FieldRef<"HelpRequest", 'Int'>
    readonly userId: FieldRef<"HelpRequest", 'Int'>
    readonly helperId: FieldRef<"HelpRequest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * HelpRequest findUnique
   */
  export type HelpRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    /**
     * Filter, which HelpRequest to fetch.
     */
    where: HelpRequestWhereUniqueInput
  }

  /**
   * HelpRequest findUniqueOrThrow
   */
  export type HelpRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    /**
     * Filter, which HelpRequest to fetch.
     */
    where: HelpRequestWhereUniqueInput
  }

  /**
   * HelpRequest findFirst
   */
  export type HelpRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    /**
     * Filter, which HelpRequest to fetch.
     */
    where?: HelpRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpRequests to fetch.
     */
    orderBy?: HelpRequestOrderByWithRelationInput | HelpRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpRequests.
     */
    cursor?: HelpRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpRequests.
     */
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * HelpRequest findFirstOrThrow
   */
  export type HelpRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    /**
     * Filter, which HelpRequest to fetch.
     */
    where?: HelpRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpRequests to fetch.
     */
    orderBy?: HelpRequestOrderByWithRelationInput | HelpRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpRequests.
     */
    cursor?: HelpRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpRequests.
     */
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * HelpRequest findMany
   */
  export type HelpRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    /**
     * Filter, which HelpRequests to fetch.
     */
    where?: HelpRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpRequests to fetch.
     */
    orderBy?: HelpRequestOrderByWithRelationInput | HelpRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpRequests.
     */
    cursor?: HelpRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpRequests.
     */
    skip?: number
    distinct?: HelpRequestScalarFieldEnum | HelpRequestScalarFieldEnum[]
  }

  /**
   * HelpRequest create
   */
  export type HelpRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpRequest.
     */
    data: XOR<HelpRequestCreateInput, HelpRequestUncheckedCreateInput>
  }

  /**
   * HelpRequest createMany
   */
  export type HelpRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpRequests.
     */
    data: HelpRequestCreateManyInput | HelpRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HelpRequest createManyAndReturn
   */
  export type HelpRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * The data used to create many HelpRequests.
     */
    data: HelpRequestCreateManyInput | HelpRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpRequest update
   */
  export type HelpRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpRequest.
     */
    data: XOR<HelpRequestUpdateInput, HelpRequestUncheckedUpdateInput>
    /**
     * Choose, which HelpRequest to update.
     */
    where: HelpRequestWhereUniqueInput
  }

  /**
   * HelpRequest updateMany
   */
  export type HelpRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpRequests.
     */
    data: XOR<HelpRequestUpdateManyMutationInput, HelpRequestUncheckedUpdateManyInput>
    /**
     * Filter which HelpRequests to update
     */
    where?: HelpRequestWhereInput
    /**
     * Limit how many HelpRequests to update.
     */
    limit?: number
  }

  /**
   * HelpRequest updateManyAndReturn
   */
  export type HelpRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * The data used to update HelpRequests.
     */
    data: XOR<HelpRequestUpdateManyMutationInput, HelpRequestUncheckedUpdateManyInput>
    /**
     * Filter which HelpRequests to update
     */
    where?: HelpRequestWhereInput
    /**
     * Limit how many HelpRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpRequest upsert
   */
  export type HelpRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpRequest to update in case it exists.
     */
    where: HelpRequestWhereUniqueInput
    /**
     * In case the HelpRequest found by the `where` argument doesn't exist, create a new HelpRequest with this data.
     */
    create: XOR<HelpRequestCreateInput, HelpRequestUncheckedCreateInput>
    /**
     * In case the HelpRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpRequestUpdateInput, HelpRequestUncheckedUpdateInput>
  }

  /**
   * HelpRequest delete
   */
  export type HelpRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
    /**
     * Filter which HelpRequest to delete.
     */
    where: HelpRequestWhereUniqueInput
  }

  /**
   * HelpRequest deleteMany
   */
  export type HelpRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpRequests to delete
     */
    where?: HelpRequestWhereInput
    /**
     * Limit how many HelpRequests to delete.
     */
    limit?: number
  }

  /**
   * HelpRequest without action
   */
  export type HelpRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpRequest
     */
    select?: HelpRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HelpRequest
     */
    omit?: HelpRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpRequestInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    id: number | null
    deviceId: number | null
    buyerId: number | null
  }

  export type SaleSumAggregateOutputType = {
    id: number | null
    deviceId: number | null
    buyerId: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: number | null
    deviceId: number | null
    buyerId: number | null
    createdAt: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: number | null
    deviceId: number | null
    buyerId: number | null
    createdAt: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    deviceId: number
    buyerId: number
    createdAt: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    id?: true
    deviceId?: true
    buyerId?: true
  }

  export type SaleSumAggregateInputType = {
    id?: true
    deviceId?: true
    buyerId?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    deviceId?: true
    buyerId?: true
    createdAt?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    deviceId?: true
    buyerId?: true
    createdAt?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    deviceId?: true
    buyerId?: true
    createdAt?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: number
    deviceId: number
    buyerId: number
    createdAt: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    buyerId?: boolean
    createdAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    buyer?: boolean | EndUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    buyerId?: boolean
    createdAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    buyer?: boolean | EndUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    buyerId?: boolean
    createdAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    buyer?: boolean | EndUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    deviceId?: boolean
    buyerId?: boolean
    createdAt?: boolean
  }

  export type SaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deviceId" | "buyerId" | "createdAt", ExtArgs["result"]["sale"]>
  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    buyer?: boolean | EndUserDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    buyer?: boolean | EndUserDefaultArgs<ExtArgs>
  }
  export type SaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    buyer?: boolean | EndUserDefaultArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      buyer: Prisma.$EndUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deviceId: number
      buyerId: number
      createdAt: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {SaleUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    buyer<T extends EndUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EndUserDefaultArgs<ExtArgs>>): Prisma__EndUserClient<$Result.GetResult<Prisma.$EndUserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */ 
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'Int'>
    readonly deviceId: FieldRef<"Sale", 'Int'>
    readonly buyerId: FieldRef<"Sale", 'Int'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
  }

  /**
   * Sale updateManyAndReturn
   */
  export type SaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to delete.
     */
    limit?: number
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model Intervention
   */

  export type AggregateIntervention = {
    _count: InterventionCountAggregateOutputType | null
    _avg: InterventionAvgAggregateOutputType | null
    _sum: InterventionSumAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  export type InterventionAvgAggregateOutputType = {
    id: number | null
    deviceId: number | null
    maintainerId: number | null
  }

  export type InterventionSumAggregateOutputType = {
    id: number | null
    deviceId: number | null
    maintainerId: number | null
  }

  export type InterventionMinAggregateOutputType = {
    id: number | null
    type: $Enums.InterventionType | null
    deviceId: number | null
    maintainerId: number | null
    isRemote: boolean | null
    planDate: Date | null
  }

  export type InterventionMaxAggregateOutputType = {
    id: number | null
    type: $Enums.InterventionType | null
    deviceId: number | null
    maintainerId: number | null
    isRemote: boolean | null
    planDate: Date | null
  }

  export type InterventionCountAggregateOutputType = {
    id: number
    type: number
    deviceId: number
    maintainerId: number
    isRemote: number
    planDate: number
    _all: number
  }


  export type InterventionAvgAggregateInputType = {
    id?: true
    deviceId?: true
    maintainerId?: true
  }

  export type InterventionSumAggregateInputType = {
    id?: true
    deviceId?: true
    maintainerId?: true
  }

  export type InterventionMinAggregateInputType = {
    id?: true
    type?: true
    deviceId?: true
    maintainerId?: true
    isRemote?: true
    planDate?: true
  }

  export type InterventionMaxAggregateInputType = {
    id?: true
    type?: true
    deviceId?: true
    maintainerId?: true
    isRemote?: true
    planDate?: true
  }

  export type InterventionCountAggregateInputType = {
    id?: true
    type?: true
    deviceId?: true
    maintainerId?: true
    isRemote?: true
    planDate?: true
    _all?: true
  }

  export type InterventionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Intervention to aggregate.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interventions
    **/
    _count?: true | InterventionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterventionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterventionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterventionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterventionMaxAggregateInputType
  }

  export type GetInterventionAggregateType<T extends InterventionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntervention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntervention[P]>
      : GetScalarType<T[P], AggregateIntervention[P]>
  }




  export type InterventionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithAggregationInput | InterventionOrderByWithAggregationInput[]
    by: InterventionScalarFieldEnum[] | InterventionScalarFieldEnum
    having?: InterventionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterventionCountAggregateInputType | true
    _avg?: InterventionAvgAggregateInputType
    _sum?: InterventionSumAggregateInputType
    _min?: InterventionMinAggregateInputType
    _max?: InterventionMaxAggregateInputType
  }

  export type InterventionGroupByOutputType = {
    id: number
    type: $Enums.InterventionType
    deviceId: number
    maintainerId: number
    isRemote: boolean
    planDate: Date
    _count: InterventionCountAggregateOutputType | null
    _avg: InterventionAvgAggregateOutputType | null
    _sum: InterventionSumAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  type GetInterventionGroupByPayload<T extends InterventionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterventionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterventionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterventionGroupByOutputType[P]>
            : GetScalarType<T[P], InterventionGroupByOutputType[P]>
        }
      >
    >


  export type InterventionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    deviceId?: boolean
    maintainerId?: boolean
    isRemote?: boolean
    planDate?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    deviceId?: boolean
    maintainerId?: boolean
    isRemote?: boolean
    planDate?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    deviceId?: boolean
    maintainerId?: boolean
    isRemote?: boolean
    planDate?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectScalar = {
    id?: boolean
    type?: boolean
    deviceId?: boolean
    maintainerId?: boolean
    isRemote?: boolean
    planDate?: boolean
  }

  export type InterventionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "deviceId" | "maintainerId" | "isRemote" | "planDate", ExtArgs["result"]["intervention"]>
  export type InterventionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }
  export type InterventionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }
  export type InterventionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    maintainer?: boolean | MaintainerDefaultArgs<ExtArgs>
  }

  export type $InterventionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Intervention"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      maintainer: Prisma.$MaintainerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.InterventionType
      deviceId: number
      maintainerId: number
      isRemote: boolean
      planDate: Date
    }, ExtArgs["result"]["intervention"]>
    composites: {}
  }

  type InterventionGetPayload<S extends boolean | null | undefined | InterventionDefaultArgs> = $Result.GetResult<Prisma.$InterventionPayload, S>

  type InterventionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterventionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterventionCountAggregateInputType | true
    }

  export interface InterventionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Intervention'], meta: { name: 'Intervention' } }
    /**
     * Find zero or one Intervention that matches the filter.
     * @param {InterventionFindUniqueArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterventionFindUniqueArgs>(args: SelectSubset<T, InterventionFindUniqueArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Intervention that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterventionFindUniqueOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterventionFindUniqueOrThrowArgs>(args: SelectSubset<T, InterventionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Intervention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterventionFindFirstArgs>(args?: SelectSubset<T, InterventionFindFirstArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Intervention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterventionFindFirstOrThrowArgs>(args?: SelectSubset<T, InterventionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Interventions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interventions
     * const interventions = await prisma.intervention.findMany()
     * 
     * // Get first 10 Interventions
     * const interventions = await prisma.intervention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interventionWithIdOnly = await prisma.intervention.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterventionFindManyArgs>(args?: SelectSubset<T, InterventionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Intervention.
     * @param {InterventionCreateArgs} args - Arguments to create a Intervention.
     * @example
     * // Create one Intervention
     * const Intervention = await prisma.intervention.create({
     *   data: {
     *     // ... data to create a Intervention
     *   }
     * })
     * 
     */
    create<T extends InterventionCreateArgs>(args: SelectSubset<T, InterventionCreateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Interventions.
     * @param {InterventionCreateManyArgs} args - Arguments to create many Interventions.
     * @example
     * // Create many Interventions
     * const intervention = await prisma.intervention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterventionCreateManyArgs>(args?: SelectSubset<T, InterventionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interventions and returns the data saved in the database.
     * @param {InterventionCreateManyAndReturnArgs} args - Arguments to create many Interventions.
     * @example
     * // Create many Interventions
     * const intervention = await prisma.intervention.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interventions and only return the `id`
     * const interventionWithIdOnly = await prisma.intervention.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterventionCreateManyAndReturnArgs>(args?: SelectSubset<T, InterventionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Intervention.
     * @param {InterventionDeleteArgs} args - Arguments to delete one Intervention.
     * @example
     * // Delete one Intervention
     * const Intervention = await prisma.intervention.delete({
     *   where: {
     *     // ... filter to delete one Intervention
     *   }
     * })
     * 
     */
    delete<T extends InterventionDeleteArgs>(args: SelectSubset<T, InterventionDeleteArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Intervention.
     * @param {InterventionUpdateArgs} args - Arguments to update one Intervention.
     * @example
     * // Update one Intervention
     * const intervention = await prisma.intervention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterventionUpdateArgs>(args: SelectSubset<T, InterventionUpdateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Interventions.
     * @param {InterventionDeleteManyArgs} args - Arguments to filter Interventions to delete.
     * @example
     * // Delete a few Interventions
     * const { count } = await prisma.intervention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterventionDeleteManyArgs>(args?: SelectSubset<T, InterventionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interventions
     * const intervention = await prisma.intervention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterventionUpdateManyArgs>(args: SelectSubset<T, InterventionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interventions and returns the data updated in the database.
     * @param {InterventionUpdateManyAndReturnArgs} args - Arguments to update many Interventions.
     * @example
     * // Update many Interventions
     * const intervention = await prisma.intervention.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interventions and only return the `id`
     * const interventionWithIdOnly = await prisma.intervention.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterventionUpdateManyAndReturnArgs>(args: SelectSubset<T, InterventionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Intervention.
     * @param {InterventionUpsertArgs} args - Arguments to update or create a Intervention.
     * @example
     * // Update or create a Intervention
     * const intervention = await prisma.intervention.upsert({
     *   create: {
     *     // ... data to create a Intervention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intervention we want to update
     *   }
     * })
     */
    upsert<T extends InterventionUpsertArgs>(args: SelectSubset<T, InterventionUpsertArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionCountArgs} args - Arguments to filter Interventions to count.
     * @example
     * // Count the number of Interventions
     * const count = await prisma.intervention.count({
     *   where: {
     *     // ... the filter for the Interventions we want to count
     *   }
     * })
    **/
    count<T extends InterventionCountArgs>(
      args?: Subset<T, InterventionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterventionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterventionAggregateArgs>(args: Subset<T, InterventionAggregateArgs>): Prisma.PrismaPromise<GetInterventionAggregateType<T>>

    /**
     * Group by Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterventionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterventionGroupByArgs['orderBy'] }
        : { orderBy?: InterventionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterventionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterventionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Intervention model
   */
  readonly fields: InterventionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Intervention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterventionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    maintainer<T extends MaintainerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintainerDefaultArgs<ExtArgs>>): Prisma__MaintainerClient<$Result.GetResult<Prisma.$MaintainerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Intervention model
   */ 
  interface InterventionFieldRefs {
    readonly id: FieldRef<"Intervention", 'Int'>
    readonly type: FieldRef<"Intervention", 'InterventionType'>
    readonly deviceId: FieldRef<"Intervention", 'Int'>
    readonly maintainerId: FieldRef<"Intervention", 'Int'>
    readonly isRemote: FieldRef<"Intervention", 'Boolean'>
    readonly planDate: FieldRef<"Intervention", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Intervention findUnique
   */
  export type InterventionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findUniqueOrThrow
   */
  export type InterventionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findFirst
   */
  export type InterventionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findFirstOrThrow
   */
  export type InterventionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findMany
   */
  export type InterventionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Interventions to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention create
   */
  export type InterventionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to create a Intervention.
     */
    data: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
  }

  /**
   * Intervention createMany
   */
  export type InterventionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interventions.
     */
    data: InterventionCreateManyInput | InterventionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Intervention createManyAndReturn
   */
  export type InterventionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * The data used to create many Interventions.
     */
    data: InterventionCreateManyInput | InterventionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Intervention update
   */
  export type InterventionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to update a Intervention.
     */
    data: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
    /**
     * Choose, which Intervention to update.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention updateMany
   */
  export type InterventionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interventions.
     */
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyInput>
    /**
     * Filter which Interventions to update
     */
    where?: InterventionWhereInput
    /**
     * Limit how many Interventions to update.
     */
    limit?: number
  }

  /**
   * Intervention updateManyAndReturn
   */
  export type InterventionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * The data used to update Interventions.
     */
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyInput>
    /**
     * Filter which Interventions to update
     */
    where?: InterventionWhereInput
    /**
     * Limit how many Interventions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Intervention upsert
   */
  export type InterventionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The filter to search for the Intervention to update in case it exists.
     */
    where: InterventionWhereUniqueInput
    /**
     * In case the Intervention found by the `where` argument doesn't exist, create a new Intervention with this data.
     */
    create: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
    /**
     * In case the Intervention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
  }

  /**
   * Intervention delete
   */
  export type InterventionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter which Intervention to delete.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention deleteMany
   */
  export type InterventionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interventions to delete
     */
    where?: InterventionWhereInput
    /**
     * Limit how many Interventions to delete.
     */
    limit?: number
  }

  /**
   * Intervention without action
   */
  export type InterventionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: Date | null
    details: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: Date | null
    details: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    details: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    details?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    details?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    details?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: number
    userId: number
    createdAt: Date
    details: string
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    details?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    details?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    details?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    details?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "details", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      createdAt: Date
      details: string
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {LogUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogUpdateManyAndReturnArgs>(args: SelectSubset<T, LogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */ 
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Int'>
    readonly userId: FieldRef<"Log", 'Int'>
    readonly createdAt: FieldRef<"Log", 'DateTime'>
    readonly details: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log updateManyAndReturn
   */
  export type LogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model KPI
   */

  export type AggregateKPI = {
    _count: KPICountAggregateOutputType | null
    _avg: KPIAvgAggregateOutputType | null
    _sum: KPISumAggregateOutputType | null
    _min: KPIMinAggregateOutputType | null
    _max: KPIMaxAggregateOutputType | null
  }

  export type KPIAvgAggregateOutputType = {
    id: number | null
  }

  export type KPISumAggregateOutputType = {
    id: number | null
  }

  export type KPIMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KPIMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KPICountAggregateOutputType = {
    id: number
    name: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KPIAvgAggregateInputType = {
    id?: true
  }

  export type KPISumAggregateInputType = {
    id?: true
  }

  export type KPIMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KPIMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KPICountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KPIAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KPI to aggregate.
     */
    where?: KPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KPIS to fetch.
     */
    orderBy?: KPIOrderByWithRelationInput | KPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KPIS
    **/
    _count?: true | KPICountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KPIAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KPISumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KPIMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KPIMaxAggregateInputType
  }

  export type GetKPIAggregateType<T extends KPIAggregateArgs> = {
        [P in keyof T & keyof AggregateKPI]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKPI[P]>
      : GetScalarType<T[P], AggregateKPI[P]>
  }




  export type KPIGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KPIWhereInput
    orderBy?: KPIOrderByWithAggregationInput | KPIOrderByWithAggregationInput[]
    by: KPIScalarFieldEnum[] | KPIScalarFieldEnum
    having?: KPIScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KPICountAggregateInputType | true
    _avg?: KPIAvgAggregateInputType
    _sum?: KPISumAggregateInputType
    _min?: KPIMinAggregateInputType
    _max?: KPIMaxAggregateInputType
  }

  export type KPIGroupByOutputType = {
    id: number
    name: string
    value: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: KPICountAggregateOutputType | null
    _avg: KPIAvgAggregateOutputType | null
    _sum: KPISumAggregateOutputType | null
    _min: KPIMinAggregateOutputType | null
    _max: KPIMaxAggregateOutputType | null
  }

  type GetKPIGroupByPayload<T extends KPIGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KPIGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KPIGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KPIGroupByOutputType[P]>
            : GetScalarType<T[P], KPIGroupByOutputType[P]>
        }
      >
    >


  export type KPISelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["kPI"]>

  export type KPISelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["kPI"]>

  export type KPISelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["kPI"]>

  export type KPISelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KPIOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["kPI"]>

  export type $KPIPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KPI"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      value: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kPI"]>
    composites: {}
  }

  type KPIGetPayload<S extends boolean | null | undefined | KPIDefaultArgs> = $Result.GetResult<Prisma.$KPIPayload, S>

  type KPICountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KPIFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KPICountAggregateInputType | true
    }

  export interface KPIDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KPI'], meta: { name: 'KPI' } }
    /**
     * Find zero or one KPI that matches the filter.
     * @param {KPIFindUniqueArgs} args - Arguments to find a KPI
     * @example
     * // Get one KPI
     * const kPI = await prisma.kPI.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KPIFindUniqueArgs>(args: SelectSubset<T, KPIFindUniqueArgs<ExtArgs>>): Prisma__KPIClient<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KPI that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KPIFindUniqueOrThrowArgs} args - Arguments to find a KPI
     * @example
     * // Get one KPI
     * const kPI = await prisma.kPI.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KPIFindUniqueOrThrowArgs>(args: SelectSubset<T, KPIFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KPIClient<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KPI that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KPIFindFirstArgs} args - Arguments to find a KPI
     * @example
     * // Get one KPI
     * const kPI = await prisma.kPI.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KPIFindFirstArgs>(args?: SelectSubset<T, KPIFindFirstArgs<ExtArgs>>): Prisma__KPIClient<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KPI that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KPIFindFirstOrThrowArgs} args - Arguments to find a KPI
     * @example
     * // Get one KPI
     * const kPI = await prisma.kPI.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KPIFindFirstOrThrowArgs>(args?: SelectSubset<T, KPIFindFirstOrThrowArgs<ExtArgs>>): Prisma__KPIClient<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KPIS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KPIFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KPIS
     * const kPIS = await prisma.kPI.findMany()
     * 
     * // Get first 10 KPIS
     * const kPIS = await prisma.kPI.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kPIWithIdOnly = await prisma.kPI.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KPIFindManyArgs>(args?: SelectSubset<T, KPIFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KPI.
     * @param {KPICreateArgs} args - Arguments to create a KPI.
     * @example
     * // Create one KPI
     * const KPI = await prisma.kPI.create({
     *   data: {
     *     // ... data to create a KPI
     *   }
     * })
     * 
     */
    create<T extends KPICreateArgs>(args: SelectSubset<T, KPICreateArgs<ExtArgs>>): Prisma__KPIClient<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KPIS.
     * @param {KPICreateManyArgs} args - Arguments to create many KPIS.
     * @example
     * // Create many KPIS
     * const kPI = await prisma.kPI.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KPICreateManyArgs>(args?: SelectSubset<T, KPICreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KPIS and returns the data saved in the database.
     * @param {KPICreateManyAndReturnArgs} args - Arguments to create many KPIS.
     * @example
     * // Create many KPIS
     * const kPI = await prisma.kPI.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KPIS and only return the `id`
     * const kPIWithIdOnly = await prisma.kPI.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KPICreateManyAndReturnArgs>(args?: SelectSubset<T, KPICreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a KPI.
     * @param {KPIDeleteArgs} args - Arguments to delete one KPI.
     * @example
     * // Delete one KPI
     * const KPI = await prisma.kPI.delete({
     *   where: {
     *     // ... filter to delete one KPI
     *   }
     * })
     * 
     */
    delete<T extends KPIDeleteArgs>(args: SelectSubset<T, KPIDeleteArgs<ExtArgs>>): Prisma__KPIClient<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KPI.
     * @param {KPIUpdateArgs} args - Arguments to update one KPI.
     * @example
     * // Update one KPI
     * const kPI = await prisma.kPI.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KPIUpdateArgs>(args: SelectSubset<T, KPIUpdateArgs<ExtArgs>>): Prisma__KPIClient<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KPIS.
     * @param {KPIDeleteManyArgs} args - Arguments to filter KPIS to delete.
     * @example
     * // Delete a few KPIS
     * const { count } = await prisma.kPI.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KPIDeleteManyArgs>(args?: SelectSubset<T, KPIDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KPIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KPIUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KPIS
     * const kPI = await prisma.kPI.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KPIUpdateManyArgs>(args: SelectSubset<T, KPIUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KPIS and returns the data updated in the database.
     * @param {KPIUpdateManyAndReturnArgs} args - Arguments to update many KPIS.
     * @example
     * // Update many KPIS
     * const kPI = await prisma.kPI.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KPIS and only return the `id`
     * const kPIWithIdOnly = await prisma.kPI.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KPIUpdateManyAndReturnArgs>(args: SelectSubset<T, KPIUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one KPI.
     * @param {KPIUpsertArgs} args - Arguments to update or create a KPI.
     * @example
     * // Update or create a KPI
     * const kPI = await prisma.kPI.upsert({
     *   create: {
     *     // ... data to create a KPI
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KPI we want to update
     *   }
     * })
     */
    upsert<T extends KPIUpsertArgs>(args: SelectSubset<T, KPIUpsertArgs<ExtArgs>>): Prisma__KPIClient<$Result.GetResult<Prisma.$KPIPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KPIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KPICountArgs} args - Arguments to filter KPIS to count.
     * @example
     * // Count the number of KPIS
     * const count = await prisma.kPI.count({
     *   where: {
     *     // ... the filter for the KPIS we want to count
     *   }
     * })
    **/
    count<T extends KPICountArgs>(
      args?: Subset<T, KPICountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KPICountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KPI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KPIAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KPIAggregateArgs>(args: Subset<T, KPIAggregateArgs>): Prisma.PrismaPromise<GetKPIAggregateType<T>>

    /**
     * Group by KPI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KPIGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KPIGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KPIGroupByArgs['orderBy'] }
        : { orderBy?: KPIGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KPIGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKPIGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KPI model
   */
  readonly fields: KPIFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KPI.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KPIClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KPI model
   */ 
  interface KPIFieldRefs {
    readonly id: FieldRef<"KPI", 'Int'>
    readonly name: FieldRef<"KPI", 'String'>
    readonly value: FieldRef<"KPI", 'Json'>
    readonly createdAt: FieldRef<"KPI", 'DateTime'>
    readonly updatedAt: FieldRef<"KPI", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KPI findUnique
   */
  export type KPIFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * Filter, which KPI to fetch.
     */
    where: KPIWhereUniqueInput
  }

  /**
   * KPI findUniqueOrThrow
   */
  export type KPIFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * Filter, which KPI to fetch.
     */
    where: KPIWhereUniqueInput
  }

  /**
   * KPI findFirst
   */
  export type KPIFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * Filter, which KPI to fetch.
     */
    where?: KPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KPIS to fetch.
     */
    orderBy?: KPIOrderByWithRelationInput | KPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KPIS.
     */
    cursor?: KPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KPIS.
     */
    distinct?: KPIScalarFieldEnum | KPIScalarFieldEnum[]
  }

  /**
   * KPI findFirstOrThrow
   */
  export type KPIFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * Filter, which KPI to fetch.
     */
    where?: KPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KPIS to fetch.
     */
    orderBy?: KPIOrderByWithRelationInput | KPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KPIS.
     */
    cursor?: KPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KPIS.
     */
    distinct?: KPIScalarFieldEnum | KPIScalarFieldEnum[]
  }

  /**
   * KPI findMany
   */
  export type KPIFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * Filter, which KPIS to fetch.
     */
    where?: KPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KPIS to fetch.
     */
    orderBy?: KPIOrderByWithRelationInput | KPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KPIS.
     */
    cursor?: KPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KPIS.
     */
    skip?: number
    distinct?: KPIScalarFieldEnum | KPIScalarFieldEnum[]
  }

  /**
   * KPI create
   */
  export type KPICreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * The data needed to create a KPI.
     */
    data: XOR<KPICreateInput, KPIUncheckedCreateInput>
  }

  /**
   * KPI createMany
   */
  export type KPICreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KPIS.
     */
    data: KPICreateManyInput | KPICreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KPI createManyAndReturn
   */
  export type KPICreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * The data used to create many KPIS.
     */
    data: KPICreateManyInput | KPICreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KPI update
   */
  export type KPIUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * The data needed to update a KPI.
     */
    data: XOR<KPIUpdateInput, KPIUncheckedUpdateInput>
    /**
     * Choose, which KPI to update.
     */
    where: KPIWhereUniqueInput
  }

  /**
   * KPI updateMany
   */
  export type KPIUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KPIS.
     */
    data: XOR<KPIUpdateManyMutationInput, KPIUncheckedUpdateManyInput>
    /**
     * Filter which KPIS to update
     */
    where?: KPIWhereInput
    /**
     * Limit how many KPIS to update.
     */
    limit?: number
  }

  /**
   * KPI updateManyAndReturn
   */
  export type KPIUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * The data used to update KPIS.
     */
    data: XOR<KPIUpdateManyMutationInput, KPIUncheckedUpdateManyInput>
    /**
     * Filter which KPIS to update
     */
    where?: KPIWhereInput
    /**
     * Limit how many KPIS to update.
     */
    limit?: number
  }

  /**
   * KPI upsert
   */
  export type KPIUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * The filter to search for the KPI to update in case it exists.
     */
    where: KPIWhereUniqueInput
    /**
     * In case the KPI found by the `where` argument doesn't exist, create a new KPI with this data.
     */
    create: XOR<KPICreateInput, KPIUncheckedCreateInput>
    /**
     * In case the KPI was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KPIUpdateInput, KPIUncheckedUpdateInput>
  }

  /**
   * KPI delete
   */
  export type KPIDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
    /**
     * Filter which KPI to delete.
     */
    where: KPIWhereUniqueInput
  }

  /**
   * KPI deleteMany
   */
  export type KPIDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KPIS to delete
     */
    where?: KPIWhereInput
    /**
     * Limit how many KPIS to delete.
     */
    limit?: number
  }

  /**
   * KPI without action
   */
  export type KPIDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KPI
     */
    select?: KPISelect<ExtArgs> | null
    /**
     * Omit specific fields from the KPI
     */
    omit?: KPIOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    userId: 'userId',
    firstname: 'firstname',
    lastname: 'lastname',
    phonenumber: 'phonenumber',
    address: 'address'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    role: 'role'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const EndUserScalarFieldEnum: {
    id: 'id',
    helperId: 'helperId',
    lastPos: 'lastPos',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type EndUserScalarFieldEnum = (typeof EndUserScalarFieldEnum)[keyof typeof EndUserScalarFieldEnum]


  export const HelperScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type HelperScalarFieldEnum = (typeof HelperScalarFieldEnum)[keyof typeof HelperScalarFieldEnum]


  export const CommercialScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type CommercialScalarFieldEnum = (typeof CommercialScalarFieldEnum)[keyof typeof CommercialScalarFieldEnum]


  export const MaintainerScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type MaintainerScalarFieldEnum = (typeof MaintainerScalarFieldEnum)[keyof typeof MaintainerScalarFieldEnum]


  export const DeciderScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type DeciderScalarFieldEnum = (typeof DeciderScalarFieldEnum)[keyof typeof DeciderScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    type: 'type',
    version: 'version',
    macAdr: 'macAdr',
    status: 'status',
    battery: 'battery',
    lastPos: 'lastPos',
    price: 'price',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const UserDeviceHistoryScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    userId: 'userId',
    useDate: 'useDate'
  };

  export type UserDeviceHistoryScalarFieldEnum = (typeof UserDeviceHistoryScalarFieldEnum)[keyof typeof UserDeviceHistoryScalarFieldEnum]


  export const EnvironmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    cords: 'cords',
    pathCartographie: 'pathCartographie',
    createdAt: 'createdAt',
    scale: 'scale'
  };

  export type EnvironmentScalarFieldEnum = (typeof EnvironmentScalarFieldEnum)[keyof typeof EnvironmentScalarFieldEnum]


  export const EnvUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    envId: 'envId'
  };

  export type EnvUserScalarFieldEnum = (typeof EnvUserScalarFieldEnum)[keyof typeof EnvUserScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    envId: 'envId',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    color: 'color',
    icon: 'icon',
    cords: 'cords'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const POIScalarFieldEnum: {
    id: 'id',
    zoneId: 'zoneId',
    name: 'name',
    category: 'category',
    description: 'description',
    location: 'location'
  };

  export type POIScalarFieldEnum = (typeof POIScalarFieldEnum)[keyof typeof POIScalarFieldEnum]


  export const ObstacleScalarFieldEnum: {
    id: 'id',
    envId: 'envId',
    name: 'name',
    description: 'description',
    cords: 'cords'
  };

  export type ObstacleScalarFieldEnum = (typeof ObstacleScalarFieldEnum)[keyof typeof ObstacleScalarFieldEnum]


  export const ItineraryScalarFieldEnum: {
    id: 'id',
    startPoint: 'startPoint',
    endPoint: 'endPoint',
    envId: 'envId'
  };

  export type ItineraryScalarFieldEnum = (typeof ItineraryScalarFieldEnum)[keyof typeof ItineraryScalarFieldEnum]


  export const HelpRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    helperId: 'helperId'
  };

  export type HelpRequestScalarFieldEnum = (typeof HelpRequestScalarFieldEnum)[keyof typeof HelpRequestScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    buyerId: 'buyerId',
    createdAt: 'createdAt'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const InterventionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    deviceId: 'deviceId',
    maintainerId: 'maintainerId',
    isRemote: 'isRemote',
    planDate: 'planDate'
  };

  export type InterventionScalarFieldEnum = (typeof InterventionScalarFieldEnum)[keyof typeof InterventionScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    details: 'details'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const KPIScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KPIScalarFieldEnum = (typeof KPIScalarFieldEnum)[keyof typeof KPIScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'DeviceStatus'
   */
  export type EnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus'>
    


  /**
   * Reference to a field of type 'DeviceStatus[]'
   */
  export type ListEnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ZoneType'
   */
  export type EnumZoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZoneType'>
    


  /**
   * Reference to a field of type 'ZoneType[]'
   */
  export type ListEnumZoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZoneType[]'>
    


  /**
   * Reference to a field of type 'POICategory'
   */
  export type EnumPOICategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POICategory'>
    


  /**
   * Reference to a field of type 'POICategory[]'
   */
  export type ListEnumPOICategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POICategory[]'>
    


  /**
   * Reference to a field of type 'InterventionType'
   */
  export type EnumInterventionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionType'>
    


  /**
   * Reference to a field of type 'InterventionType[]'
   */
  export type ListEnumInterventionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    endUser?: XOR<EndUserNullableScalarRelationFilter, EndUserWhereInput> | null
    helper?: XOR<HelperNullableScalarRelationFilter, HelperWhereInput> | null
    commercial?: XOR<CommercialNullableScalarRelationFilter, CommercialWhereInput> | null
    maintainer?: XOR<MaintainerNullableScalarRelationFilter, MaintainerWhereInput> | null
    decider?: XOR<DeciderNullableScalarRelationFilter, DeciderWhereInput> | null
    notifications?: NotificationListRelationFilter
    userDeviceHistories?: UserDeviceHistoryListRelationFilter
    envUsers?: EnvUserListRelationFilter
    logs?: LogListRelationFilter
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    endUser?: EndUserOrderByWithRelationInput
    helper?: HelperOrderByWithRelationInput
    commercial?: CommercialOrderByWithRelationInput
    maintainer?: MaintainerOrderByWithRelationInput
    decider?: DeciderOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    userDeviceHistories?: UserDeviceHistoryOrderByRelationAggregateInput
    envUsers?: EnvUserOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    endUser?: XOR<EndUserNullableScalarRelationFilter, EndUserWhereInput> | null
    helper?: XOR<HelperNullableScalarRelationFilter, HelperWhereInput> | null
    commercial?: XOR<CommercialNullableScalarRelationFilter, CommercialWhereInput> | null
    maintainer?: XOR<MaintainerNullableScalarRelationFilter, MaintainerWhereInput> | null
    decider?: XOR<DeciderNullableScalarRelationFilter, DeciderWhereInput> | null
    notifications?: NotificationListRelationFilter
    userDeviceHistories?: UserDeviceHistoryListRelationFilter
    envUsers?: EnvUserListRelationFilter
    logs?: LogListRelationFilter
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleNullableWithAggregatesFilter<"User"> | $Enums.Role | null
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    userId?: IntFilter<"Profile"> | number
    firstname?: StringNullableFilter<"Profile"> | string | null
    lastname?: StringNullableFilter<"Profile"> | string | null
    phonenumber?: StringNullableFilter<"Profile"> | string | null
    address?: StringFilter<"Profile"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    userId?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    phonenumber?: SortOrderInput | SortOrder
    address?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    firstname?: StringNullableFilter<"Profile"> | string | null
    lastname?: StringNullableFilter<"Profile"> | string | null
    phonenumber?: StringNullableFilter<"Profile"> | string | null
    address?: StringFilter<"Profile"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type ProfileOrderByWithAggregationInput = {
    userId?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    phonenumber?: SortOrderInput | SortOrder
    address?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Profile"> | number
    firstname?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lastname?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    phonenumber?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    address?: StringWithAggregatesFilter<"Profile"> | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    userId?: IntFilter<"Admin"> | number
    role?: EnumRoleFilter<"Admin"> | $Enums.Role
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    role?: EnumRoleFilter<"Admin"> | $Enums.Role
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    userId?: IntWithAggregatesFilter<"Admin"> | number
    role?: EnumRoleWithAggregatesFilter<"Admin"> | $Enums.Role
  }

  export type EndUserWhereInput = {
    AND?: EndUserWhereInput | EndUserWhereInput[]
    OR?: EndUserWhereInput[]
    NOT?: EndUserWhereInput | EndUserWhereInput[]
    id?: IntFilter<"EndUser"> | number
    helperId?: IntNullableFilter<"EndUser"> | number | null
    lastPos?: JsonNullableFilter<"EndUser">
    status?: StringFilter<"EndUser"> | string
    userId?: IntFilter<"EndUser"> | number
    createdAt?: DateTimeFilter<"EndUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    helper?: XOR<HelperNullableScalarRelationFilter, HelperWhereInput> | null
    devices?: DeviceListRelationFilter
    helpRequests?: HelpRequestListRelationFilter
    mySales?: SaleListRelationFilter
  }

  export type EndUserOrderByWithRelationInput = {
    id?: SortOrder
    helperId?: SortOrderInput | SortOrder
    lastPos?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    helper?: HelperOrderByWithRelationInput
    devices?: DeviceOrderByRelationAggregateInput
    helpRequests?: HelpRequestOrderByRelationAggregateInput
    mySales?: SaleOrderByRelationAggregateInput
  }

  export type EndUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: EndUserWhereInput | EndUserWhereInput[]
    OR?: EndUserWhereInput[]
    NOT?: EndUserWhereInput | EndUserWhereInput[]
    helperId?: IntNullableFilter<"EndUser"> | number | null
    lastPos?: JsonNullableFilter<"EndUser">
    status?: StringFilter<"EndUser"> | string
    createdAt?: DateTimeFilter<"EndUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    helper?: XOR<HelperNullableScalarRelationFilter, HelperWhereInput> | null
    devices?: DeviceListRelationFilter
    helpRequests?: HelpRequestListRelationFilter
    mySales?: SaleListRelationFilter
  }, "id" | "userId">

  export type EndUserOrderByWithAggregationInput = {
    id?: SortOrder
    helperId?: SortOrderInput | SortOrder
    lastPos?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: EndUserCountOrderByAggregateInput
    _avg?: EndUserAvgOrderByAggregateInput
    _max?: EndUserMaxOrderByAggregateInput
    _min?: EndUserMinOrderByAggregateInput
    _sum?: EndUserSumOrderByAggregateInput
  }

  export type EndUserScalarWhereWithAggregatesInput = {
    AND?: EndUserScalarWhereWithAggregatesInput | EndUserScalarWhereWithAggregatesInput[]
    OR?: EndUserScalarWhereWithAggregatesInput[]
    NOT?: EndUserScalarWhereWithAggregatesInput | EndUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EndUser"> | number
    helperId?: IntNullableWithAggregatesFilter<"EndUser"> | number | null
    lastPos?: JsonNullableWithAggregatesFilter<"EndUser">
    status?: StringWithAggregatesFilter<"EndUser"> | string
    userId?: IntWithAggregatesFilter<"EndUser"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EndUser"> | Date | string
  }

  export type HelperWhereInput = {
    AND?: HelperWhereInput | HelperWhereInput[]
    OR?: HelperWhereInput[]
    NOT?: HelperWhereInput | HelperWhereInput[]
    id?: IntFilter<"Helper"> | number
    userId?: IntFilter<"Helper"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    endUsers?: EndUserListRelationFilter
    helpRequests?: HelpRequestListRelationFilter
  }

  export type HelperOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    endUsers?: EndUserOrderByRelationAggregateInput
    helpRequests?: HelpRequestOrderByRelationAggregateInput
  }

  export type HelperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: HelperWhereInput | HelperWhereInput[]
    OR?: HelperWhereInput[]
    NOT?: HelperWhereInput | HelperWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    endUsers?: EndUserListRelationFilter
    helpRequests?: HelpRequestListRelationFilter
  }, "id" | "userId">

  export type HelperOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: HelperCountOrderByAggregateInput
    _avg?: HelperAvgOrderByAggregateInput
    _max?: HelperMaxOrderByAggregateInput
    _min?: HelperMinOrderByAggregateInput
    _sum?: HelperSumOrderByAggregateInput
  }

  export type HelperScalarWhereWithAggregatesInput = {
    AND?: HelperScalarWhereWithAggregatesInput | HelperScalarWhereWithAggregatesInput[]
    OR?: HelperScalarWhereWithAggregatesInput[]
    NOT?: HelperScalarWhereWithAggregatesInput | HelperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Helper"> | number
    userId?: IntWithAggregatesFilter<"Helper"> | number
  }

  export type CommercialWhereInput = {
    AND?: CommercialWhereInput | CommercialWhereInput[]
    OR?: CommercialWhereInput[]
    NOT?: CommercialWhereInput | CommercialWhereInput[]
    id?: IntFilter<"Commercial"> | number
    userId?: IntFilter<"Commercial"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommercialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CommercialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: CommercialWhereInput | CommercialWhereInput[]
    OR?: CommercialWhereInput[]
    NOT?: CommercialWhereInput | CommercialWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type CommercialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: CommercialCountOrderByAggregateInput
    _avg?: CommercialAvgOrderByAggregateInput
    _max?: CommercialMaxOrderByAggregateInput
    _min?: CommercialMinOrderByAggregateInput
    _sum?: CommercialSumOrderByAggregateInput
  }

  export type CommercialScalarWhereWithAggregatesInput = {
    AND?: CommercialScalarWhereWithAggregatesInput | CommercialScalarWhereWithAggregatesInput[]
    OR?: CommercialScalarWhereWithAggregatesInput[]
    NOT?: CommercialScalarWhereWithAggregatesInput | CommercialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Commercial"> | number
    userId?: IntWithAggregatesFilter<"Commercial"> | number
  }

  export type MaintainerWhereInput = {
    AND?: MaintainerWhereInput | MaintainerWhereInput[]
    OR?: MaintainerWhereInput[]
    NOT?: MaintainerWhereInput | MaintainerWhereInput[]
    id?: IntFilter<"Maintainer"> | number
    userId?: IntFilter<"Maintainer"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    interventions?: InterventionListRelationFilter
  }

  export type MaintainerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    interventions?: InterventionOrderByRelationAggregateInput
  }

  export type MaintainerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: MaintainerWhereInput | MaintainerWhereInput[]
    OR?: MaintainerWhereInput[]
    NOT?: MaintainerWhereInput | MaintainerWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    interventions?: InterventionListRelationFilter
  }, "id" | "userId">

  export type MaintainerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: MaintainerCountOrderByAggregateInput
    _avg?: MaintainerAvgOrderByAggregateInput
    _max?: MaintainerMaxOrderByAggregateInput
    _min?: MaintainerMinOrderByAggregateInput
    _sum?: MaintainerSumOrderByAggregateInput
  }

  export type MaintainerScalarWhereWithAggregatesInput = {
    AND?: MaintainerScalarWhereWithAggregatesInput | MaintainerScalarWhereWithAggregatesInput[]
    OR?: MaintainerScalarWhereWithAggregatesInput[]
    NOT?: MaintainerScalarWhereWithAggregatesInput | MaintainerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Maintainer"> | number
    userId?: IntWithAggregatesFilter<"Maintainer"> | number
  }

  export type DeciderWhereInput = {
    AND?: DeciderWhereInput | DeciderWhereInput[]
    OR?: DeciderWhereInput[]
    NOT?: DeciderWhereInput | DeciderWhereInput[]
    id?: IntFilter<"Decider"> | number
    userId?: IntFilter<"Decider"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeciderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeciderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: DeciderWhereInput | DeciderWhereInput[]
    OR?: DeciderWhereInput[]
    NOT?: DeciderWhereInput | DeciderWhereInput[]
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type DeciderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: DeciderCountOrderByAggregateInput
    _avg?: DeciderAvgOrderByAggregateInput
    _max?: DeciderMaxOrderByAggregateInput
    _min?: DeciderMinOrderByAggregateInput
    _sum?: DeciderSumOrderByAggregateInput
  }

  export type DeciderScalarWhereWithAggregatesInput = {
    AND?: DeciderScalarWhereWithAggregatesInput | DeciderScalarWhereWithAggregatesInput[]
    OR?: DeciderScalarWhereWithAggregatesInput[]
    NOT?: DeciderScalarWhereWithAggregatesInput | DeciderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Decider"> | number
    userId?: IntWithAggregatesFilter<"Decider"> | number
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: IntFilter<"Device"> | number
    type?: StringFilter<"Device"> | string
    version?: StringFilter<"Device"> | string
    macAdr?: StringNullableFilter<"Device"> | string | null
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    battery?: IntFilter<"Device"> | number
    lastPos?: JsonNullableFilter<"Device">
    price?: IntNullableFilter<"Device"> | number | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    userId?: IntNullableFilter<"Device"> | number | null
    user?: XOR<EndUserNullableScalarRelationFilter, EndUserWhereInput> | null
    sales?: SaleListRelationFilter
    userDeviceHistories?: UserDeviceHistoryListRelationFilter
    interventions?: InterventionListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    version?: SortOrder
    macAdr?: SortOrderInput | SortOrder
    status?: SortOrder
    battery?: SortOrder
    lastPos?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: EndUserOrderByWithRelationInput
    sales?: SaleOrderByRelationAggregateInput
    userDeviceHistories?: UserDeviceHistoryOrderByRelationAggregateInput
    interventions?: InterventionOrderByRelationAggregateInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    type?: StringFilter<"Device"> | string
    version?: StringFilter<"Device"> | string
    macAdr?: StringNullableFilter<"Device"> | string | null
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    battery?: IntFilter<"Device"> | number
    lastPos?: JsonNullableFilter<"Device">
    price?: IntNullableFilter<"Device"> | number | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    userId?: IntNullableFilter<"Device"> | number | null
    user?: XOR<EndUserNullableScalarRelationFilter, EndUserWhereInput> | null
    sales?: SaleListRelationFilter
    userDeviceHistories?: UserDeviceHistoryListRelationFilter
    interventions?: InterventionListRelationFilter
  }, "id">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    version?: SortOrder
    macAdr?: SortOrderInput | SortOrder
    status?: SortOrder
    battery?: SortOrder
    lastPos?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Device"> | number
    type?: StringWithAggregatesFilter<"Device"> | string
    version?: StringWithAggregatesFilter<"Device"> | string
    macAdr?: StringNullableWithAggregatesFilter<"Device"> | string | null
    status?: EnumDeviceStatusWithAggregatesFilter<"Device"> | $Enums.DeviceStatus
    battery?: IntWithAggregatesFilter<"Device"> | number
    lastPos?: JsonNullableWithAggregatesFilter<"Device">
    price?: IntNullableWithAggregatesFilter<"Device"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"Device"> | number | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: IntFilter<"Notification"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: IntFilter<"Notification"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    content?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    userId?: IntWithAggregatesFilter<"Notification"> | number
  }

  export type UserDeviceHistoryWhereInput = {
    AND?: UserDeviceHistoryWhereInput | UserDeviceHistoryWhereInput[]
    OR?: UserDeviceHistoryWhereInput[]
    NOT?: UserDeviceHistoryWhereInput | UserDeviceHistoryWhereInput[]
    id?: IntFilter<"UserDeviceHistory"> | number
    deviceId?: IntFilter<"UserDeviceHistory"> | number
    userId?: IntFilter<"UserDeviceHistory"> | number
    useDate?: DateTimeFilter<"UserDeviceHistory"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserDeviceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    useDate?: SortOrder
    device?: DeviceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserDeviceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserDeviceHistoryWhereInput | UserDeviceHistoryWhereInput[]
    OR?: UserDeviceHistoryWhereInput[]
    NOT?: UserDeviceHistoryWhereInput | UserDeviceHistoryWhereInput[]
    deviceId?: IntFilter<"UserDeviceHistory"> | number
    userId?: IntFilter<"UserDeviceHistory"> | number
    useDate?: DateTimeFilter<"UserDeviceHistory"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserDeviceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    useDate?: SortOrder
    _count?: UserDeviceHistoryCountOrderByAggregateInput
    _avg?: UserDeviceHistoryAvgOrderByAggregateInput
    _max?: UserDeviceHistoryMaxOrderByAggregateInput
    _min?: UserDeviceHistoryMinOrderByAggregateInput
    _sum?: UserDeviceHistorySumOrderByAggregateInput
  }

  export type UserDeviceHistoryScalarWhereWithAggregatesInput = {
    AND?: UserDeviceHistoryScalarWhereWithAggregatesInput | UserDeviceHistoryScalarWhereWithAggregatesInput[]
    OR?: UserDeviceHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserDeviceHistoryScalarWhereWithAggregatesInput | UserDeviceHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserDeviceHistory"> | number
    deviceId?: IntWithAggregatesFilter<"UserDeviceHistory"> | number
    userId?: IntWithAggregatesFilter<"UserDeviceHistory"> | number
    useDate?: DateTimeWithAggregatesFilter<"UserDeviceHistory"> | Date | string
  }

  export type EnvironmentWhereInput = {
    AND?: EnvironmentWhereInput | EnvironmentWhereInput[]
    OR?: EnvironmentWhereInput[]
    NOT?: EnvironmentWhereInput | EnvironmentWhereInput[]
    id?: IntFilter<"Environment"> | number
    name?: StringFilter<"Environment"> | string
    address?: StringFilter<"Environment"> | string
    cords?: JsonFilter<"Environment">
    pathCartographie?: StringFilter<"Environment"> | string
    createdAt?: DateTimeFilter<"Environment"> | Date | string
    scale?: IntFilter<"Environment"> | number
    zones?: ZoneListRelationFilter
    obstacles?: ObstacleListRelationFilter
    envUsers?: EnvUserListRelationFilter
    routes?: ItineraryListRelationFilter
  }

  export type EnvironmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    cords?: SortOrder
    pathCartographie?: SortOrder
    createdAt?: SortOrder
    scale?: SortOrder
    zones?: ZoneOrderByRelationAggregateInput
    obstacles?: ObstacleOrderByRelationAggregateInput
    envUsers?: EnvUserOrderByRelationAggregateInput
    routes?: ItineraryOrderByRelationAggregateInput
  }

  export type EnvironmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EnvironmentWhereInput | EnvironmentWhereInput[]
    OR?: EnvironmentWhereInput[]
    NOT?: EnvironmentWhereInput | EnvironmentWhereInput[]
    name?: StringFilter<"Environment"> | string
    address?: StringFilter<"Environment"> | string
    cords?: JsonFilter<"Environment">
    pathCartographie?: StringFilter<"Environment"> | string
    createdAt?: DateTimeFilter<"Environment"> | Date | string
    scale?: IntFilter<"Environment"> | number
    zones?: ZoneListRelationFilter
    obstacles?: ObstacleListRelationFilter
    envUsers?: EnvUserListRelationFilter
    routes?: ItineraryListRelationFilter
  }, "id">

  export type EnvironmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    cords?: SortOrder
    pathCartographie?: SortOrder
    createdAt?: SortOrder
    scale?: SortOrder
    _count?: EnvironmentCountOrderByAggregateInput
    _avg?: EnvironmentAvgOrderByAggregateInput
    _max?: EnvironmentMaxOrderByAggregateInput
    _min?: EnvironmentMinOrderByAggregateInput
    _sum?: EnvironmentSumOrderByAggregateInput
  }

  export type EnvironmentScalarWhereWithAggregatesInput = {
    AND?: EnvironmentScalarWhereWithAggregatesInput | EnvironmentScalarWhereWithAggregatesInput[]
    OR?: EnvironmentScalarWhereWithAggregatesInput[]
    NOT?: EnvironmentScalarWhereWithAggregatesInput | EnvironmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Environment"> | number
    name?: StringWithAggregatesFilter<"Environment"> | string
    address?: StringWithAggregatesFilter<"Environment"> | string
    cords?: JsonWithAggregatesFilter<"Environment">
    pathCartographie?: StringWithAggregatesFilter<"Environment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Environment"> | Date | string
    scale?: IntWithAggregatesFilter<"Environment"> | number
  }

  export type EnvUserWhereInput = {
    AND?: EnvUserWhereInput | EnvUserWhereInput[]
    OR?: EnvUserWhereInput[]
    NOT?: EnvUserWhereInput | EnvUserWhereInput[]
    id?: IntFilter<"EnvUser"> | number
    userId?: IntFilter<"EnvUser"> | number
    envId?: IntFilter<"EnvUser"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    environment?: XOR<EnvironmentScalarRelationFilter, EnvironmentWhereInput>
  }

  export type EnvUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    envId?: SortOrder
    user?: UserOrderByWithRelationInput
    environment?: EnvironmentOrderByWithRelationInput
  }

  export type EnvUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EnvUserWhereInput | EnvUserWhereInput[]
    OR?: EnvUserWhereInput[]
    NOT?: EnvUserWhereInput | EnvUserWhereInput[]
    userId?: IntFilter<"EnvUser"> | number
    envId?: IntFilter<"EnvUser"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    environment?: XOR<EnvironmentScalarRelationFilter, EnvironmentWhereInput>
  }, "id">

  export type EnvUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    envId?: SortOrder
    _count?: EnvUserCountOrderByAggregateInput
    _avg?: EnvUserAvgOrderByAggregateInput
    _max?: EnvUserMaxOrderByAggregateInput
    _min?: EnvUserMinOrderByAggregateInput
    _sum?: EnvUserSumOrderByAggregateInput
  }

  export type EnvUserScalarWhereWithAggregatesInput = {
    AND?: EnvUserScalarWhereWithAggregatesInput | EnvUserScalarWhereWithAggregatesInput[]
    OR?: EnvUserScalarWhereWithAggregatesInput[]
    NOT?: EnvUserScalarWhereWithAggregatesInput | EnvUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EnvUser"> | number
    userId?: IntWithAggregatesFilter<"EnvUser"> | number
    envId?: IntWithAggregatesFilter<"EnvUser"> | number
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: IntFilter<"Zone"> | number
    envId?: IntFilter<"Zone"> | number
    name?: StringFilter<"Zone"> | string
    type?: EnumZoneTypeFilter<"Zone"> | $Enums.ZoneType
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    color?: StringFilter<"Zone"> | string
    icon?: StringFilter<"Zone"> | string
    cords?: JsonFilter<"Zone">
    environment?: XOR<EnvironmentScalarRelationFilter, EnvironmentWhereInput>
    pois?: POIListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    cords?: SortOrder
    environment?: EnvironmentOrderByWithRelationInput
    pois?: POIOrderByRelationAggregateInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    envId?: IntFilter<"Zone"> | number
    name?: StringFilter<"Zone"> | string
    type?: EnumZoneTypeFilter<"Zone"> | $Enums.ZoneType
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    color?: StringFilter<"Zone"> | string
    icon?: StringFilter<"Zone"> | string
    cords?: JsonFilter<"Zone">
    environment?: XOR<EnvironmentScalarRelationFilter, EnvironmentWhereInput>
    pois?: POIListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    cords?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _avg?: ZoneAvgOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
    _sum?: ZoneSumOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Zone"> | number
    envId?: IntWithAggregatesFilter<"Zone"> | number
    name?: StringWithAggregatesFilter<"Zone"> | string
    type?: EnumZoneTypeWithAggregatesFilter<"Zone"> | $Enums.ZoneType
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    color?: StringWithAggregatesFilter<"Zone"> | string
    icon?: StringWithAggregatesFilter<"Zone"> | string
    cords?: JsonWithAggregatesFilter<"Zone">
  }

  export type POIWhereInput = {
    AND?: POIWhereInput | POIWhereInput[]
    OR?: POIWhereInput[]
    NOT?: POIWhereInput | POIWhereInput[]
    id?: IntFilter<"POI"> | number
    zoneId?: IntFilter<"POI"> | number
    name?: StringFilter<"POI"> | string
    category?: EnumPOICategoryFilter<"POI"> | $Enums.POICategory
    description?: StringFilter<"POI"> | string
    location?: JsonFilter<"POI">
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
  }

  export type POIOrderByWithRelationInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    location?: SortOrder
    zone?: ZoneOrderByWithRelationInput
  }

  export type POIWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: POIWhereInput | POIWhereInput[]
    OR?: POIWhereInput[]
    NOT?: POIWhereInput | POIWhereInput[]
    zoneId?: IntFilter<"POI"> | number
    name?: StringFilter<"POI"> | string
    category?: EnumPOICategoryFilter<"POI"> | $Enums.POICategory
    description?: StringFilter<"POI"> | string
    location?: JsonFilter<"POI">
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
  }, "id">

  export type POIOrderByWithAggregationInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    location?: SortOrder
    _count?: POICountOrderByAggregateInput
    _avg?: POIAvgOrderByAggregateInput
    _max?: POIMaxOrderByAggregateInput
    _min?: POIMinOrderByAggregateInput
    _sum?: POISumOrderByAggregateInput
  }

  export type POIScalarWhereWithAggregatesInput = {
    AND?: POIScalarWhereWithAggregatesInput | POIScalarWhereWithAggregatesInput[]
    OR?: POIScalarWhereWithAggregatesInput[]
    NOT?: POIScalarWhereWithAggregatesInput | POIScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"POI"> | number
    zoneId?: IntWithAggregatesFilter<"POI"> | number
    name?: StringWithAggregatesFilter<"POI"> | string
    category?: EnumPOICategoryWithAggregatesFilter<"POI"> | $Enums.POICategory
    description?: StringWithAggregatesFilter<"POI"> | string
    location?: JsonWithAggregatesFilter<"POI">
  }

  export type ObstacleWhereInput = {
    AND?: ObstacleWhereInput | ObstacleWhereInput[]
    OR?: ObstacleWhereInput[]
    NOT?: ObstacleWhereInput | ObstacleWhereInput[]
    id?: IntFilter<"Obstacle"> | number
    envId?: IntFilter<"Obstacle"> | number
    name?: StringFilter<"Obstacle"> | string
    description?: StringFilter<"Obstacle"> | string
    cords?: JsonFilter<"Obstacle">
    environment?: XOR<EnvironmentScalarRelationFilter, EnvironmentWhereInput>
  }

  export type ObstacleOrderByWithRelationInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cords?: SortOrder
    environment?: EnvironmentOrderByWithRelationInput
  }

  export type ObstacleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ObstacleWhereInput | ObstacleWhereInput[]
    OR?: ObstacleWhereInput[]
    NOT?: ObstacleWhereInput | ObstacleWhereInput[]
    envId?: IntFilter<"Obstacle"> | number
    name?: StringFilter<"Obstacle"> | string
    description?: StringFilter<"Obstacle"> | string
    cords?: JsonFilter<"Obstacle">
    environment?: XOR<EnvironmentScalarRelationFilter, EnvironmentWhereInput>
  }, "id">

  export type ObstacleOrderByWithAggregationInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cords?: SortOrder
    _count?: ObstacleCountOrderByAggregateInput
    _avg?: ObstacleAvgOrderByAggregateInput
    _max?: ObstacleMaxOrderByAggregateInput
    _min?: ObstacleMinOrderByAggregateInput
    _sum?: ObstacleSumOrderByAggregateInput
  }

  export type ObstacleScalarWhereWithAggregatesInput = {
    AND?: ObstacleScalarWhereWithAggregatesInput | ObstacleScalarWhereWithAggregatesInput[]
    OR?: ObstacleScalarWhereWithAggregatesInput[]
    NOT?: ObstacleScalarWhereWithAggregatesInput | ObstacleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Obstacle"> | number
    envId?: IntWithAggregatesFilter<"Obstacle"> | number
    name?: StringWithAggregatesFilter<"Obstacle"> | string
    description?: StringWithAggregatesFilter<"Obstacle"> | string
    cords?: JsonWithAggregatesFilter<"Obstacle">
  }

  export type ItineraryWhereInput = {
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    id?: IntFilter<"Itinerary"> | number
    startPoint?: JsonFilter<"Itinerary">
    endPoint?: JsonFilter<"Itinerary">
    envId?: IntFilter<"Itinerary"> | number
    environement?: XOR<EnvironmentScalarRelationFilter, EnvironmentWhereInput>
  }

  export type ItineraryOrderByWithRelationInput = {
    id?: SortOrder
    startPoint?: SortOrder
    endPoint?: SortOrder
    envId?: SortOrder
    environement?: EnvironmentOrderByWithRelationInput
  }

  export type ItineraryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    startPoint?: JsonFilter<"Itinerary">
    endPoint?: JsonFilter<"Itinerary">
    envId?: IntFilter<"Itinerary"> | number
    environement?: XOR<EnvironmentScalarRelationFilter, EnvironmentWhereInput>
  }, "id">

  export type ItineraryOrderByWithAggregationInput = {
    id?: SortOrder
    startPoint?: SortOrder
    endPoint?: SortOrder
    envId?: SortOrder
    _count?: ItineraryCountOrderByAggregateInput
    _avg?: ItineraryAvgOrderByAggregateInput
    _max?: ItineraryMaxOrderByAggregateInput
    _min?: ItineraryMinOrderByAggregateInput
    _sum?: ItinerarySumOrderByAggregateInput
  }

  export type ItineraryScalarWhereWithAggregatesInput = {
    AND?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    OR?: ItineraryScalarWhereWithAggregatesInput[]
    NOT?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Itinerary"> | number
    startPoint?: JsonWithAggregatesFilter<"Itinerary">
    endPoint?: JsonWithAggregatesFilter<"Itinerary">
    envId?: IntWithAggregatesFilter<"Itinerary"> | number
  }

  export type HelpRequestWhereInput = {
    AND?: HelpRequestWhereInput | HelpRequestWhereInput[]
    OR?: HelpRequestWhereInput[]
    NOT?: HelpRequestWhereInput | HelpRequestWhereInput[]
    id?: IntFilter<"HelpRequest"> | number
    userId?: IntFilter<"HelpRequest"> | number
    helperId?: IntFilter<"HelpRequest"> | number
    user?: XOR<EndUserScalarRelationFilter, EndUserWhereInput>
    helper?: XOR<HelperScalarRelationFilter, HelperWhereInput>
  }

  export type HelpRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    helperId?: SortOrder
    user?: EndUserOrderByWithRelationInput
    helper?: HelperOrderByWithRelationInput
  }

  export type HelpRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HelpRequestWhereInput | HelpRequestWhereInput[]
    OR?: HelpRequestWhereInput[]
    NOT?: HelpRequestWhereInput | HelpRequestWhereInput[]
    userId?: IntFilter<"HelpRequest"> | number
    helperId?: IntFilter<"HelpRequest"> | number
    user?: XOR<EndUserScalarRelationFilter, EndUserWhereInput>
    helper?: XOR<HelperScalarRelationFilter, HelperWhereInput>
  }, "id">

  export type HelpRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    helperId?: SortOrder
    _count?: HelpRequestCountOrderByAggregateInput
    _avg?: HelpRequestAvgOrderByAggregateInput
    _max?: HelpRequestMaxOrderByAggregateInput
    _min?: HelpRequestMinOrderByAggregateInput
    _sum?: HelpRequestSumOrderByAggregateInput
  }

  export type HelpRequestScalarWhereWithAggregatesInput = {
    AND?: HelpRequestScalarWhereWithAggregatesInput | HelpRequestScalarWhereWithAggregatesInput[]
    OR?: HelpRequestScalarWhereWithAggregatesInput[]
    NOT?: HelpRequestScalarWhereWithAggregatesInput | HelpRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HelpRequest"> | number
    userId?: IntWithAggregatesFilter<"HelpRequest"> | number
    helperId?: IntWithAggregatesFilter<"HelpRequest"> | number
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: IntFilter<"Sale"> | number
    deviceId?: IntFilter<"Sale"> | number
    buyerId?: IntFilter<"Sale"> | number
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    buyer?: XOR<EndUserScalarRelationFilter, EndUserWhereInput>
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    buyerId?: SortOrder
    createdAt?: SortOrder
    device?: DeviceOrderByWithRelationInput
    buyer?: EndUserOrderByWithRelationInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    deviceId?: IntFilter<"Sale"> | number
    buyerId?: IntFilter<"Sale"> | number
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    buyer?: XOR<EndUserScalarRelationFilter, EndUserWhereInput>
  }, "id">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    buyerId?: SortOrder
    createdAt?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sale"> | number
    deviceId?: IntWithAggregatesFilter<"Sale"> | number
    buyerId?: IntWithAggregatesFilter<"Sale"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
  }

  export type InterventionWhereInput = {
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    id?: IntFilter<"Intervention"> | number
    type?: EnumInterventionTypeFilter<"Intervention"> | $Enums.InterventionType
    deviceId?: IntFilter<"Intervention"> | number
    maintainerId?: IntFilter<"Intervention"> | number
    isRemote?: BoolFilter<"Intervention"> | boolean
    planDate?: DateTimeFilter<"Intervention"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    maintainer?: XOR<MaintainerScalarRelationFilter, MaintainerWhereInput>
  }

  export type InterventionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    maintainerId?: SortOrder
    isRemote?: SortOrder
    planDate?: SortOrder
    device?: DeviceOrderByWithRelationInput
    maintainer?: MaintainerOrderByWithRelationInput
  }

  export type InterventionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    type?: EnumInterventionTypeFilter<"Intervention"> | $Enums.InterventionType
    deviceId?: IntFilter<"Intervention"> | number
    maintainerId?: IntFilter<"Intervention"> | number
    isRemote?: BoolFilter<"Intervention"> | boolean
    planDate?: DateTimeFilter<"Intervention"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, DeviceWhereInput>
    maintainer?: XOR<MaintainerScalarRelationFilter, MaintainerWhereInput>
  }, "id">

  export type InterventionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    maintainerId?: SortOrder
    isRemote?: SortOrder
    planDate?: SortOrder
    _count?: InterventionCountOrderByAggregateInput
    _avg?: InterventionAvgOrderByAggregateInput
    _max?: InterventionMaxOrderByAggregateInput
    _min?: InterventionMinOrderByAggregateInput
    _sum?: InterventionSumOrderByAggregateInput
  }

  export type InterventionScalarWhereWithAggregatesInput = {
    AND?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    OR?: InterventionScalarWhereWithAggregatesInput[]
    NOT?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Intervention"> | number
    type?: EnumInterventionTypeWithAggregatesFilter<"Intervention"> | $Enums.InterventionType
    deviceId?: IntWithAggregatesFilter<"Intervention"> | number
    maintainerId?: IntWithAggregatesFilter<"Intervention"> | number
    isRemote?: BoolWithAggregatesFilter<"Intervention"> | boolean
    planDate?: DateTimeWithAggregatesFilter<"Intervention"> | Date | string
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: IntFilter<"Log"> | number
    userId?: IntFilter<"Log"> | number
    createdAt?: DateTimeFilter<"Log"> | Date | string
    details?: StringFilter<"Log"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    details?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    userId?: IntFilter<"Log"> | number
    createdAt?: DateTimeFilter<"Log"> | Date | string
    details?: StringFilter<"Log"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    details?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Log"> | number
    userId?: IntWithAggregatesFilter<"Log"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    details?: StringWithAggregatesFilter<"Log"> | string
  }

  export type KPIWhereInput = {
    AND?: KPIWhereInput | KPIWhereInput[]
    OR?: KPIWhereInput[]
    NOT?: KPIWhereInput | KPIWhereInput[]
    id?: IntFilter<"KPI"> | number
    name?: StringFilter<"KPI"> | string
    value?: JsonFilter<"KPI">
    createdAt?: DateTimeFilter<"KPI"> | Date | string
    updatedAt?: DateTimeFilter<"KPI"> | Date | string
  }

  export type KPIOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KPIWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: KPIWhereInput | KPIWhereInput[]
    OR?: KPIWhereInput[]
    NOT?: KPIWhereInput | KPIWhereInput[]
    value?: JsonFilter<"KPI">
    createdAt?: DateTimeFilter<"KPI"> | Date | string
    updatedAt?: DateTimeFilter<"KPI"> | Date | string
  }, "id" | "name">

  export type KPIOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KPICountOrderByAggregateInput
    _avg?: KPIAvgOrderByAggregateInput
    _max?: KPIMaxOrderByAggregateInput
    _min?: KPIMinOrderByAggregateInput
    _sum?: KPISumOrderByAggregateInput
  }

  export type KPIScalarWhereWithAggregatesInput = {
    AND?: KPIScalarWhereWithAggregatesInput | KPIScalarWhereWithAggregatesInput[]
    OR?: KPIScalarWhereWithAggregatesInput[]
    NOT?: KPIScalarWhereWithAggregatesInput | KPIScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KPI"> | number
    name?: StringWithAggregatesFilter<"KPI"> | string
    value?: JsonWithAggregatesFilter<"KPI">
    createdAt?: DateTimeWithAggregatesFilter<"KPI"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KPI"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
  }

  export type ProfileCreateInput = {
    firstname?: string | null
    lastname?: string | null
    phonenumber?: string | null
    address: string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    userId: number
    firstname?: string | null
    lastname?: string | null
    phonenumber?: string | null
    address: string
  }

  export type ProfileUpdateInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateManyInput = {
    userId: number
    firstname?: string | null
    lastname?: string | null
    phonenumber?: string | null
    address: string
  }

  export type ProfileUpdateManyMutationInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateInput = {
    role: $Enums.Role
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    userId: number
    role: $Enums.Role
  }

  export type AdminUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AdminCreateManyInput = {
    id?: number
    userId: number
    role: $Enums.Role
  }

  export type AdminUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type EndUserCreateInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEndUserInput
    helper?: HelperCreateNestedOneWithoutEndUsersInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    helpRequests?: HelpRequestCreateNestedManyWithoutUserInput
    mySales?: SaleCreateNestedManyWithoutBuyerInput
  }

  export type EndUserUncheckedCreateInput = {
    id?: number
    helperId?: number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userId: number
    createdAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    helpRequests?: HelpRequestUncheckedCreateNestedManyWithoutUserInput
    mySales?: SaleUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type EndUserUpdateInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEndUserNestedInput
    helper?: HelperUpdateOneWithoutEndUsersNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    helpRequests?: HelpRequestUpdateManyWithoutUserNestedInput
    mySales?: SaleUpdateManyWithoutBuyerNestedInput
  }

  export type EndUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    helperId?: NullableIntFieldUpdateOperationsInput | number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    helpRequests?: HelpRequestUncheckedUpdateManyWithoutUserNestedInput
    mySales?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type EndUserCreateManyInput = {
    id?: number
    helperId?: number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userId: number
    createdAt?: Date | string
  }

  export type EndUserUpdateManyMutationInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EndUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    helperId?: NullableIntFieldUpdateOperationsInput | number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelperCreateInput = {
    user: UserCreateNestedOneWithoutHelperInput
    endUsers?: EndUserCreateNestedManyWithoutHelperInput
    helpRequests?: HelpRequestCreateNestedManyWithoutHelperInput
  }

  export type HelperUncheckedCreateInput = {
    id?: number
    userId: number
    endUsers?: EndUserUncheckedCreateNestedManyWithoutHelperInput
    helpRequests?: HelpRequestUncheckedCreateNestedManyWithoutHelperInput
  }

  export type HelperUpdateInput = {
    user?: UserUpdateOneRequiredWithoutHelperNestedInput
    endUsers?: EndUserUpdateManyWithoutHelperNestedInput
    helpRequests?: HelpRequestUpdateManyWithoutHelperNestedInput
  }

  export type HelperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    endUsers?: EndUserUncheckedUpdateManyWithoutHelperNestedInput
    helpRequests?: HelpRequestUncheckedUpdateManyWithoutHelperNestedInput
  }

  export type HelperCreateManyInput = {
    id?: number
    userId: number
  }

  export type HelperUpdateManyMutationInput = {

  }

  export type HelperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommercialCreateInput = {
    user: UserCreateNestedOneWithoutCommercialInput
  }

  export type CommercialUncheckedCreateInput = {
    id?: number
    userId: number
  }

  export type CommercialUpdateInput = {
    user?: UserUpdateOneRequiredWithoutCommercialNestedInput
  }

  export type CommercialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommercialCreateManyInput = {
    id?: number
    userId: number
  }

  export type CommercialUpdateManyMutationInput = {

  }

  export type CommercialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type MaintainerCreateInput = {
    user: UserCreateNestedOneWithoutMaintainerInput
    interventions?: InterventionCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerUncheckedCreateInput = {
    id?: number
    userId: number
    interventions?: InterventionUncheckedCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerUpdateInput = {
    user?: UserUpdateOneRequiredWithoutMaintainerNestedInput
    interventions?: InterventionUpdateManyWithoutMaintainerNestedInput
  }

  export type MaintainerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    interventions?: InterventionUncheckedUpdateManyWithoutMaintainerNestedInput
  }

  export type MaintainerCreateManyInput = {
    id?: number
    userId: number
  }

  export type MaintainerUpdateManyMutationInput = {

  }

  export type MaintainerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type DeciderCreateInput = {
    user: UserCreateNestedOneWithoutDeciderInput
  }

  export type DeciderUncheckedCreateInput = {
    id?: number
    userId: number
  }

  export type DeciderUpdateInput = {
    user?: UserUpdateOneRequiredWithoutDeciderNestedInput
  }

  export type DeciderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type DeciderCreateManyInput = {
    id?: number
    userId: number
  }

  export type DeciderUpdateManyMutationInput = {

  }

  export type DeciderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceCreateInput = {
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    user?: EndUserCreateNestedOneWithoutDevicesInput
    sales?: SaleCreateNestedManyWithoutDeviceInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutDeviceInput
    interventions?: InterventionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: number
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    userId?: number | null
    sales?: SaleUncheckedCreateNestedManyWithoutDeviceInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutDeviceInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: EndUserUpdateOneWithoutDevicesNestedInput
    sales?: SaleUpdateManyWithoutDeviceNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutDeviceNestedInput
    interventions?: InterventionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: SaleUncheckedUpdateManyWithoutDeviceNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutDeviceNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: number
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    userId?: number | null
  }

  export type DeviceUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationCreateInput = {
    content: string
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: number
  }

  export type NotificationUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateManyInput = {
    id?: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: number
  }

  export type NotificationUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserDeviceHistoryCreateInput = {
    useDate?: Date | string
    device: DeviceCreateNestedOneWithoutUserDeviceHistoriesInput
    user: UserCreateNestedOneWithoutUserDeviceHistoriesInput
  }

  export type UserDeviceHistoryUncheckedCreateInput = {
    id?: number
    deviceId: number
    userId: number
    useDate?: Date | string
  }

  export type UserDeviceHistoryUpdateInput = {
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutUserDeviceHistoriesNestedInput
    user?: UserUpdateOneRequiredWithoutUserDeviceHistoriesNestedInput
  }

  export type UserDeviceHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceHistoryCreateManyInput = {
    id?: number
    deviceId: number
    userId: number
    useDate?: Date | string
  }

  export type UserDeviceHistoryUpdateManyMutationInput = {
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvironmentCreateInput = {
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    zones?: ZoneCreateNestedManyWithoutEnvironmentInput
    obstacles?: ObstacleCreateNestedManyWithoutEnvironmentInput
    envUsers?: EnvUserCreateNestedManyWithoutEnvironmentInput
    routes?: ItineraryCreateNestedManyWithoutEnvironementInput
  }

  export type EnvironmentUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    zones?: ZoneUncheckedCreateNestedManyWithoutEnvironmentInput
    obstacles?: ObstacleUncheckedCreateNestedManyWithoutEnvironmentInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutEnvironmentInput
    routes?: ItineraryUncheckedCreateNestedManyWithoutEnvironementInput
  }

  export type EnvironmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    zones?: ZoneUpdateManyWithoutEnvironmentNestedInput
    obstacles?: ObstacleUpdateManyWithoutEnvironmentNestedInput
    envUsers?: EnvUserUpdateManyWithoutEnvironmentNestedInput
    routes?: ItineraryUpdateManyWithoutEnvironementNestedInput
  }

  export type EnvironmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    zones?: ZoneUncheckedUpdateManyWithoutEnvironmentNestedInput
    obstacles?: ObstacleUncheckedUpdateManyWithoutEnvironmentNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutEnvironmentNestedInput
    routes?: ItineraryUncheckedUpdateManyWithoutEnvironementNestedInput
  }

  export type EnvironmentCreateManyInput = {
    id?: number
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
  }

  export type EnvironmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
  }

  export type EnvironmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
  }

  export type EnvUserCreateInput = {
    user: UserCreateNestedOneWithoutEnvUsersInput
    environment: EnvironmentCreateNestedOneWithoutEnvUsersInput
  }

  export type EnvUserUncheckedCreateInput = {
    id?: number
    userId: number
    envId: number
  }

  export type EnvUserUpdateInput = {
    user?: UserUpdateOneRequiredWithoutEnvUsersNestedInput
    environment?: EnvironmentUpdateOneRequiredWithoutEnvUsersNestedInput
  }

  export type EnvUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    envId?: IntFieldUpdateOperationsInput | number
  }

  export type EnvUserCreateManyInput = {
    id?: number
    userId: number
    envId: number
  }

  export type EnvUserUpdateManyMutationInput = {

  }

  export type EnvUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    envId?: IntFieldUpdateOperationsInput | number
  }

  export type ZoneCreateInput = {
    name: string
    type: $Enums.ZoneType
    createdAt?: Date | string
    color: string
    icon: string
    cords: JsonNullValueInput | InputJsonValue
    environment: EnvironmentCreateNestedOneWithoutZonesInput
    pois?: POICreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: number
    envId: number
    name: string
    type: $Enums.ZoneType
    createdAt?: Date | string
    color: string
    icon: string
    cords: JsonNullValueInput | InputJsonValue
    pois?: POIUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    environment?: EnvironmentUpdateOneRequiredWithoutZonesNestedInput
    pois?: POIUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    envId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pois?: POIUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id?: number
    envId: number
    name: string
    type: $Enums.ZoneType
    createdAt?: Date | string
    color: string
    icon: string
    cords: JsonNullValueInput | InputJsonValue
  }

  export type ZoneUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    envId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type POICreateInput = {
    name: string
    category: $Enums.POICategory
    description: string
    location: JsonNullValueInput | InputJsonValue
    zone: ZoneCreateNestedOneWithoutPoisInput
  }

  export type POIUncheckedCreateInput = {
    id?: number
    zoneId: number
    name: string
    category: $Enums.POICategory
    description: string
    location: JsonNullValueInput | InputJsonValue
  }

  export type POIUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumPOICategoryFieldUpdateOperationsInput | $Enums.POICategory
    description?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
    zone?: ZoneUpdateOneRequiredWithoutPoisNestedInput
  }

  export type POIUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumPOICategoryFieldUpdateOperationsInput | $Enums.POICategory
    description?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
  }

  export type POICreateManyInput = {
    id?: number
    zoneId: number
    name: string
    category: $Enums.POICategory
    description: string
    location: JsonNullValueInput | InputJsonValue
  }

  export type POIUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumPOICategoryFieldUpdateOperationsInput | $Enums.POICategory
    description?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
  }

  export type POIUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumPOICategoryFieldUpdateOperationsInput | $Enums.POICategory
    description?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleCreateInput = {
    name: string
    description: string
    cords: JsonNullValueInput | InputJsonValue
    environment: EnvironmentCreateNestedOneWithoutObstaclesInput
  }

  export type ObstacleUncheckedCreateInput = {
    id?: number
    envId: number
    name: string
    description: string
    cords: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    environment?: EnvironmentUpdateOneRequiredWithoutObstaclesNestedInput
  }

  export type ObstacleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    envId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleCreateManyInput = {
    id?: number
    envId: number
    name: string
    description: string
    cords: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    envId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type ItineraryCreateInput = {
    startPoint: JsonNullValueInput | InputJsonValue
    endPoint: JsonNullValueInput | InputJsonValue
    environement: EnvironmentCreateNestedOneWithoutRoutesInput
  }

  export type ItineraryUncheckedCreateInput = {
    id?: number
    startPoint: JsonNullValueInput | InputJsonValue
    endPoint: JsonNullValueInput | InputJsonValue
    envId: number
  }

  export type ItineraryUpdateInput = {
    startPoint?: JsonNullValueInput | InputJsonValue
    endPoint?: JsonNullValueInput | InputJsonValue
    environement?: EnvironmentUpdateOneRequiredWithoutRoutesNestedInput
  }

  export type ItineraryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startPoint?: JsonNullValueInput | InputJsonValue
    endPoint?: JsonNullValueInput | InputJsonValue
    envId?: IntFieldUpdateOperationsInput | number
  }

  export type ItineraryCreateManyInput = {
    id?: number
    startPoint: JsonNullValueInput | InputJsonValue
    endPoint: JsonNullValueInput | InputJsonValue
    envId: number
  }

  export type ItineraryUpdateManyMutationInput = {
    startPoint?: JsonNullValueInput | InputJsonValue
    endPoint?: JsonNullValueInput | InputJsonValue
  }

  export type ItineraryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startPoint?: JsonNullValueInput | InputJsonValue
    endPoint?: JsonNullValueInput | InputJsonValue
    envId?: IntFieldUpdateOperationsInput | number
  }

  export type HelpRequestCreateInput = {
    user: EndUserCreateNestedOneWithoutHelpRequestsInput
    helper: HelperCreateNestedOneWithoutHelpRequestsInput
  }

  export type HelpRequestUncheckedCreateInput = {
    id?: number
    userId: number
    helperId: number
  }

  export type HelpRequestUpdateInput = {
    user?: EndUserUpdateOneRequiredWithoutHelpRequestsNestedInput
    helper?: HelperUpdateOneRequiredWithoutHelpRequestsNestedInput
  }

  export type HelpRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    helperId?: IntFieldUpdateOperationsInput | number
  }

  export type HelpRequestCreateManyInput = {
    id?: number
    userId: number
    helperId: number
  }

  export type HelpRequestUpdateManyMutationInput = {

  }

  export type HelpRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    helperId?: IntFieldUpdateOperationsInput | number
  }

  export type SaleCreateInput = {
    createdAt?: Date | string
    device: DeviceCreateNestedOneWithoutSalesInput
    buyer: EndUserCreateNestedOneWithoutMySalesInput
  }

  export type SaleUncheckedCreateInput = {
    id?: number
    deviceId: number
    buyerId: number
    createdAt?: Date | string
  }

  export type SaleUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutSalesNestedInput
    buyer?: EndUserUpdateOneRequiredWithoutMySalesNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyInput = {
    id?: number
    deviceId: number
    buyerId: number
    createdAt?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionCreateInput = {
    type: $Enums.InterventionType
    isRemote: boolean
    planDate: Date | string
    device: DeviceCreateNestedOneWithoutInterventionsInput
    maintainer: MaintainerCreateNestedOneWithoutInterventionsInput
  }

  export type InterventionUncheckedCreateInput = {
    id?: number
    type: $Enums.InterventionType
    deviceId: number
    maintainerId: number
    isRemote: boolean
    planDate: Date | string
  }

  export type InterventionUpdateInput = {
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutInterventionsNestedInput
    maintainer?: MaintainerUpdateOneRequiredWithoutInterventionsNestedInput
  }

  export type InterventionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    deviceId?: IntFieldUpdateOperationsInput | number
    maintainerId?: IntFieldUpdateOperationsInput | number
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionCreateManyInput = {
    id?: number
    type: $Enums.InterventionType
    deviceId: number
    maintainerId: number
    isRemote: boolean
    planDate: Date | string
  }

  export type InterventionUpdateManyMutationInput = {
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    deviceId?: IntFieldUpdateOperationsInput | number
    maintainerId?: IntFieldUpdateOperationsInput | number
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateInput = {
    createdAt?: Date | string
    details: string
    user: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    details: string
  }

  export type LogUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type LogCreateManyInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    details: string
  }

  export type LogUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type LogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type KPICreateInput = {
    name: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KPIUncheckedCreateInput = {
    id?: number
    name: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KPIUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KPIUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KPICreateManyInput = {
    id?: number
    name: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KPIUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KPIUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type EndUserNullableScalarRelationFilter = {
    is?: EndUserWhereInput | null
    isNot?: EndUserWhereInput | null
  }

  export type HelperNullableScalarRelationFilter = {
    is?: HelperWhereInput | null
    isNot?: HelperWhereInput | null
  }

  export type CommercialNullableScalarRelationFilter = {
    is?: CommercialWhereInput | null
    isNot?: CommercialWhereInput | null
  }

  export type MaintainerNullableScalarRelationFilter = {
    is?: MaintainerWhereInput | null
    isNot?: MaintainerWhereInput | null
  }

  export type DeciderNullableScalarRelationFilter = {
    is?: DeciderWhereInput | null
    isNot?: DeciderWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserDeviceHistoryListRelationFilter = {
    every?: UserDeviceHistoryWhereInput
    some?: UserDeviceHistoryWhereInput
    none?: UserDeviceHistoryWhereInput
  }

  export type EnvUserListRelationFilter = {
    every?: EnvUserWhereInput
    some?: EnvUserWhereInput
    none?: EnvUserWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDeviceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnvUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProfileCountOrderByAggregateInput = {
    userId?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phonenumber?: SortOrder
    address?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    userId?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phonenumber?: SortOrder
    address?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    userId?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phonenumber?: SortOrder
    address?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type HelpRequestListRelationFilter = {
    every?: HelpRequestWhereInput
    some?: HelpRequestWhereInput
    none?: HelpRequestWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelpRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EndUserCountOrderByAggregateInput = {
    id?: SortOrder
    helperId?: SortOrder
    lastPos?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EndUserAvgOrderByAggregateInput = {
    id?: SortOrder
    helperId?: SortOrder
    userId?: SortOrder
  }

  export type EndUserMaxOrderByAggregateInput = {
    id?: SortOrder
    helperId?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EndUserMinOrderByAggregateInput = {
    id?: SortOrder
    helperId?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EndUserSumOrderByAggregateInput = {
    id?: SortOrder
    helperId?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EndUserListRelationFilter = {
    every?: EndUserWhereInput
    some?: EndUserWhereInput
    none?: EndUserWhereInput
  }

  export type EndUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelperCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HelperAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HelperMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HelperMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HelperSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CommercialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CommercialAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CommercialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CommercialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CommercialSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type InterventionListRelationFilter = {
    every?: InterventionWhereInput
    some?: InterventionWhereInput
    none?: InterventionWhereInput
  }

  export type InterventionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintainerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MaintainerAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MaintainerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MaintainerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MaintainerSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DeciderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DeciderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DeciderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DeciderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DeciderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusFilter<$PrismaModel> | $Enums.DeviceStatus
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    version?: SortOrder
    macAdr?: SortOrder
    status?: SortOrder
    battery?: SortOrder
    lastPos?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    id?: SortOrder
    battery?: SortOrder
    price?: SortOrder
    userId?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    version?: SortOrder
    macAdr?: SortOrder
    status?: SortOrder
    battery?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    version?: SortOrder
    macAdr?: SortOrder
    status?: SortOrder
    battery?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    id?: SortOrder
    battery?: SortOrder
    price?: SortOrder
    userId?: SortOrder
  }

  export type EnumDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DeviceScalarRelationFilter = {
    is?: DeviceWhereInput
    isNot?: DeviceWhereInput
  }

  export type UserDeviceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    useDate?: SortOrder
  }

  export type UserDeviceHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
  }

  export type UserDeviceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    useDate?: SortOrder
  }

  export type UserDeviceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
    useDate?: SortOrder
  }

  export type UserDeviceHistorySumOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    userId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ZoneListRelationFilter = {
    every?: ZoneWhereInput
    some?: ZoneWhereInput
    none?: ZoneWhereInput
  }

  export type ObstacleListRelationFilter = {
    every?: ObstacleWhereInput
    some?: ObstacleWhereInput
    none?: ObstacleWhereInput
  }

  export type ItineraryListRelationFilter = {
    every?: ItineraryWhereInput
    some?: ItineraryWhereInput
    none?: ItineraryWhereInput
  }

  export type ZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObstacleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItineraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnvironmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    cords?: SortOrder
    pathCartographie?: SortOrder
    createdAt?: SortOrder
    scale?: SortOrder
  }

  export type EnvironmentAvgOrderByAggregateInput = {
    id?: SortOrder
    scale?: SortOrder
  }

  export type EnvironmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pathCartographie?: SortOrder
    createdAt?: SortOrder
    scale?: SortOrder
  }

  export type EnvironmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pathCartographie?: SortOrder
    createdAt?: SortOrder
    scale?: SortOrder
  }

  export type EnvironmentSumOrderByAggregateInput = {
    id?: SortOrder
    scale?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnvironmentScalarRelationFilter = {
    is?: EnvironmentWhereInput
    isNot?: EnvironmentWhereInput
  }

  export type EnvUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    envId?: SortOrder
  }

  export type EnvUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    envId?: SortOrder
  }

  export type EnvUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    envId?: SortOrder
  }

  export type EnvUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    envId?: SortOrder
  }

  export type EnvUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    envId?: SortOrder
  }

  export type EnumZoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeFilter<$PrismaModel> | $Enums.ZoneType
  }

  export type POIListRelationFilter = {
    every?: POIWhereInput
    some?: POIWhereInput
    none?: POIWhereInput
  }

  export type POIOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    cords?: SortOrder
  }

  export type ZoneAvgOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    color?: SortOrder
    icon?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    color?: SortOrder
    icon?: SortOrder
  }

  export type ZoneSumOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
  }

  export type EnumZoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZoneTypeFilter<$PrismaModel>
    _max?: NestedEnumZoneTypeFilter<$PrismaModel>
  }

  export type EnumPOICategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.POICategory | EnumPOICategoryFieldRefInput<$PrismaModel>
    in?: $Enums.POICategory[] | ListEnumPOICategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.POICategory[] | ListEnumPOICategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPOICategoryFilter<$PrismaModel> | $Enums.POICategory
  }

  export type ZoneScalarRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type POICountOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    location?: SortOrder
  }

  export type POIAvgOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
  }

  export type POIMaxOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
  }

  export type POIMinOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
  }

  export type POISumOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
  }

  export type EnumPOICategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POICategory | EnumPOICategoryFieldRefInput<$PrismaModel>
    in?: $Enums.POICategory[] | ListEnumPOICategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.POICategory[] | ListEnumPOICategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPOICategoryWithAggregatesFilter<$PrismaModel> | $Enums.POICategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOICategoryFilter<$PrismaModel>
    _max?: NestedEnumPOICategoryFilter<$PrismaModel>
  }

  export type ObstacleCountOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cords?: SortOrder
  }

  export type ObstacleAvgOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
  }

  export type ObstacleMaxOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ObstacleMinOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ObstacleSumOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
  }

  export type ItineraryCountOrderByAggregateInput = {
    id?: SortOrder
    startPoint?: SortOrder
    endPoint?: SortOrder
    envId?: SortOrder
  }

  export type ItineraryAvgOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
  }

  export type ItineraryMaxOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
  }

  export type ItineraryMinOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
  }

  export type ItinerarySumOrderByAggregateInput = {
    id?: SortOrder
    envId?: SortOrder
  }

  export type EndUserScalarRelationFilter = {
    is?: EndUserWhereInput
    isNot?: EndUserWhereInput
  }

  export type HelperScalarRelationFilter = {
    is?: HelperWhereInput
    isNot?: HelperWhereInput
  }

  export type HelpRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    helperId?: SortOrder
  }

  export type HelpRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    helperId?: SortOrder
  }

  export type HelpRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    helperId?: SortOrder
  }

  export type HelpRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    helperId?: SortOrder
  }

  export type HelpRequestSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    helperId?: SortOrder
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    buyerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    buyerId?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    buyerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    buyerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    buyerId?: SortOrder
  }

  export type EnumInterventionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionType | EnumInterventionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionTypeFilter<$PrismaModel> | $Enums.InterventionType
  }

  export type MaintainerScalarRelationFilter = {
    is?: MaintainerWhereInput
    isNot?: MaintainerWhereInput
  }

  export type InterventionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    maintainerId?: SortOrder
    isRemote?: SortOrder
    planDate?: SortOrder
  }

  export type InterventionAvgOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    maintainerId?: SortOrder
  }

  export type InterventionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    maintainerId?: SortOrder
    isRemote?: SortOrder
    planDate?: SortOrder
  }

  export type InterventionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    deviceId?: SortOrder
    maintainerId?: SortOrder
    isRemote?: SortOrder
    planDate?: SortOrder
  }

  export type InterventionSumOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    maintainerId?: SortOrder
  }

  export type EnumInterventionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionType | EnumInterventionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InterventionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionTypeFilter<$PrismaModel>
    _max?: NestedEnumInterventionTypeFilter<$PrismaModel>
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    details?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    details?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    details?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type KPICountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KPIAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KPIMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KPIMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KPISumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type EndUserCreateNestedOneWithoutUserInput = {
    create?: XOR<EndUserCreateWithoutUserInput, EndUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutUserInput
    connect?: EndUserWhereUniqueInput
  }

  export type HelperCreateNestedOneWithoutUserInput = {
    create?: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput>
    connectOrCreate?: HelperCreateOrConnectWithoutUserInput
    connect?: HelperWhereUniqueInput
  }

  export type CommercialCreateNestedOneWithoutUserInput = {
    create?: XOR<CommercialCreateWithoutUserInput, CommercialUncheckedCreateWithoutUserInput>
    connectOrCreate?: CommercialCreateOrConnectWithoutUserInput
    connect?: CommercialWhereUniqueInput
  }

  export type MaintainerCreateNestedOneWithoutUserInput = {
    create?: XOR<MaintainerCreateWithoutUserInput, MaintainerUncheckedCreateWithoutUserInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutUserInput
    connect?: MaintainerWhereUniqueInput
  }

  export type DeciderCreateNestedOneWithoutUserInput = {
    create?: XOR<DeciderCreateWithoutUserInput, DeciderUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeciderCreateOrConnectWithoutUserInput
    connect?: DeciderWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserDeviceHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDeviceHistoryCreateWithoutUserInput, UserDeviceHistoryUncheckedCreateWithoutUserInput> | UserDeviceHistoryCreateWithoutUserInput[] | UserDeviceHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceHistoryCreateOrConnectWithoutUserInput | UserDeviceHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserDeviceHistoryCreateManyUserInputEnvelope
    connect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
  }

  export type EnvUserCreateNestedManyWithoutUserInput = {
    create?: XOR<EnvUserCreateWithoutUserInput, EnvUserUncheckedCreateWithoutUserInput> | EnvUserCreateWithoutUserInput[] | EnvUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnvUserCreateOrConnectWithoutUserInput | EnvUserCreateOrConnectWithoutUserInput[]
    createMany?: EnvUserCreateManyUserInputEnvelope
    connect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type EndUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EndUserCreateWithoutUserInput, EndUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutUserInput
    connect?: EndUserWhereUniqueInput
  }

  export type HelperUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput>
    connectOrCreate?: HelperCreateOrConnectWithoutUserInput
    connect?: HelperWhereUniqueInput
  }

  export type CommercialUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CommercialCreateWithoutUserInput, CommercialUncheckedCreateWithoutUserInput>
    connectOrCreate?: CommercialCreateOrConnectWithoutUserInput
    connect?: CommercialWhereUniqueInput
  }

  export type MaintainerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MaintainerCreateWithoutUserInput, MaintainerUncheckedCreateWithoutUserInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutUserInput
    connect?: MaintainerWhereUniqueInput
  }

  export type DeciderUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DeciderCreateWithoutUserInput, DeciderUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeciderCreateOrConnectWithoutUserInput
    connect?: DeciderWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDeviceHistoryCreateWithoutUserInput, UserDeviceHistoryUncheckedCreateWithoutUserInput> | UserDeviceHistoryCreateWithoutUserInput[] | UserDeviceHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceHistoryCreateOrConnectWithoutUserInput | UserDeviceHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserDeviceHistoryCreateManyUserInputEnvelope
    connect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
  }

  export type EnvUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EnvUserCreateWithoutUserInput, EnvUserUncheckedCreateWithoutUserInput> | EnvUserCreateWithoutUserInput[] | EnvUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnvUserCreateOrConnectWithoutUserInput | EnvUserCreateOrConnectWithoutUserInput[]
    createMany?: EnvUserCreateManyUserInputEnvelope
    connect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type EndUserUpdateOneWithoutUserNestedInput = {
    create?: XOR<EndUserCreateWithoutUserInput, EndUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutUserInput
    upsert?: EndUserUpsertWithoutUserInput
    disconnect?: EndUserWhereInput | boolean
    delete?: EndUserWhereInput | boolean
    connect?: EndUserWhereUniqueInput
    update?: XOR<XOR<EndUserUpdateToOneWithWhereWithoutUserInput, EndUserUpdateWithoutUserInput>, EndUserUncheckedUpdateWithoutUserInput>
  }

  export type HelperUpdateOneWithoutUserNestedInput = {
    create?: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput>
    connectOrCreate?: HelperCreateOrConnectWithoutUserInput
    upsert?: HelperUpsertWithoutUserInput
    disconnect?: HelperWhereInput | boolean
    delete?: HelperWhereInput | boolean
    connect?: HelperWhereUniqueInput
    update?: XOR<XOR<HelperUpdateToOneWithWhereWithoutUserInput, HelperUpdateWithoutUserInput>, HelperUncheckedUpdateWithoutUserInput>
  }

  export type CommercialUpdateOneWithoutUserNestedInput = {
    create?: XOR<CommercialCreateWithoutUserInput, CommercialUncheckedCreateWithoutUserInput>
    connectOrCreate?: CommercialCreateOrConnectWithoutUserInput
    upsert?: CommercialUpsertWithoutUserInput
    disconnect?: CommercialWhereInput | boolean
    delete?: CommercialWhereInput | boolean
    connect?: CommercialWhereUniqueInput
    update?: XOR<XOR<CommercialUpdateToOneWithWhereWithoutUserInput, CommercialUpdateWithoutUserInput>, CommercialUncheckedUpdateWithoutUserInput>
  }

  export type MaintainerUpdateOneWithoutUserNestedInput = {
    create?: XOR<MaintainerCreateWithoutUserInput, MaintainerUncheckedCreateWithoutUserInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutUserInput
    upsert?: MaintainerUpsertWithoutUserInput
    disconnect?: MaintainerWhereInput | boolean
    delete?: MaintainerWhereInput | boolean
    connect?: MaintainerWhereUniqueInput
    update?: XOR<XOR<MaintainerUpdateToOneWithWhereWithoutUserInput, MaintainerUpdateWithoutUserInput>, MaintainerUncheckedUpdateWithoutUserInput>
  }

  export type DeciderUpdateOneWithoutUserNestedInput = {
    create?: XOR<DeciderCreateWithoutUserInput, DeciderUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeciderCreateOrConnectWithoutUserInput
    upsert?: DeciderUpsertWithoutUserInput
    disconnect?: DeciderWhereInput | boolean
    delete?: DeciderWhereInput | boolean
    connect?: DeciderWhereUniqueInput
    update?: XOR<XOR<DeciderUpdateToOneWithWhereWithoutUserInput, DeciderUpdateWithoutUserInput>, DeciderUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserDeviceHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDeviceHistoryCreateWithoutUserInput, UserDeviceHistoryUncheckedCreateWithoutUserInput> | UserDeviceHistoryCreateWithoutUserInput[] | UserDeviceHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceHistoryCreateOrConnectWithoutUserInput | UserDeviceHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserDeviceHistoryUpsertWithWhereUniqueWithoutUserInput | UserDeviceHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDeviceHistoryCreateManyUserInputEnvelope
    set?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    disconnect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    delete?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    connect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    update?: UserDeviceHistoryUpdateWithWhereUniqueWithoutUserInput | UserDeviceHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDeviceHistoryUpdateManyWithWhereWithoutUserInput | UserDeviceHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDeviceHistoryScalarWhereInput | UserDeviceHistoryScalarWhereInput[]
  }

  export type EnvUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnvUserCreateWithoutUserInput, EnvUserUncheckedCreateWithoutUserInput> | EnvUserCreateWithoutUserInput[] | EnvUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnvUserCreateOrConnectWithoutUserInput | EnvUserCreateOrConnectWithoutUserInput[]
    upsert?: EnvUserUpsertWithWhereUniqueWithoutUserInput | EnvUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnvUserCreateManyUserInputEnvelope
    set?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    disconnect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    delete?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    connect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    update?: EnvUserUpdateWithWhereUniqueWithoutUserInput | EnvUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnvUserUpdateManyWithWhereWithoutUserInput | EnvUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnvUserScalarWhereInput | EnvUserScalarWhereInput[]
  }

  export type LogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type EndUserUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EndUserCreateWithoutUserInput, EndUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutUserInput
    upsert?: EndUserUpsertWithoutUserInput
    disconnect?: EndUserWhereInput | boolean
    delete?: EndUserWhereInput | boolean
    connect?: EndUserWhereUniqueInput
    update?: XOR<XOR<EndUserUpdateToOneWithWhereWithoutUserInput, EndUserUpdateWithoutUserInput>, EndUserUncheckedUpdateWithoutUserInput>
  }

  export type HelperUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput>
    connectOrCreate?: HelperCreateOrConnectWithoutUserInput
    upsert?: HelperUpsertWithoutUserInput
    disconnect?: HelperWhereInput | boolean
    delete?: HelperWhereInput | boolean
    connect?: HelperWhereUniqueInput
    update?: XOR<XOR<HelperUpdateToOneWithWhereWithoutUserInput, HelperUpdateWithoutUserInput>, HelperUncheckedUpdateWithoutUserInput>
  }

  export type CommercialUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CommercialCreateWithoutUserInput, CommercialUncheckedCreateWithoutUserInput>
    connectOrCreate?: CommercialCreateOrConnectWithoutUserInput
    upsert?: CommercialUpsertWithoutUserInput
    disconnect?: CommercialWhereInput | boolean
    delete?: CommercialWhereInput | boolean
    connect?: CommercialWhereUniqueInput
    update?: XOR<XOR<CommercialUpdateToOneWithWhereWithoutUserInput, CommercialUpdateWithoutUserInput>, CommercialUncheckedUpdateWithoutUserInput>
  }

  export type MaintainerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MaintainerCreateWithoutUserInput, MaintainerUncheckedCreateWithoutUserInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutUserInput
    upsert?: MaintainerUpsertWithoutUserInput
    disconnect?: MaintainerWhereInput | boolean
    delete?: MaintainerWhereInput | boolean
    connect?: MaintainerWhereUniqueInput
    update?: XOR<XOR<MaintainerUpdateToOneWithWhereWithoutUserInput, MaintainerUpdateWithoutUserInput>, MaintainerUncheckedUpdateWithoutUserInput>
  }

  export type DeciderUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DeciderCreateWithoutUserInput, DeciderUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeciderCreateOrConnectWithoutUserInput
    upsert?: DeciderUpsertWithoutUserInput
    disconnect?: DeciderWhereInput | boolean
    delete?: DeciderWhereInput | boolean
    connect?: DeciderWhereUniqueInput
    update?: XOR<XOR<DeciderUpdateToOneWithWhereWithoutUserInput, DeciderUpdateWithoutUserInput>, DeciderUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDeviceHistoryCreateWithoutUserInput, UserDeviceHistoryUncheckedCreateWithoutUserInput> | UserDeviceHistoryCreateWithoutUserInput[] | UserDeviceHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceHistoryCreateOrConnectWithoutUserInput | UserDeviceHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserDeviceHistoryUpsertWithWhereUniqueWithoutUserInput | UserDeviceHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDeviceHistoryCreateManyUserInputEnvelope
    set?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    disconnect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    delete?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    connect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    update?: UserDeviceHistoryUpdateWithWhereUniqueWithoutUserInput | UserDeviceHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDeviceHistoryUpdateManyWithWhereWithoutUserInput | UserDeviceHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDeviceHistoryScalarWhereInput | UserDeviceHistoryScalarWhereInput[]
  }

  export type EnvUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnvUserCreateWithoutUserInput, EnvUserUncheckedCreateWithoutUserInput> | EnvUserCreateWithoutUserInput[] | EnvUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnvUserCreateOrConnectWithoutUserInput | EnvUserCreateOrConnectWithoutUserInput[]
    upsert?: EnvUserUpsertWithWhereUniqueWithoutUserInput | EnvUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnvUserCreateManyUserInputEnvelope
    set?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    disconnect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    delete?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    connect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    update?: EnvUserUpdateWithWhereUniqueWithoutUserInput | EnvUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnvUserUpdateManyWithWhereWithoutUserInput | EnvUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnvUserScalarWhereInput | EnvUserScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserCreateNestedOneWithoutEndUserInput = {
    create?: XOR<UserCreateWithoutEndUserInput, UserUncheckedCreateWithoutEndUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutEndUserInput
    connect?: UserWhereUniqueInput
  }

  export type HelperCreateNestedOneWithoutEndUsersInput = {
    create?: XOR<HelperCreateWithoutEndUsersInput, HelperUncheckedCreateWithoutEndUsersInput>
    connectOrCreate?: HelperCreateOrConnectWithoutEndUsersInput
    connect?: HelperWhereUniqueInput
  }

  export type DeviceCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type HelpRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<HelpRequestCreateWithoutUserInput, HelpRequestUncheckedCreateWithoutUserInput> | HelpRequestCreateWithoutUserInput[] | HelpRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelpRequestCreateOrConnectWithoutUserInput | HelpRequestCreateOrConnectWithoutUserInput[]
    createMany?: HelpRequestCreateManyUserInputEnvelope
    connect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutBuyerInput = {
    create?: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput> | SaleCreateWithoutBuyerInput[] | SaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutBuyerInput | SaleCreateOrConnectWithoutBuyerInput[]
    createMany?: SaleCreateManyBuyerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type HelpRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HelpRequestCreateWithoutUserInput, HelpRequestUncheckedCreateWithoutUserInput> | HelpRequestCreateWithoutUserInput[] | HelpRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelpRequestCreateOrConnectWithoutUserInput | HelpRequestCreateOrConnectWithoutUserInput[]
    createMany?: HelpRequestCreateManyUserInputEnvelope
    connect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput> | SaleCreateWithoutBuyerInput[] | SaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutBuyerInput | SaleCreateOrConnectWithoutBuyerInput[]
    createMany?: SaleCreateManyBuyerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutEndUserNestedInput = {
    create?: XOR<UserCreateWithoutEndUserInput, UserUncheckedCreateWithoutEndUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutEndUserInput
    upsert?: UserUpsertWithoutEndUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEndUserInput, UserUpdateWithoutEndUserInput>, UserUncheckedUpdateWithoutEndUserInput>
  }

  export type HelperUpdateOneWithoutEndUsersNestedInput = {
    create?: XOR<HelperCreateWithoutEndUsersInput, HelperUncheckedCreateWithoutEndUsersInput>
    connectOrCreate?: HelperCreateOrConnectWithoutEndUsersInput
    upsert?: HelperUpsertWithoutEndUsersInput
    disconnect?: HelperWhereInput | boolean
    delete?: HelperWhereInput | boolean
    connect?: HelperWhereUniqueInput
    update?: XOR<XOR<HelperUpdateToOneWithWhereWithoutEndUsersInput, HelperUpdateWithoutEndUsersInput>, HelperUncheckedUpdateWithoutEndUsersInput>
  }

  export type DeviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutUserInput | DeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutUserInput | DeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutUserInput | DeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type HelpRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<HelpRequestCreateWithoutUserInput, HelpRequestUncheckedCreateWithoutUserInput> | HelpRequestCreateWithoutUserInput[] | HelpRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelpRequestCreateOrConnectWithoutUserInput | HelpRequestCreateOrConnectWithoutUserInput[]
    upsert?: HelpRequestUpsertWithWhereUniqueWithoutUserInput | HelpRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HelpRequestCreateManyUserInputEnvelope
    set?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    disconnect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    delete?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    connect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    update?: HelpRequestUpdateWithWhereUniqueWithoutUserInput | HelpRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HelpRequestUpdateManyWithWhereWithoutUserInput | HelpRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HelpRequestScalarWhereInput | HelpRequestScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput> | SaleCreateWithoutBuyerInput[] | SaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutBuyerInput | SaleCreateOrConnectWithoutBuyerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutBuyerInput | SaleUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: SaleCreateManyBuyerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutBuyerInput | SaleUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutBuyerInput | SaleUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DeviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutUserInput | DeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutUserInput | DeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutUserInput | DeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type HelpRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HelpRequestCreateWithoutUserInput, HelpRequestUncheckedCreateWithoutUserInput> | HelpRequestCreateWithoutUserInput[] | HelpRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HelpRequestCreateOrConnectWithoutUserInput | HelpRequestCreateOrConnectWithoutUserInput[]
    upsert?: HelpRequestUpsertWithWhereUniqueWithoutUserInput | HelpRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HelpRequestCreateManyUserInputEnvelope
    set?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    disconnect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    delete?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    connect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    update?: HelpRequestUpdateWithWhereUniqueWithoutUserInput | HelpRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HelpRequestUpdateManyWithWhereWithoutUserInput | HelpRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HelpRequestScalarWhereInput | HelpRequestScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput> | SaleCreateWithoutBuyerInput[] | SaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutBuyerInput | SaleCreateOrConnectWithoutBuyerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutBuyerInput | SaleUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: SaleCreateManyBuyerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutBuyerInput | SaleUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutBuyerInput | SaleUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHelperInput = {
    create?: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelperInput
    connect?: UserWhereUniqueInput
  }

  export type EndUserCreateNestedManyWithoutHelperInput = {
    create?: XOR<EndUserCreateWithoutHelperInput, EndUserUncheckedCreateWithoutHelperInput> | EndUserCreateWithoutHelperInput[] | EndUserUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: EndUserCreateOrConnectWithoutHelperInput | EndUserCreateOrConnectWithoutHelperInput[]
    createMany?: EndUserCreateManyHelperInputEnvelope
    connect?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
  }

  export type HelpRequestCreateNestedManyWithoutHelperInput = {
    create?: XOR<HelpRequestCreateWithoutHelperInput, HelpRequestUncheckedCreateWithoutHelperInput> | HelpRequestCreateWithoutHelperInput[] | HelpRequestUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: HelpRequestCreateOrConnectWithoutHelperInput | HelpRequestCreateOrConnectWithoutHelperInput[]
    createMany?: HelpRequestCreateManyHelperInputEnvelope
    connect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
  }

  export type EndUserUncheckedCreateNestedManyWithoutHelperInput = {
    create?: XOR<EndUserCreateWithoutHelperInput, EndUserUncheckedCreateWithoutHelperInput> | EndUserCreateWithoutHelperInput[] | EndUserUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: EndUserCreateOrConnectWithoutHelperInput | EndUserCreateOrConnectWithoutHelperInput[]
    createMany?: EndUserCreateManyHelperInputEnvelope
    connect?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
  }

  export type HelpRequestUncheckedCreateNestedManyWithoutHelperInput = {
    create?: XOR<HelpRequestCreateWithoutHelperInput, HelpRequestUncheckedCreateWithoutHelperInput> | HelpRequestCreateWithoutHelperInput[] | HelpRequestUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: HelpRequestCreateOrConnectWithoutHelperInput | HelpRequestCreateOrConnectWithoutHelperInput[]
    createMany?: HelpRequestCreateManyHelperInputEnvelope
    connect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutHelperNestedInput = {
    create?: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
    connectOrCreate?: UserCreateOrConnectWithoutHelperInput
    upsert?: UserUpsertWithoutHelperInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHelperInput, UserUpdateWithoutHelperInput>, UserUncheckedUpdateWithoutHelperInput>
  }

  export type EndUserUpdateManyWithoutHelperNestedInput = {
    create?: XOR<EndUserCreateWithoutHelperInput, EndUserUncheckedCreateWithoutHelperInput> | EndUserCreateWithoutHelperInput[] | EndUserUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: EndUserCreateOrConnectWithoutHelperInput | EndUserCreateOrConnectWithoutHelperInput[]
    upsert?: EndUserUpsertWithWhereUniqueWithoutHelperInput | EndUserUpsertWithWhereUniqueWithoutHelperInput[]
    createMany?: EndUserCreateManyHelperInputEnvelope
    set?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
    disconnect?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
    delete?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
    connect?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
    update?: EndUserUpdateWithWhereUniqueWithoutHelperInput | EndUserUpdateWithWhereUniqueWithoutHelperInput[]
    updateMany?: EndUserUpdateManyWithWhereWithoutHelperInput | EndUserUpdateManyWithWhereWithoutHelperInput[]
    deleteMany?: EndUserScalarWhereInput | EndUserScalarWhereInput[]
  }

  export type HelpRequestUpdateManyWithoutHelperNestedInput = {
    create?: XOR<HelpRequestCreateWithoutHelperInput, HelpRequestUncheckedCreateWithoutHelperInput> | HelpRequestCreateWithoutHelperInput[] | HelpRequestUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: HelpRequestCreateOrConnectWithoutHelperInput | HelpRequestCreateOrConnectWithoutHelperInput[]
    upsert?: HelpRequestUpsertWithWhereUniqueWithoutHelperInput | HelpRequestUpsertWithWhereUniqueWithoutHelperInput[]
    createMany?: HelpRequestCreateManyHelperInputEnvelope
    set?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    disconnect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    delete?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    connect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    update?: HelpRequestUpdateWithWhereUniqueWithoutHelperInput | HelpRequestUpdateWithWhereUniqueWithoutHelperInput[]
    updateMany?: HelpRequestUpdateManyWithWhereWithoutHelperInput | HelpRequestUpdateManyWithWhereWithoutHelperInput[]
    deleteMany?: HelpRequestScalarWhereInput | HelpRequestScalarWhereInput[]
  }

  export type EndUserUncheckedUpdateManyWithoutHelperNestedInput = {
    create?: XOR<EndUserCreateWithoutHelperInput, EndUserUncheckedCreateWithoutHelperInput> | EndUserCreateWithoutHelperInput[] | EndUserUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: EndUserCreateOrConnectWithoutHelperInput | EndUserCreateOrConnectWithoutHelperInput[]
    upsert?: EndUserUpsertWithWhereUniqueWithoutHelperInput | EndUserUpsertWithWhereUniqueWithoutHelperInput[]
    createMany?: EndUserCreateManyHelperInputEnvelope
    set?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
    disconnect?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
    delete?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
    connect?: EndUserWhereUniqueInput | EndUserWhereUniqueInput[]
    update?: EndUserUpdateWithWhereUniqueWithoutHelperInput | EndUserUpdateWithWhereUniqueWithoutHelperInput[]
    updateMany?: EndUserUpdateManyWithWhereWithoutHelperInput | EndUserUpdateManyWithWhereWithoutHelperInput[]
    deleteMany?: EndUserScalarWhereInput | EndUserScalarWhereInput[]
  }

  export type HelpRequestUncheckedUpdateManyWithoutHelperNestedInput = {
    create?: XOR<HelpRequestCreateWithoutHelperInput, HelpRequestUncheckedCreateWithoutHelperInput> | HelpRequestCreateWithoutHelperInput[] | HelpRequestUncheckedCreateWithoutHelperInput[]
    connectOrCreate?: HelpRequestCreateOrConnectWithoutHelperInput | HelpRequestCreateOrConnectWithoutHelperInput[]
    upsert?: HelpRequestUpsertWithWhereUniqueWithoutHelperInput | HelpRequestUpsertWithWhereUniqueWithoutHelperInput[]
    createMany?: HelpRequestCreateManyHelperInputEnvelope
    set?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    disconnect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    delete?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    connect?: HelpRequestWhereUniqueInput | HelpRequestWhereUniqueInput[]
    update?: HelpRequestUpdateWithWhereUniqueWithoutHelperInput | HelpRequestUpdateWithWhereUniqueWithoutHelperInput[]
    updateMany?: HelpRequestUpdateManyWithWhereWithoutHelperInput | HelpRequestUpdateManyWithWhereWithoutHelperInput[]
    deleteMany?: HelpRequestScalarWhereInput | HelpRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCommercialInput = {
    create?: XOR<UserCreateWithoutCommercialInput, UserUncheckedCreateWithoutCommercialInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommercialInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommercialNestedInput = {
    create?: XOR<UserCreateWithoutCommercialInput, UserUncheckedCreateWithoutCommercialInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommercialInput
    upsert?: UserUpsertWithoutCommercialInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommercialInput, UserUpdateWithoutCommercialInput>, UserUncheckedUpdateWithoutCommercialInput>
  }

  export type UserCreateNestedOneWithoutMaintainerInput = {
    create?: XOR<UserCreateWithoutMaintainerInput, UserUncheckedCreateWithoutMaintainerInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaintainerInput
    connect?: UserWhereUniqueInput
  }

  export type InterventionCreateNestedManyWithoutMaintainerInput = {
    create?: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput> | InterventionCreateWithoutMaintainerInput[] | InterventionUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMaintainerInput | InterventionCreateOrConnectWithoutMaintainerInput[]
    createMany?: InterventionCreateManyMaintainerInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type InterventionUncheckedCreateNestedManyWithoutMaintainerInput = {
    create?: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput> | InterventionCreateWithoutMaintainerInput[] | InterventionUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMaintainerInput | InterventionCreateOrConnectWithoutMaintainerInput[]
    createMany?: InterventionCreateManyMaintainerInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMaintainerNestedInput = {
    create?: XOR<UserCreateWithoutMaintainerInput, UserUncheckedCreateWithoutMaintainerInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaintainerInput
    upsert?: UserUpsertWithoutMaintainerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMaintainerInput, UserUpdateWithoutMaintainerInput>, UserUncheckedUpdateWithoutMaintainerInput>
  }

  export type InterventionUpdateManyWithoutMaintainerNestedInput = {
    create?: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput> | InterventionCreateWithoutMaintainerInput[] | InterventionUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMaintainerInput | InterventionCreateOrConnectWithoutMaintainerInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutMaintainerInput | InterventionUpsertWithWhereUniqueWithoutMaintainerInput[]
    createMany?: InterventionCreateManyMaintainerInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutMaintainerInput | InterventionUpdateWithWhereUniqueWithoutMaintainerInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutMaintainerInput | InterventionUpdateManyWithWhereWithoutMaintainerInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type InterventionUncheckedUpdateManyWithoutMaintainerNestedInput = {
    create?: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput> | InterventionCreateWithoutMaintainerInput[] | InterventionUncheckedCreateWithoutMaintainerInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutMaintainerInput | InterventionCreateOrConnectWithoutMaintainerInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutMaintainerInput | InterventionUpsertWithWhereUniqueWithoutMaintainerInput[]
    createMany?: InterventionCreateManyMaintainerInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutMaintainerInput | InterventionUpdateWithWhereUniqueWithoutMaintainerInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutMaintainerInput | InterventionUpdateManyWithWhereWithoutMaintainerInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDeciderInput = {
    create?: XOR<UserCreateWithoutDeciderInput, UserUncheckedCreateWithoutDeciderInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeciderInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeciderNestedInput = {
    create?: XOR<UserCreateWithoutDeciderInput, UserUncheckedCreateWithoutDeciderInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeciderInput
    upsert?: UserUpsertWithoutDeciderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeciderInput, UserUpdateWithoutDeciderInput>, UserUncheckedUpdateWithoutDeciderInput>
  }

  export type EndUserCreateNestedOneWithoutDevicesInput = {
    create?: XOR<EndUserCreateWithoutDevicesInput, EndUserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutDevicesInput
    connect?: EndUserWhereUniqueInput
  }

  export type SaleCreateNestedManyWithoutDeviceInput = {
    create?: XOR<SaleCreateWithoutDeviceInput, SaleUncheckedCreateWithoutDeviceInput> | SaleCreateWithoutDeviceInput[] | SaleUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutDeviceInput | SaleCreateOrConnectWithoutDeviceInput[]
    createMany?: SaleCreateManyDeviceInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type UserDeviceHistoryCreateNestedManyWithoutDeviceInput = {
    create?: XOR<UserDeviceHistoryCreateWithoutDeviceInput, UserDeviceHistoryUncheckedCreateWithoutDeviceInput> | UserDeviceHistoryCreateWithoutDeviceInput[] | UserDeviceHistoryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserDeviceHistoryCreateOrConnectWithoutDeviceInput | UserDeviceHistoryCreateOrConnectWithoutDeviceInput[]
    createMany?: UserDeviceHistoryCreateManyDeviceInputEnvelope
    connect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
  }

  export type InterventionCreateNestedManyWithoutDeviceInput = {
    create?: XOR<InterventionCreateWithoutDeviceInput, InterventionUncheckedCreateWithoutDeviceInput> | InterventionCreateWithoutDeviceInput[] | InterventionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutDeviceInput | InterventionCreateOrConnectWithoutDeviceInput[]
    createMany?: InterventionCreateManyDeviceInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<SaleCreateWithoutDeviceInput, SaleUncheckedCreateWithoutDeviceInput> | SaleCreateWithoutDeviceInput[] | SaleUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutDeviceInput | SaleCreateOrConnectWithoutDeviceInput[]
    createMany?: SaleCreateManyDeviceInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type UserDeviceHistoryUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<UserDeviceHistoryCreateWithoutDeviceInput, UserDeviceHistoryUncheckedCreateWithoutDeviceInput> | UserDeviceHistoryCreateWithoutDeviceInput[] | UserDeviceHistoryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserDeviceHistoryCreateOrConnectWithoutDeviceInput | UserDeviceHistoryCreateOrConnectWithoutDeviceInput[]
    createMany?: UserDeviceHistoryCreateManyDeviceInputEnvelope
    connect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
  }

  export type InterventionUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<InterventionCreateWithoutDeviceInput, InterventionUncheckedCreateWithoutDeviceInput> | InterventionCreateWithoutDeviceInput[] | InterventionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutDeviceInput | InterventionCreateOrConnectWithoutDeviceInput[]
    createMany?: InterventionCreateManyDeviceInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type EnumDeviceStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeviceStatus
  }

  export type EndUserUpdateOneWithoutDevicesNestedInput = {
    create?: XOR<EndUserCreateWithoutDevicesInput, EndUserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutDevicesInput
    upsert?: EndUserUpsertWithoutDevicesInput
    disconnect?: EndUserWhereInput | boolean
    delete?: EndUserWhereInput | boolean
    connect?: EndUserWhereUniqueInput
    update?: XOR<XOR<EndUserUpdateToOneWithWhereWithoutDevicesInput, EndUserUpdateWithoutDevicesInput>, EndUserUncheckedUpdateWithoutDevicesInput>
  }

  export type SaleUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<SaleCreateWithoutDeviceInput, SaleUncheckedCreateWithoutDeviceInput> | SaleCreateWithoutDeviceInput[] | SaleUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutDeviceInput | SaleCreateOrConnectWithoutDeviceInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutDeviceInput | SaleUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: SaleCreateManyDeviceInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutDeviceInput | SaleUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutDeviceInput | SaleUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type UserDeviceHistoryUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<UserDeviceHistoryCreateWithoutDeviceInput, UserDeviceHistoryUncheckedCreateWithoutDeviceInput> | UserDeviceHistoryCreateWithoutDeviceInput[] | UserDeviceHistoryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserDeviceHistoryCreateOrConnectWithoutDeviceInput | UserDeviceHistoryCreateOrConnectWithoutDeviceInput[]
    upsert?: UserDeviceHistoryUpsertWithWhereUniqueWithoutDeviceInput | UserDeviceHistoryUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: UserDeviceHistoryCreateManyDeviceInputEnvelope
    set?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    disconnect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    delete?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    connect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    update?: UserDeviceHistoryUpdateWithWhereUniqueWithoutDeviceInput | UserDeviceHistoryUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: UserDeviceHistoryUpdateManyWithWhereWithoutDeviceInput | UserDeviceHistoryUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: UserDeviceHistoryScalarWhereInput | UserDeviceHistoryScalarWhereInput[]
  }

  export type InterventionUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<InterventionCreateWithoutDeviceInput, InterventionUncheckedCreateWithoutDeviceInput> | InterventionCreateWithoutDeviceInput[] | InterventionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutDeviceInput | InterventionCreateOrConnectWithoutDeviceInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutDeviceInput | InterventionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: InterventionCreateManyDeviceInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutDeviceInput | InterventionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutDeviceInput | InterventionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<SaleCreateWithoutDeviceInput, SaleUncheckedCreateWithoutDeviceInput> | SaleCreateWithoutDeviceInput[] | SaleUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutDeviceInput | SaleCreateOrConnectWithoutDeviceInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutDeviceInput | SaleUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: SaleCreateManyDeviceInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutDeviceInput | SaleUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutDeviceInput | SaleUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type UserDeviceHistoryUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<UserDeviceHistoryCreateWithoutDeviceInput, UserDeviceHistoryUncheckedCreateWithoutDeviceInput> | UserDeviceHistoryCreateWithoutDeviceInput[] | UserDeviceHistoryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserDeviceHistoryCreateOrConnectWithoutDeviceInput | UserDeviceHistoryCreateOrConnectWithoutDeviceInput[]
    upsert?: UserDeviceHistoryUpsertWithWhereUniqueWithoutDeviceInput | UserDeviceHistoryUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: UserDeviceHistoryCreateManyDeviceInputEnvelope
    set?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    disconnect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    delete?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    connect?: UserDeviceHistoryWhereUniqueInput | UserDeviceHistoryWhereUniqueInput[]
    update?: UserDeviceHistoryUpdateWithWhereUniqueWithoutDeviceInput | UserDeviceHistoryUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: UserDeviceHistoryUpdateManyWithWhereWithoutDeviceInput | UserDeviceHistoryUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: UserDeviceHistoryScalarWhereInput | UserDeviceHistoryScalarWhereInput[]
  }

  export type InterventionUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<InterventionCreateWithoutDeviceInput, InterventionUncheckedCreateWithoutDeviceInput> | InterventionCreateWithoutDeviceInput[] | InterventionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutDeviceInput | InterventionCreateOrConnectWithoutDeviceInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutDeviceInput | InterventionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: InterventionCreateManyDeviceInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutDeviceInput | InterventionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutDeviceInput | InterventionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type DeviceCreateNestedOneWithoutUserDeviceHistoriesInput = {
    create?: XOR<DeviceCreateWithoutUserDeviceHistoriesInput, DeviceUncheckedCreateWithoutUserDeviceHistoriesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutUserDeviceHistoriesInput
    connect?: DeviceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserDeviceHistoriesInput = {
    create?: XOR<UserCreateWithoutUserDeviceHistoriesInput, UserUncheckedCreateWithoutUserDeviceHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDeviceHistoriesInput
    connect?: UserWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutUserDeviceHistoriesNestedInput = {
    create?: XOR<DeviceCreateWithoutUserDeviceHistoriesInput, DeviceUncheckedCreateWithoutUserDeviceHistoriesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutUserDeviceHistoriesInput
    upsert?: DeviceUpsertWithoutUserDeviceHistoriesInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutUserDeviceHistoriesInput, DeviceUpdateWithoutUserDeviceHistoriesInput>, DeviceUncheckedUpdateWithoutUserDeviceHistoriesInput>
  }

  export type UserUpdateOneRequiredWithoutUserDeviceHistoriesNestedInput = {
    create?: XOR<UserCreateWithoutUserDeviceHistoriesInput, UserUncheckedCreateWithoutUserDeviceHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDeviceHistoriesInput
    upsert?: UserUpsertWithoutUserDeviceHistoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserDeviceHistoriesInput, UserUpdateWithoutUserDeviceHistoriesInput>, UserUncheckedUpdateWithoutUserDeviceHistoriesInput>
  }

  export type ZoneCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<ZoneCreateWithoutEnvironmentInput, ZoneUncheckedCreateWithoutEnvironmentInput> | ZoneCreateWithoutEnvironmentInput[] | ZoneUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutEnvironmentInput | ZoneCreateOrConnectWithoutEnvironmentInput[]
    createMany?: ZoneCreateManyEnvironmentInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type ObstacleCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<ObstacleCreateWithoutEnvironmentInput, ObstacleUncheckedCreateWithoutEnvironmentInput> | ObstacleCreateWithoutEnvironmentInput[] | ObstacleUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ObstacleCreateOrConnectWithoutEnvironmentInput | ObstacleCreateOrConnectWithoutEnvironmentInput[]
    createMany?: ObstacleCreateManyEnvironmentInputEnvelope
    connect?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
  }

  export type EnvUserCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<EnvUserCreateWithoutEnvironmentInput, EnvUserUncheckedCreateWithoutEnvironmentInput> | EnvUserCreateWithoutEnvironmentInput[] | EnvUserUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: EnvUserCreateOrConnectWithoutEnvironmentInput | EnvUserCreateOrConnectWithoutEnvironmentInput[]
    createMany?: EnvUserCreateManyEnvironmentInputEnvelope
    connect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
  }

  export type ItineraryCreateNestedManyWithoutEnvironementInput = {
    create?: XOR<ItineraryCreateWithoutEnvironementInput, ItineraryUncheckedCreateWithoutEnvironementInput> | ItineraryCreateWithoutEnvironementInput[] | ItineraryUncheckedCreateWithoutEnvironementInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutEnvironementInput | ItineraryCreateOrConnectWithoutEnvironementInput[]
    createMany?: ItineraryCreateManyEnvironementInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type ZoneUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<ZoneCreateWithoutEnvironmentInput, ZoneUncheckedCreateWithoutEnvironmentInput> | ZoneCreateWithoutEnvironmentInput[] | ZoneUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutEnvironmentInput | ZoneCreateOrConnectWithoutEnvironmentInput[]
    createMany?: ZoneCreateManyEnvironmentInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type ObstacleUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<ObstacleCreateWithoutEnvironmentInput, ObstacleUncheckedCreateWithoutEnvironmentInput> | ObstacleCreateWithoutEnvironmentInput[] | ObstacleUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ObstacleCreateOrConnectWithoutEnvironmentInput | ObstacleCreateOrConnectWithoutEnvironmentInput[]
    createMany?: ObstacleCreateManyEnvironmentInputEnvelope
    connect?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
  }

  export type EnvUserUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<EnvUserCreateWithoutEnvironmentInput, EnvUserUncheckedCreateWithoutEnvironmentInput> | EnvUserCreateWithoutEnvironmentInput[] | EnvUserUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: EnvUserCreateOrConnectWithoutEnvironmentInput | EnvUserCreateOrConnectWithoutEnvironmentInput[]
    createMany?: EnvUserCreateManyEnvironmentInputEnvelope
    connect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
  }

  export type ItineraryUncheckedCreateNestedManyWithoutEnvironementInput = {
    create?: XOR<ItineraryCreateWithoutEnvironementInput, ItineraryUncheckedCreateWithoutEnvironementInput> | ItineraryCreateWithoutEnvironementInput[] | ItineraryUncheckedCreateWithoutEnvironementInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutEnvironementInput | ItineraryCreateOrConnectWithoutEnvironementInput[]
    createMany?: ItineraryCreateManyEnvironementInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type ZoneUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<ZoneCreateWithoutEnvironmentInput, ZoneUncheckedCreateWithoutEnvironmentInput> | ZoneCreateWithoutEnvironmentInput[] | ZoneUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutEnvironmentInput | ZoneCreateOrConnectWithoutEnvironmentInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutEnvironmentInput | ZoneUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: ZoneCreateManyEnvironmentInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutEnvironmentInput | ZoneUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutEnvironmentInput | ZoneUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type ObstacleUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<ObstacleCreateWithoutEnvironmentInput, ObstacleUncheckedCreateWithoutEnvironmentInput> | ObstacleCreateWithoutEnvironmentInput[] | ObstacleUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ObstacleCreateOrConnectWithoutEnvironmentInput | ObstacleCreateOrConnectWithoutEnvironmentInput[]
    upsert?: ObstacleUpsertWithWhereUniqueWithoutEnvironmentInput | ObstacleUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: ObstacleCreateManyEnvironmentInputEnvelope
    set?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
    disconnect?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
    delete?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
    connect?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
    update?: ObstacleUpdateWithWhereUniqueWithoutEnvironmentInput | ObstacleUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: ObstacleUpdateManyWithWhereWithoutEnvironmentInput | ObstacleUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: ObstacleScalarWhereInput | ObstacleScalarWhereInput[]
  }

  export type EnvUserUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<EnvUserCreateWithoutEnvironmentInput, EnvUserUncheckedCreateWithoutEnvironmentInput> | EnvUserCreateWithoutEnvironmentInput[] | EnvUserUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: EnvUserCreateOrConnectWithoutEnvironmentInput | EnvUserCreateOrConnectWithoutEnvironmentInput[]
    upsert?: EnvUserUpsertWithWhereUniqueWithoutEnvironmentInput | EnvUserUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: EnvUserCreateManyEnvironmentInputEnvelope
    set?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    disconnect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    delete?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    connect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    update?: EnvUserUpdateWithWhereUniqueWithoutEnvironmentInput | EnvUserUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: EnvUserUpdateManyWithWhereWithoutEnvironmentInput | EnvUserUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: EnvUserScalarWhereInput | EnvUserScalarWhereInput[]
  }

  export type ItineraryUpdateManyWithoutEnvironementNestedInput = {
    create?: XOR<ItineraryCreateWithoutEnvironementInput, ItineraryUncheckedCreateWithoutEnvironementInput> | ItineraryCreateWithoutEnvironementInput[] | ItineraryUncheckedCreateWithoutEnvironementInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutEnvironementInput | ItineraryCreateOrConnectWithoutEnvironementInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutEnvironementInput | ItineraryUpsertWithWhereUniqueWithoutEnvironementInput[]
    createMany?: ItineraryCreateManyEnvironementInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutEnvironementInput | ItineraryUpdateWithWhereUniqueWithoutEnvironementInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutEnvironementInput | ItineraryUpdateManyWithWhereWithoutEnvironementInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type ZoneUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<ZoneCreateWithoutEnvironmentInput, ZoneUncheckedCreateWithoutEnvironmentInput> | ZoneCreateWithoutEnvironmentInput[] | ZoneUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutEnvironmentInput | ZoneCreateOrConnectWithoutEnvironmentInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutEnvironmentInput | ZoneUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: ZoneCreateManyEnvironmentInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutEnvironmentInput | ZoneUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutEnvironmentInput | ZoneUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type ObstacleUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<ObstacleCreateWithoutEnvironmentInput, ObstacleUncheckedCreateWithoutEnvironmentInput> | ObstacleCreateWithoutEnvironmentInput[] | ObstacleUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: ObstacleCreateOrConnectWithoutEnvironmentInput | ObstacleCreateOrConnectWithoutEnvironmentInput[]
    upsert?: ObstacleUpsertWithWhereUniqueWithoutEnvironmentInput | ObstacleUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: ObstacleCreateManyEnvironmentInputEnvelope
    set?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
    disconnect?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
    delete?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
    connect?: ObstacleWhereUniqueInput | ObstacleWhereUniqueInput[]
    update?: ObstacleUpdateWithWhereUniqueWithoutEnvironmentInput | ObstacleUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: ObstacleUpdateManyWithWhereWithoutEnvironmentInput | ObstacleUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: ObstacleScalarWhereInput | ObstacleScalarWhereInput[]
  }

  export type EnvUserUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<EnvUserCreateWithoutEnvironmentInput, EnvUserUncheckedCreateWithoutEnvironmentInput> | EnvUserCreateWithoutEnvironmentInput[] | EnvUserUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: EnvUserCreateOrConnectWithoutEnvironmentInput | EnvUserCreateOrConnectWithoutEnvironmentInput[]
    upsert?: EnvUserUpsertWithWhereUniqueWithoutEnvironmentInput | EnvUserUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: EnvUserCreateManyEnvironmentInputEnvelope
    set?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    disconnect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    delete?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    connect?: EnvUserWhereUniqueInput | EnvUserWhereUniqueInput[]
    update?: EnvUserUpdateWithWhereUniqueWithoutEnvironmentInput | EnvUserUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: EnvUserUpdateManyWithWhereWithoutEnvironmentInput | EnvUserUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: EnvUserScalarWhereInput | EnvUserScalarWhereInput[]
  }

  export type ItineraryUncheckedUpdateManyWithoutEnvironementNestedInput = {
    create?: XOR<ItineraryCreateWithoutEnvironementInput, ItineraryUncheckedCreateWithoutEnvironementInput> | ItineraryCreateWithoutEnvironementInput[] | ItineraryUncheckedCreateWithoutEnvironementInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutEnvironementInput | ItineraryCreateOrConnectWithoutEnvironementInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutEnvironementInput | ItineraryUpsertWithWhereUniqueWithoutEnvironementInput[]
    createMany?: ItineraryCreateManyEnvironementInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutEnvironementInput | ItineraryUpdateWithWhereUniqueWithoutEnvironementInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutEnvironementInput | ItineraryUpdateManyWithWhereWithoutEnvironementInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEnvUsersInput = {
    create?: XOR<UserCreateWithoutEnvUsersInput, UserUncheckedCreateWithoutEnvUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnvUsersInput
    connect?: UserWhereUniqueInput
  }

  export type EnvironmentCreateNestedOneWithoutEnvUsersInput = {
    create?: XOR<EnvironmentCreateWithoutEnvUsersInput, EnvironmentUncheckedCreateWithoutEnvUsersInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutEnvUsersInput
    connect?: EnvironmentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEnvUsersNestedInput = {
    create?: XOR<UserCreateWithoutEnvUsersInput, UserUncheckedCreateWithoutEnvUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnvUsersInput
    upsert?: UserUpsertWithoutEnvUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnvUsersInput, UserUpdateWithoutEnvUsersInput>, UserUncheckedUpdateWithoutEnvUsersInput>
  }

  export type EnvironmentUpdateOneRequiredWithoutEnvUsersNestedInput = {
    create?: XOR<EnvironmentCreateWithoutEnvUsersInput, EnvironmentUncheckedCreateWithoutEnvUsersInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutEnvUsersInput
    upsert?: EnvironmentUpsertWithoutEnvUsersInput
    connect?: EnvironmentWhereUniqueInput
    update?: XOR<XOR<EnvironmentUpdateToOneWithWhereWithoutEnvUsersInput, EnvironmentUpdateWithoutEnvUsersInput>, EnvironmentUncheckedUpdateWithoutEnvUsersInput>
  }

  export type EnvironmentCreateNestedOneWithoutZonesInput = {
    create?: XOR<EnvironmentCreateWithoutZonesInput, EnvironmentUncheckedCreateWithoutZonesInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutZonesInput
    connect?: EnvironmentWhereUniqueInput
  }

  export type POICreateNestedManyWithoutZoneInput = {
    create?: XOR<POICreateWithoutZoneInput, POIUncheckedCreateWithoutZoneInput> | POICreateWithoutZoneInput[] | POIUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: POICreateOrConnectWithoutZoneInput | POICreateOrConnectWithoutZoneInput[]
    createMany?: POICreateManyZoneInputEnvelope
    connect?: POIWhereUniqueInput | POIWhereUniqueInput[]
  }

  export type POIUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<POICreateWithoutZoneInput, POIUncheckedCreateWithoutZoneInput> | POICreateWithoutZoneInput[] | POIUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: POICreateOrConnectWithoutZoneInput | POICreateOrConnectWithoutZoneInput[]
    createMany?: POICreateManyZoneInputEnvelope
    connect?: POIWhereUniqueInput | POIWhereUniqueInput[]
  }

  export type EnumZoneTypeFieldUpdateOperationsInput = {
    set?: $Enums.ZoneType
  }

  export type EnvironmentUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<EnvironmentCreateWithoutZonesInput, EnvironmentUncheckedCreateWithoutZonesInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutZonesInput
    upsert?: EnvironmentUpsertWithoutZonesInput
    connect?: EnvironmentWhereUniqueInput
    update?: XOR<XOR<EnvironmentUpdateToOneWithWhereWithoutZonesInput, EnvironmentUpdateWithoutZonesInput>, EnvironmentUncheckedUpdateWithoutZonesInput>
  }

  export type POIUpdateManyWithoutZoneNestedInput = {
    create?: XOR<POICreateWithoutZoneInput, POIUncheckedCreateWithoutZoneInput> | POICreateWithoutZoneInput[] | POIUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: POICreateOrConnectWithoutZoneInput | POICreateOrConnectWithoutZoneInput[]
    upsert?: POIUpsertWithWhereUniqueWithoutZoneInput | POIUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: POICreateManyZoneInputEnvelope
    set?: POIWhereUniqueInput | POIWhereUniqueInput[]
    disconnect?: POIWhereUniqueInput | POIWhereUniqueInput[]
    delete?: POIWhereUniqueInput | POIWhereUniqueInput[]
    connect?: POIWhereUniqueInput | POIWhereUniqueInput[]
    update?: POIUpdateWithWhereUniqueWithoutZoneInput | POIUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: POIUpdateManyWithWhereWithoutZoneInput | POIUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: POIScalarWhereInput | POIScalarWhereInput[]
  }

  export type POIUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<POICreateWithoutZoneInput, POIUncheckedCreateWithoutZoneInput> | POICreateWithoutZoneInput[] | POIUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: POICreateOrConnectWithoutZoneInput | POICreateOrConnectWithoutZoneInput[]
    upsert?: POIUpsertWithWhereUniqueWithoutZoneInput | POIUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: POICreateManyZoneInputEnvelope
    set?: POIWhereUniqueInput | POIWhereUniqueInput[]
    disconnect?: POIWhereUniqueInput | POIWhereUniqueInput[]
    delete?: POIWhereUniqueInput | POIWhereUniqueInput[]
    connect?: POIWhereUniqueInput | POIWhereUniqueInput[]
    update?: POIUpdateWithWhereUniqueWithoutZoneInput | POIUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: POIUpdateManyWithWhereWithoutZoneInput | POIUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: POIScalarWhereInput | POIScalarWhereInput[]
  }

  export type ZoneCreateNestedOneWithoutPoisInput = {
    create?: XOR<ZoneCreateWithoutPoisInput, ZoneUncheckedCreateWithoutPoisInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutPoisInput
    connect?: ZoneWhereUniqueInput
  }

  export type EnumPOICategoryFieldUpdateOperationsInput = {
    set?: $Enums.POICategory
  }

  export type ZoneUpdateOneRequiredWithoutPoisNestedInput = {
    create?: XOR<ZoneCreateWithoutPoisInput, ZoneUncheckedCreateWithoutPoisInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutPoisInput
    upsert?: ZoneUpsertWithoutPoisInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutPoisInput, ZoneUpdateWithoutPoisInput>, ZoneUncheckedUpdateWithoutPoisInput>
  }

  export type EnvironmentCreateNestedOneWithoutObstaclesInput = {
    create?: XOR<EnvironmentCreateWithoutObstaclesInput, EnvironmentUncheckedCreateWithoutObstaclesInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutObstaclesInput
    connect?: EnvironmentWhereUniqueInput
  }

  export type EnvironmentUpdateOneRequiredWithoutObstaclesNestedInput = {
    create?: XOR<EnvironmentCreateWithoutObstaclesInput, EnvironmentUncheckedCreateWithoutObstaclesInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutObstaclesInput
    upsert?: EnvironmentUpsertWithoutObstaclesInput
    connect?: EnvironmentWhereUniqueInput
    update?: XOR<XOR<EnvironmentUpdateToOneWithWhereWithoutObstaclesInput, EnvironmentUpdateWithoutObstaclesInput>, EnvironmentUncheckedUpdateWithoutObstaclesInput>
  }

  export type EnvironmentCreateNestedOneWithoutRoutesInput = {
    create?: XOR<EnvironmentCreateWithoutRoutesInput, EnvironmentUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutRoutesInput
    connect?: EnvironmentWhereUniqueInput
  }

  export type EnvironmentUpdateOneRequiredWithoutRoutesNestedInput = {
    create?: XOR<EnvironmentCreateWithoutRoutesInput, EnvironmentUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutRoutesInput
    upsert?: EnvironmentUpsertWithoutRoutesInput
    connect?: EnvironmentWhereUniqueInput
    update?: XOR<XOR<EnvironmentUpdateToOneWithWhereWithoutRoutesInput, EnvironmentUpdateWithoutRoutesInput>, EnvironmentUncheckedUpdateWithoutRoutesInput>
  }

  export type EndUserCreateNestedOneWithoutHelpRequestsInput = {
    create?: XOR<EndUserCreateWithoutHelpRequestsInput, EndUserUncheckedCreateWithoutHelpRequestsInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutHelpRequestsInput
    connect?: EndUserWhereUniqueInput
  }

  export type HelperCreateNestedOneWithoutHelpRequestsInput = {
    create?: XOR<HelperCreateWithoutHelpRequestsInput, HelperUncheckedCreateWithoutHelpRequestsInput>
    connectOrCreate?: HelperCreateOrConnectWithoutHelpRequestsInput
    connect?: HelperWhereUniqueInput
  }

  export type EndUserUpdateOneRequiredWithoutHelpRequestsNestedInput = {
    create?: XOR<EndUserCreateWithoutHelpRequestsInput, EndUserUncheckedCreateWithoutHelpRequestsInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutHelpRequestsInput
    upsert?: EndUserUpsertWithoutHelpRequestsInput
    connect?: EndUserWhereUniqueInput
    update?: XOR<XOR<EndUserUpdateToOneWithWhereWithoutHelpRequestsInput, EndUserUpdateWithoutHelpRequestsInput>, EndUserUncheckedUpdateWithoutHelpRequestsInput>
  }

  export type HelperUpdateOneRequiredWithoutHelpRequestsNestedInput = {
    create?: XOR<HelperCreateWithoutHelpRequestsInput, HelperUncheckedCreateWithoutHelpRequestsInput>
    connectOrCreate?: HelperCreateOrConnectWithoutHelpRequestsInput
    upsert?: HelperUpsertWithoutHelpRequestsInput
    connect?: HelperWhereUniqueInput
    update?: XOR<XOR<HelperUpdateToOneWithWhereWithoutHelpRequestsInput, HelperUpdateWithoutHelpRequestsInput>, HelperUncheckedUpdateWithoutHelpRequestsInput>
  }

  export type DeviceCreateNestedOneWithoutSalesInput = {
    create?: XOR<DeviceCreateWithoutSalesInput, DeviceUncheckedCreateWithoutSalesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSalesInput
    connect?: DeviceWhereUniqueInput
  }

  export type EndUserCreateNestedOneWithoutMySalesInput = {
    create?: XOR<EndUserCreateWithoutMySalesInput, EndUserUncheckedCreateWithoutMySalesInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutMySalesInput
    connect?: EndUserWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<DeviceCreateWithoutSalesInput, DeviceUncheckedCreateWithoutSalesInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSalesInput
    upsert?: DeviceUpsertWithoutSalesInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutSalesInput, DeviceUpdateWithoutSalesInput>, DeviceUncheckedUpdateWithoutSalesInput>
  }

  export type EndUserUpdateOneRequiredWithoutMySalesNestedInput = {
    create?: XOR<EndUserCreateWithoutMySalesInput, EndUserUncheckedCreateWithoutMySalesInput>
    connectOrCreate?: EndUserCreateOrConnectWithoutMySalesInput
    upsert?: EndUserUpsertWithoutMySalesInput
    connect?: EndUserWhereUniqueInput
    update?: XOR<XOR<EndUserUpdateToOneWithWhereWithoutMySalesInput, EndUserUpdateWithoutMySalesInput>, EndUserUncheckedUpdateWithoutMySalesInput>
  }

  export type DeviceCreateNestedOneWithoutInterventionsInput = {
    create?: XOR<DeviceCreateWithoutInterventionsInput, DeviceUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutInterventionsInput
    connect?: DeviceWhereUniqueInput
  }

  export type MaintainerCreateNestedOneWithoutInterventionsInput = {
    create?: XOR<MaintainerCreateWithoutInterventionsInput, MaintainerUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutInterventionsInput
    connect?: MaintainerWhereUniqueInput
  }

  export type EnumInterventionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InterventionType
  }

  export type DeviceUpdateOneRequiredWithoutInterventionsNestedInput = {
    create?: XOR<DeviceCreateWithoutInterventionsInput, DeviceUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutInterventionsInput
    upsert?: DeviceUpsertWithoutInterventionsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutInterventionsInput, DeviceUpdateWithoutInterventionsInput>, DeviceUncheckedUpdateWithoutInterventionsInput>
  }

  export type MaintainerUpdateOneRequiredWithoutInterventionsNestedInput = {
    create?: XOR<MaintainerCreateWithoutInterventionsInput, MaintainerUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: MaintainerCreateOrConnectWithoutInterventionsInput
    upsert?: MaintainerUpsertWithoutInterventionsInput
    connect?: MaintainerWhereUniqueInput
    update?: XOR<XOR<MaintainerUpdateToOneWithWhereWithoutInterventionsInput, MaintainerUpdateWithoutInterventionsInput>, MaintainerUncheckedUpdateWithoutInterventionsInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusFilter<$PrismaModel> | $Enums.DeviceStatus
  }

  export type NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumZoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeFilter<$PrismaModel> | $Enums.ZoneType
  }

  export type NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZoneTypeFilter<$PrismaModel>
    _max?: NestedEnumZoneTypeFilter<$PrismaModel>
  }

  export type NestedEnumPOICategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.POICategory | EnumPOICategoryFieldRefInput<$PrismaModel>
    in?: $Enums.POICategory[] | ListEnumPOICategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.POICategory[] | ListEnumPOICategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPOICategoryFilter<$PrismaModel> | $Enums.POICategory
  }

  export type NestedEnumPOICategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POICategory | EnumPOICategoryFieldRefInput<$PrismaModel>
    in?: $Enums.POICategory[] | ListEnumPOICategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.POICategory[] | ListEnumPOICategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPOICategoryWithAggregatesFilter<$PrismaModel> | $Enums.POICategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOICategoryFilter<$PrismaModel>
    _max?: NestedEnumPOICategoryFilter<$PrismaModel>
  }

  export type NestedEnumInterventionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionType | EnumInterventionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionTypeFilter<$PrismaModel> | $Enums.InterventionType
  }

  export type NestedEnumInterventionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionType | EnumInterventionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InterventionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionTypeFilter<$PrismaModel>
    _max?: NestedEnumInterventionTypeFilter<$PrismaModel>
  }

  export type AdminCreateWithoutUserInput = {
    role: $Enums.Role
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: number
    role: $Enums.Role
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type EndUserCreateWithoutUserInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    helper?: HelperCreateNestedOneWithoutEndUsersInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    helpRequests?: HelpRequestCreateNestedManyWithoutUserInput
    mySales?: SaleCreateNestedManyWithoutBuyerInput
  }

  export type EndUserUncheckedCreateWithoutUserInput = {
    id?: number
    helperId?: number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    helpRequests?: HelpRequestUncheckedCreateNestedManyWithoutUserInput
    mySales?: SaleUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type EndUserCreateOrConnectWithoutUserInput = {
    where: EndUserWhereUniqueInput
    create: XOR<EndUserCreateWithoutUserInput, EndUserUncheckedCreateWithoutUserInput>
  }

  export type HelperCreateWithoutUserInput = {
    endUsers?: EndUserCreateNestedManyWithoutHelperInput
    helpRequests?: HelpRequestCreateNestedManyWithoutHelperInput
  }

  export type HelperUncheckedCreateWithoutUserInput = {
    id?: number
    endUsers?: EndUserUncheckedCreateNestedManyWithoutHelperInput
    helpRequests?: HelpRequestUncheckedCreateNestedManyWithoutHelperInput
  }

  export type HelperCreateOrConnectWithoutUserInput = {
    where: HelperWhereUniqueInput
    create: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput>
  }

  export type CommercialCreateWithoutUserInput = {

  }

  export type CommercialUncheckedCreateWithoutUserInput = {
    id?: number
  }

  export type CommercialCreateOrConnectWithoutUserInput = {
    where: CommercialWhereUniqueInput
    create: XOR<CommercialCreateWithoutUserInput, CommercialUncheckedCreateWithoutUserInput>
  }

  export type MaintainerCreateWithoutUserInput = {
    interventions?: InterventionCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerUncheckedCreateWithoutUserInput = {
    id?: number
    interventions?: InterventionUncheckedCreateNestedManyWithoutMaintainerInput
  }

  export type MaintainerCreateOrConnectWithoutUserInput = {
    where: MaintainerWhereUniqueInput
    create: XOR<MaintainerCreateWithoutUserInput, MaintainerUncheckedCreateWithoutUserInput>
  }

  export type DeciderCreateWithoutUserInput = {

  }

  export type DeciderUncheckedCreateWithoutUserInput = {
    id?: number
  }

  export type DeciderCreateOrConnectWithoutUserInput = {
    where: DeciderWhereUniqueInput
    create: XOR<DeciderCreateWithoutUserInput, DeciderUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserDeviceHistoryCreateWithoutUserInput = {
    useDate?: Date | string
    device: DeviceCreateNestedOneWithoutUserDeviceHistoriesInput
  }

  export type UserDeviceHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    deviceId: number
    useDate?: Date | string
  }

  export type UserDeviceHistoryCreateOrConnectWithoutUserInput = {
    where: UserDeviceHistoryWhereUniqueInput
    create: XOR<UserDeviceHistoryCreateWithoutUserInput, UserDeviceHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserDeviceHistoryCreateManyUserInputEnvelope = {
    data: UserDeviceHistoryCreateManyUserInput | UserDeviceHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EnvUserCreateWithoutUserInput = {
    environment: EnvironmentCreateNestedOneWithoutEnvUsersInput
  }

  export type EnvUserUncheckedCreateWithoutUserInput = {
    id?: number
    envId: number
  }

  export type EnvUserCreateOrConnectWithoutUserInput = {
    where: EnvUserWhereUniqueInput
    create: XOR<EnvUserCreateWithoutUserInput, EnvUserUncheckedCreateWithoutUserInput>
  }

  export type EnvUserCreateManyUserInputEnvelope = {
    data: EnvUserCreateManyUserInput | EnvUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutUserInput = {
    createdAt?: Date | string
    details: string
  }

  export type LogUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    details: string
  }

  export type LogCreateOrConnectWithoutUserInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogCreateManyUserInputEnvelope = {
    data: LogCreateManyUserInput | LogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    firstname?: string | null
    lastname?: string | null
    phonenumber?: string | null
    address: string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    firstname?: string | null
    lastname?: string | null
    phonenumber?: string | null
    address: string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type EndUserUpsertWithoutUserInput = {
    update: XOR<EndUserUpdateWithoutUserInput, EndUserUncheckedUpdateWithoutUserInput>
    create: XOR<EndUserCreateWithoutUserInput, EndUserUncheckedCreateWithoutUserInput>
    where?: EndUserWhereInput
  }

  export type EndUserUpdateToOneWithWhereWithoutUserInput = {
    where?: EndUserWhereInput
    data: XOR<EndUserUpdateWithoutUserInput, EndUserUncheckedUpdateWithoutUserInput>
  }

  export type EndUserUpdateWithoutUserInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helper?: HelperUpdateOneWithoutEndUsersNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    helpRequests?: HelpRequestUpdateManyWithoutUserNestedInput
    mySales?: SaleUpdateManyWithoutBuyerNestedInput
  }

  export type EndUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    helperId?: NullableIntFieldUpdateOperationsInput | number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    helpRequests?: HelpRequestUncheckedUpdateManyWithoutUserNestedInput
    mySales?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type HelperUpsertWithoutUserInput = {
    update: XOR<HelperUpdateWithoutUserInput, HelperUncheckedUpdateWithoutUserInput>
    create: XOR<HelperCreateWithoutUserInput, HelperUncheckedCreateWithoutUserInput>
    where?: HelperWhereInput
  }

  export type HelperUpdateToOneWithWhereWithoutUserInput = {
    where?: HelperWhereInput
    data: XOR<HelperUpdateWithoutUserInput, HelperUncheckedUpdateWithoutUserInput>
  }

  export type HelperUpdateWithoutUserInput = {
    endUsers?: EndUserUpdateManyWithoutHelperNestedInput
    helpRequests?: HelpRequestUpdateManyWithoutHelperNestedInput
  }

  export type HelperUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    endUsers?: EndUserUncheckedUpdateManyWithoutHelperNestedInput
    helpRequests?: HelpRequestUncheckedUpdateManyWithoutHelperNestedInput
  }

  export type CommercialUpsertWithoutUserInput = {
    update: XOR<CommercialUpdateWithoutUserInput, CommercialUncheckedUpdateWithoutUserInput>
    create: XOR<CommercialCreateWithoutUserInput, CommercialUncheckedCreateWithoutUserInput>
    where?: CommercialWhereInput
  }

  export type CommercialUpdateToOneWithWhereWithoutUserInput = {
    where?: CommercialWhereInput
    data: XOR<CommercialUpdateWithoutUserInput, CommercialUncheckedUpdateWithoutUserInput>
  }

  export type CommercialUpdateWithoutUserInput = {

  }

  export type CommercialUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type MaintainerUpsertWithoutUserInput = {
    update: XOR<MaintainerUpdateWithoutUserInput, MaintainerUncheckedUpdateWithoutUserInput>
    create: XOR<MaintainerCreateWithoutUserInput, MaintainerUncheckedCreateWithoutUserInput>
    where?: MaintainerWhereInput
  }

  export type MaintainerUpdateToOneWithWhereWithoutUserInput = {
    where?: MaintainerWhereInput
    data: XOR<MaintainerUpdateWithoutUserInput, MaintainerUncheckedUpdateWithoutUserInput>
  }

  export type MaintainerUpdateWithoutUserInput = {
    interventions?: InterventionUpdateManyWithoutMaintainerNestedInput
  }

  export type MaintainerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    interventions?: InterventionUncheckedUpdateManyWithoutMaintainerNestedInput
  }

  export type DeciderUpsertWithoutUserInput = {
    update: XOR<DeciderUpdateWithoutUserInput, DeciderUncheckedUpdateWithoutUserInput>
    create: XOR<DeciderCreateWithoutUserInput, DeciderUncheckedCreateWithoutUserInput>
    where?: DeciderWhereInput
  }

  export type DeciderUpdateToOneWithWhereWithoutUserInput = {
    where?: DeciderWhereInput
    data: XOR<DeciderUpdateWithoutUserInput, DeciderUncheckedUpdateWithoutUserInput>
  }

  export type DeciderUpdateWithoutUserInput = {

  }

  export type DeciderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: IntFilter<"Notification"> | number
  }

  export type UserDeviceHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDeviceHistoryWhereUniqueInput
    update: XOR<UserDeviceHistoryUpdateWithoutUserInput, UserDeviceHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserDeviceHistoryCreateWithoutUserInput, UserDeviceHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserDeviceHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDeviceHistoryWhereUniqueInput
    data: XOR<UserDeviceHistoryUpdateWithoutUserInput, UserDeviceHistoryUncheckedUpdateWithoutUserInput>
  }

  export type UserDeviceHistoryUpdateManyWithWhereWithoutUserInput = {
    where: UserDeviceHistoryScalarWhereInput
    data: XOR<UserDeviceHistoryUpdateManyMutationInput, UserDeviceHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserDeviceHistoryScalarWhereInput = {
    AND?: UserDeviceHistoryScalarWhereInput | UserDeviceHistoryScalarWhereInput[]
    OR?: UserDeviceHistoryScalarWhereInput[]
    NOT?: UserDeviceHistoryScalarWhereInput | UserDeviceHistoryScalarWhereInput[]
    id?: IntFilter<"UserDeviceHistory"> | number
    deviceId?: IntFilter<"UserDeviceHistory"> | number
    userId?: IntFilter<"UserDeviceHistory"> | number
    useDate?: DateTimeFilter<"UserDeviceHistory"> | Date | string
  }

  export type EnvUserUpsertWithWhereUniqueWithoutUserInput = {
    where: EnvUserWhereUniqueInput
    update: XOR<EnvUserUpdateWithoutUserInput, EnvUserUncheckedUpdateWithoutUserInput>
    create: XOR<EnvUserCreateWithoutUserInput, EnvUserUncheckedCreateWithoutUserInput>
  }

  export type EnvUserUpdateWithWhereUniqueWithoutUserInput = {
    where: EnvUserWhereUniqueInput
    data: XOR<EnvUserUpdateWithoutUserInput, EnvUserUncheckedUpdateWithoutUserInput>
  }

  export type EnvUserUpdateManyWithWhereWithoutUserInput = {
    where: EnvUserScalarWhereInput
    data: XOR<EnvUserUpdateManyMutationInput, EnvUserUncheckedUpdateManyWithoutUserInput>
  }

  export type EnvUserScalarWhereInput = {
    AND?: EnvUserScalarWhereInput | EnvUserScalarWhereInput[]
    OR?: EnvUserScalarWhereInput[]
    NOT?: EnvUserScalarWhereInput | EnvUserScalarWhereInput[]
    id?: IntFilter<"EnvUser"> | number
    userId?: IntFilter<"EnvUser"> | number
    envId?: IntFilter<"EnvUser"> | number
  }

  export type LogUpsertWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogUpdateWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
  }

  export type LogUpdateManyWithWhereWithoutUserInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutUserInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: IntFilter<"Log"> | number
    userId?: IntFilter<"Log"> | number
    createdAt?: DateTimeFilter<"Log"> | Date | string
    details?: StringFilter<"Log"> | string
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutProfileInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAdminInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutEndUserInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEndUserInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEndUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEndUserInput, UserUncheckedCreateWithoutEndUserInput>
  }

  export type HelperCreateWithoutEndUsersInput = {
    user: UserCreateNestedOneWithoutHelperInput
    helpRequests?: HelpRequestCreateNestedManyWithoutHelperInput
  }

  export type HelperUncheckedCreateWithoutEndUsersInput = {
    id?: number
    userId: number
    helpRequests?: HelpRequestUncheckedCreateNestedManyWithoutHelperInput
  }

  export type HelperCreateOrConnectWithoutEndUsersInput = {
    where: HelperWhereUniqueInput
    create: XOR<HelperCreateWithoutEndUsersInput, HelperUncheckedCreateWithoutEndUsersInput>
  }

  export type DeviceCreateWithoutUserInput = {
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    sales?: SaleCreateNestedManyWithoutDeviceInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutDeviceInput
    interventions?: InterventionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutDeviceInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutDeviceInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutUserInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceCreateManyUserInputEnvelope = {
    data: DeviceCreateManyUserInput | DeviceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HelpRequestCreateWithoutUserInput = {
    helper: HelperCreateNestedOneWithoutHelpRequestsInput
  }

  export type HelpRequestUncheckedCreateWithoutUserInput = {
    id?: number
    helperId: number
  }

  export type HelpRequestCreateOrConnectWithoutUserInput = {
    where: HelpRequestWhereUniqueInput
    create: XOR<HelpRequestCreateWithoutUserInput, HelpRequestUncheckedCreateWithoutUserInput>
  }

  export type HelpRequestCreateManyUserInputEnvelope = {
    data: HelpRequestCreateManyUserInput | HelpRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutBuyerInput = {
    createdAt?: Date | string
    device: DeviceCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutBuyerInput = {
    id?: number
    deviceId: number
    createdAt?: Date | string
  }

  export type SaleCreateOrConnectWithoutBuyerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput>
  }

  export type SaleCreateManyBuyerInputEnvelope = {
    data: SaleCreateManyBuyerInput | SaleCreateManyBuyerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEndUserInput = {
    update: XOR<UserUpdateWithoutEndUserInput, UserUncheckedUpdateWithoutEndUserInput>
    create: XOR<UserCreateWithoutEndUserInput, UserUncheckedCreateWithoutEndUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEndUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEndUserInput, UserUncheckedUpdateWithoutEndUserInput>
  }

  export type UserUpdateWithoutEndUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEndUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type HelperUpsertWithoutEndUsersInput = {
    update: XOR<HelperUpdateWithoutEndUsersInput, HelperUncheckedUpdateWithoutEndUsersInput>
    create: XOR<HelperCreateWithoutEndUsersInput, HelperUncheckedCreateWithoutEndUsersInput>
    where?: HelperWhereInput
  }

  export type HelperUpdateToOneWithWhereWithoutEndUsersInput = {
    where?: HelperWhereInput
    data: XOR<HelperUpdateWithoutEndUsersInput, HelperUncheckedUpdateWithoutEndUsersInput>
  }

  export type HelperUpdateWithoutEndUsersInput = {
    user?: UserUpdateOneRequiredWithoutHelperNestedInput
    helpRequests?: HelpRequestUpdateManyWithoutHelperNestedInput
  }

  export type HelperUncheckedUpdateWithoutEndUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    helpRequests?: HelpRequestUncheckedUpdateManyWithoutHelperNestedInput
  }

  export type DeviceUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
  }

  export type DeviceUpdateManyWithWhereWithoutUserInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    OR?: DeviceScalarWhereInput[]
    NOT?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    id?: IntFilter<"Device"> | number
    type?: StringFilter<"Device"> | string
    version?: StringFilter<"Device"> | string
    macAdr?: StringNullableFilter<"Device"> | string | null
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    battery?: IntFilter<"Device"> | number
    lastPos?: JsonNullableFilter<"Device">
    price?: IntNullableFilter<"Device"> | number | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    userId?: IntNullableFilter<"Device"> | number | null
  }

  export type HelpRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: HelpRequestWhereUniqueInput
    update: XOR<HelpRequestUpdateWithoutUserInput, HelpRequestUncheckedUpdateWithoutUserInput>
    create: XOR<HelpRequestCreateWithoutUserInput, HelpRequestUncheckedCreateWithoutUserInput>
  }

  export type HelpRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: HelpRequestWhereUniqueInput
    data: XOR<HelpRequestUpdateWithoutUserInput, HelpRequestUncheckedUpdateWithoutUserInput>
  }

  export type HelpRequestUpdateManyWithWhereWithoutUserInput = {
    where: HelpRequestScalarWhereInput
    data: XOR<HelpRequestUpdateManyMutationInput, HelpRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type HelpRequestScalarWhereInput = {
    AND?: HelpRequestScalarWhereInput | HelpRequestScalarWhereInput[]
    OR?: HelpRequestScalarWhereInput[]
    NOT?: HelpRequestScalarWhereInput | HelpRequestScalarWhereInput[]
    id?: IntFilter<"HelpRequest"> | number
    userId?: IntFilter<"HelpRequest"> | number
    helperId?: IntFilter<"HelpRequest"> | number
  }

  export type SaleUpsertWithWhereUniqueWithoutBuyerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutBuyerInput, SaleUncheckedUpdateWithoutBuyerInput>
    create: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutBuyerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutBuyerInput, SaleUncheckedUpdateWithoutBuyerInput>
  }

  export type SaleUpdateManyWithWhereWithoutBuyerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutBuyerInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: IntFilter<"Sale"> | number
    deviceId?: IntFilter<"Sale"> | number
    buyerId?: IntFilter<"Sale"> | number
    createdAt?: DateTimeFilter<"Sale"> | Date | string
  }

  export type UserCreateWithoutHelperInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHelperInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHelperInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
  }

  export type EndUserCreateWithoutHelperInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEndUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    helpRequests?: HelpRequestCreateNestedManyWithoutUserInput
    mySales?: SaleCreateNestedManyWithoutBuyerInput
  }

  export type EndUserUncheckedCreateWithoutHelperInput = {
    id?: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userId: number
    createdAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    helpRequests?: HelpRequestUncheckedCreateNestedManyWithoutUserInput
    mySales?: SaleUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type EndUserCreateOrConnectWithoutHelperInput = {
    where: EndUserWhereUniqueInput
    create: XOR<EndUserCreateWithoutHelperInput, EndUserUncheckedCreateWithoutHelperInput>
  }

  export type EndUserCreateManyHelperInputEnvelope = {
    data: EndUserCreateManyHelperInput | EndUserCreateManyHelperInput[]
    skipDuplicates?: boolean
  }

  export type HelpRequestCreateWithoutHelperInput = {
    user: EndUserCreateNestedOneWithoutHelpRequestsInput
  }

  export type HelpRequestUncheckedCreateWithoutHelperInput = {
    id?: number
    userId: number
  }

  export type HelpRequestCreateOrConnectWithoutHelperInput = {
    where: HelpRequestWhereUniqueInput
    create: XOR<HelpRequestCreateWithoutHelperInput, HelpRequestUncheckedCreateWithoutHelperInput>
  }

  export type HelpRequestCreateManyHelperInputEnvelope = {
    data: HelpRequestCreateManyHelperInput | HelpRequestCreateManyHelperInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHelperInput = {
    update: XOR<UserUpdateWithoutHelperInput, UserUncheckedUpdateWithoutHelperInput>
    create: XOR<UserCreateWithoutHelperInput, UserUncheckedCreateWithoutHelperInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHelperInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHelperInput, UserUncheckedUpdateWithoutHelperInput>
  }

  export type UserUpdateWithoutHelperInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHelperInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EndUserUpsertWithWhereUniqueWithoutHelperInput = {
    where: EndUserWhereUniqueInput
    update: XOR<EndUserUpdateWithoutHelperInput, EndUserUncheckedUpdateWithoutHelperInput>
    create: XOR<EndUserCreateWithoutHelperInput, EndUserUncheckedCreateWithoutHelperInput>
  }

  export type EndUserUpdateWithWhereUniqueWithoutHelperInput = {
    where: EndUserWhereUniqueInput
    data: XOR<EndUserUpdateWithoutHelperInput, EndUserUncheckedUpdateWithoutHelperInput>
  }

  export type EndUserUpdateManyWithWhereWithoutHelperInput = {
    where: EndUserScalarWhereInput
    data: XOR<EndUserUpdateManyMutationInput, EndUserUncheckedUpdateManyWithoutHelperInput>
  }

  export type EndUserScalarWhereInput = {
    AND?: EndUserScalarWhereInput | EndUserScalarWhereInput[]
    OR?: EndUserScalarWhereInput[]
    NOT?: EndUserScalarWhereInput | EndUserScalarWhereInput[]
    id?: IntFilter<"EndUser"> | number
    helperId?: IntNullableFilter<"EndUser"> | number | null
    lastPos?: JsonNullableFilter<"EndUser">
    status?: StringFilter<"EndUser"> | string
    userId?: IntFilter<"EndUser"> | number
    createdAt?: DateTimeFilter<"EndUser"> | Date | string
  }

  export type HelpRequestUpsertWithWhereUniqueWithoutHelperInput = {
    where: HelpRequestWhereUniqueInput
    update: XOR<HelpRequestUpdateWithoutHelperInput, HelpRequestUncheckedUpdateWithoutHelperInput>
    create: XOR<HelpRequestCreateWithoutHelperInput, HelpRequestUncheckedCreateWithoutHelperInput>
  }

  export type HelpRequestUpdateWithWhereUniqueWithoutHelperInput = {
    where: HelpRequestWhereUniqueInput
    data: XOR<HelpRequestUpdateWithoutHelperInput, HelpRequestUncheckedUpdateWithoutHelperInput>
  }

  export type HelpRequestUpdateManyWithWhereWithoutHelperInput = {
    where: HelpRequestScalarWhereInput
    data: XOR<HelpRequestUpdateManyMutationInput, HelpRequestUncheckedUpdateManyWithoutHelperInput>
  }

  export type UserCreateWithoutCommercialInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommercialInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommercialInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommercialInput, UserUncheckedCreateWithoutCommercialInput>
  }

  export type UserUpsertWithoutCommercialInput = {
    update: XOR<UserUpdateWithoutCommercialInput, UserUncheckedUpdateWithoutCommercialInput>
    create: XOR<UserCreateWithoutCommercialInput, UserUncheckedCreateWithoutCommercialInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommercialInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommercialInput, UserUncheckedUpdateWithoutCommercialInput>
  }

  export type UserUpdateWithoutCommercialInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommercialInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutMaintainerInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMaintainerInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMaintainerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMaintainerInput, UserUncheckedCreateWithoutMaintainerInput>
  }

  export type InterventionCreateWithoutMaintainerInput = {
    type: $Enums.InterventionType
    isRemote: boolean
    planDate: Date | string
    device: DeviceCreateNestedOneWithoutInterventionsInput
  }

  export type InterventionUncheckedCreateWithoutMaintainerInput = {
    id?: number
    type: $Enums.InterventionType
    deviceId: number
    isRemote: boolean
    planDate: Date | string
  }

  export type InterventionCreateOrConnectWithoutMaintainerInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput>
  }

  export type InterventionCreateManyMaintainerInputEnvelope = {
    data: InterventionCreateManyMaintainerInput | InterventionCreateManyMaintainerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMaintainerInput = {
    update: XOR<UserUpdateWithoutMaintainerInput, UserUncheckedUpdateWithoutMaintainerInput>
    create: XOR<UserCreateWithoutMaintainerInput, UserUncheckedCreateWithoutMaintainerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMaintainerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMaintainerInput, UserUncheckedUpdateWithoutMaintainerInput>
  }

  export type UserUpdateWithoutMaintainerInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMaintainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type InterventionUpsertWithWhereUniqueWithoutMaintainerInput = {
    where: InterventionWhereUniqueInput
    update: XOR<InterventionUpdateWithoutMaintainerInput, InterventionUncheckedUpdateWithoutMaintainerInput>
    create: XOR<InterventionCreateWithoutMaintainerInput, InterventionUncheckedCreateWithoutMaintainerInput>
  }

  export type InterventionUpdateWithWhereUniqueWithoutMaintainerInput = {
    where: InterventionWhereUniqueInput
    data: XOR<InterventionUpdateWithoutMaintainerInput, InterventionUncheckedUpdateWithoutMaintainerInput>
  }

  export type InterventionUpdateManyWithWhereWithoutMaintainerInput = {
    where: InterventionScalarWhereInput
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyWithoutMaintainerInput>
  }

  export type InterventionScalarWhereInput = {
    AND?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    OR?: InterventionScalarWhereInput[]
    NOT?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    id?: IntFilter<"Intervention"> | number
    type?: EnumInterventionTypeFilter<"Intervention"> | $Enums.InterventionType
    deviceId?: IntFilter<"Intervention"> | number
    maintainerId?: IntFilter<"Intervention"> | number
    isRemote?: BoolFilter<"Intervention"> | boolean
    planDate?: DateTimeFilter<"Intervention"> | Date | string
  }

  export type UserCreateWithoutDeciderInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeciderInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeciderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeciderInput, UserUncheckedCreateWithoutDeciderInput>
  }

  export type UserUpsertWithoutDeciderInput = {
    update: XOR<UserUpdateWithoutDeciderInput, UserUncheckedUpdateWithoutDeciderInput>
    create: XOR<UserCreateWithoutDeciderInput, UserUncheckedCreateWithoutDeciderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeciderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeciderInput, UserUncheckedUpdateWithoutDeciderInput>
  }

  export type UserUpdateWithoutDeciderInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeciderInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EndUserCreateWithoutDevicesInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEndUserInput
    helper?: HelperCreateNestedOneWithoutEndUsersInput
    helpRequests?: HelpRequestCreateNestedManyWithoutUserInput
    mySales?: SaleCreateNestedManyWithoutBuyerInput
  }

  export type EndUserUncheckedCreateWithoutDevicesInput = {
    id?: number
    helperId?: number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userId: number
    createdAt?: Date | string
    helpRequests?: HelpRequestUncheckedCreateNestedManyWithoutUserInput
    mySales?: SaleUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type EndUserCreateOrConnectWithoutDevicesInput = {
    where: EndUserWhereUniqueInput
    create: XOR<EndUserCreateWithoutDevicesInput, EndUserUncheckedCreateWithoutDevicesInput>
  }

  export type SaleCreateWithoutDeviceInput = {
    createdAt?: Date | string
    buyer: EndUserCreateNestedOneWithoutMySalesInput
  }

  export type SaleUncheckedCreateWithoutDeviceInput = {
    id?: number
    buyerId: number
    createdAt?: Date | string
  }

  export type SaleCreateOrConnectWithoutDeviceInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutDeviceInput, SaleUncheckedCreateWithoutDeviceInput>
  }

  export type SaleCreateManyDeviceInputEnvelope = {
    data: SaleCreateManyDeviceInput | SaleCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type UserDeviceHistoryCreateWithoutDeviceInput = {
    useDate?: Date | string
    user: UserCreateNestedOneWithoutUserDeviceHistoriesInput
  }

  export type UserDeviceHistoryUncheckedCreateWithoutDeviceInput = {
    id?: number
    userId: number
    useDate?: Date | string
  }

  export type UserDeviceHistoryCreateOrConnectWithoutDeviceInput = {
    where: UserDeviceHistoryWhereUniqueInput
    create: XOR<UserDeviceHistoryCreateWithoutDeviceInput, UserDeviceHistoryUncheckedCreateWithoutDeviceInput>
  }

  export type UserDeviceHistoryCreateManyDeviceInputEnvelope = {
    data: UserDeviceHistoryCreateManyDeviceInput | UserDeviceHistoryCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type InterventionCreateWithoutDeviceInput = {
    type: $Enums.InterventionType
    isRemote: boolean
    planDate: Date | string
    maintainer: MaintainerCreateNestedOneWithoutInterventionsInput
  }

  export type InterventionUncheckedCreateWithoutDeviceInput = {
    id?: number
    type: $Enums.InterventionType
    maintainerId: number
    isRemote: boolean
    planDate: Date | string
  }

  export type InterventionCreateOrConnectWithoutDeviceInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutDeviceInput, InterventionUncheckedCreateWithoutDeviceInput>
  }

  export type InterventionCreateManyDeviceInputEnvelope = {
    data: InterventionCreateManyDeviceInput | InterventionCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type EndUserUpsertWithoutDevicesInput = {
    update: XOR<EndUserUpdateWithoutDevicesInput, EndUserUncheckedUpdateWithoutDevicesInput>
    create: XOR<EndUserCreateWithoutDevicesInput, EndUserUncheckedCreateWithoutDevicesInput>
    where?: EndUserWhereInput
  }

  export type EndUserUpdateToOneWithWhereWithoutDevicesInput = {
    where?: EndUserWhereInput
    data: XOR<EndUserUpdateWithoutDevicesInput, EndUserUncheckedUpdateWithoutDevicesInput>
  }

  export type EndUserUpdateWithoutDevicesInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEndUserNestedInput
    helper?: HelperUpdateOneWithoutEndUsersNestedInput
    helpRequests?: HelpRequestUpdateManyWithoutUserNestedInput
    mySales?: SaleUpdateManyWithoutBuyerNestedInput
  }

  export type EndUserUncheckedUpdateWithoutDevicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    helperId?: NullableIntFieldUpdateOperationsInput | number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpRequests?: HelpRequestUncheckedUpdateManyWithoutUserNestedInput
    mySales?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type SaleUpsertWithWhereUniqueWithoutDeviceInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutDeviceInput, SaleUncheckedUpdateWithoutDeviceInput>
    create: XOR<SaleCreateWithoutDeviceInput, SaleUncheckedCreateWithoutDeviceInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutDeviceInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutDeviceInput, SaleUncheckedUpdateWithoutDeviceInput>
  }

  export type SaleUpdateManyWithWhereWithoutDeviceInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutDeviceInput>
  }

  export type UserDeviceHistoryUpsertWithWhereUniqueWithoutDeviceInput = {
    where: UserDeviceHistoryWhereUniqueInput
    update: XOR<UserDeviceHistoryUpdateWithoutDeviceInput, UserDeviceHistoryUncheckedUpdateWithoutDeviceInput>
    create: XOR<UserDeviceHistoryCreateWithoutDeviceInput, UserDeviceHistoryUncheckedCreateWithoutDeviceInput>
  }

  export type UserDeviceHistoryUpdateWithWhereUniqueWithoutDeviceInput = {
    where: UserDeviceHistoryWhereUniqueInput
    data: XOR<UserDeviceHistoryUpdateWithoutDeviceInput, UserDeviceHistoryUncheckedUpdateWithoutDeviceInput>
  }

  export type UserDeviceHistoryUpdateManyWithWhereWithoutDeviceInput = {
    where: UserDeviceHistoryScalarWhereInput
    data: XOR<UserDeviceHistoryUpdateManyMutationInput, UserDeviceHistoryUncheckedUpdateManyWithoutDeviceInput>
  }

  export type InterventionUpsertWithWhereUniqueWithoutDeviceInput = {
    where: InterventionWhereUniqueInput
    update: XOR<InterventionUpdateWithoutDeviceInput, InterventionUncheckedUpdateWithoutDeviceInput>
    create: XOR<InterventionCreateWithoutDeviceInput, InterventionUncheckedCreateWithoutDeviceInput>
  }

  export type InterventionUpdateWithWhereUniqueWithoutDeviceInput = {
    where: InterventionWhereUniqueInput
    data: XOR<InterventionUpdateWithoutDeviceInput, InterventionUncheckedUpdateWithoutDeviceInput>
  }

  export type InterventionUpdateManyWithWhereWithoutDeviceInput = {
    where: InterventionScalarWhereInput
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyWithoutDeviceInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DeviceCreateWithoutUserDeviceHistoriesInput = {
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    user?: EndUserCreateNestedOneWithoutDevicesInput
    sales?: SaleCreateNestedManyWithoutDeviceInput
    interventions?: InterventionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutUserDeviceHistoriesInput = {
    id?: number
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    userId?: number | null
    sales?: SaleUncheckedCreateNestedManyWithoutDeviceInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutUserDeviceHistoriesInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutUserDeviceHistoriesInput, DeviceUncheckedCreateWithoutUserDeviceHistoriesInput>
  }

  export type UserCreateWithoutUserDeviceHistoriesInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserDeviceHistoriesInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserDeviceHistoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserDeviceHistoriesInput, UserUncheckedCreateWithoutUserDeviceHistoriesInput>
  }

  export type DeviceUpsertWithoutUserDeviceHistoriesInput = {
    update: XOR<DeviceUpdateWithoutUserDeviceHistoriesInput, DeviceUncheckedUpdateWithoutUserDeviceHistoriesInput>
    create: XOR<DeviceCreateWithoutUserDeviceHistoriesInput, DeviceUncheckedCreateWithoutUserDeviceHistoriesInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutUserDeviceHistoriesInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutUserDeviceHistoriesInput, DeviceUncheckedUpdateWithoutUserDeviceHistoriesInput>
  }

  export type DeviceUpdateWithoutUserDeviceHistoriesInput = {
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: EndUserUpdateOneWithoutDevicesNestedInput
    sales?: SaleUpdateManyWithoutDeviceNestedInput
    interventions?: InterventionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutUserDeviceHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: SaleUncheckedUpdateManyWithoutDeviceNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserUpsertWithoutUserDeviceHistoriesInput = {
    update: XOR<UserUpdateWithoutUserDeviceHistoriesInput, UserUncheckedUpdateWithoutUserDeviceHistoriesInput>
    create: XOR<UserCreateWithoutUserDeviceHistoriesInput, UserUncheckedCreateWithoutUserDeviceHistoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserDeviceHistoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserDeviceHistoriesInput, UserUncheckedUpdateWithoutUserDeviceHistoriesInput>
  }

  export type UserUpdateWithoutUserDeviceHistoriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserDeviceHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ZoneCreateWithoutEnvironmentInput = {
    name: string
    type: $Enums.ZoneType
    createdAt?: Date | string
    color: string
    icon: string
    cords: JsonNullValueInput | InputJsonValue
    pois?: POICreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    name: string
    type: $Enums.ZoneType
    createdAt?: Date | string
    color: string
    icon: string
    cords: JsonNullValueInput | InputJsonValue
    pois?: POIUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutEnvironmentInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutEnvironmentInput, ZoneUncheckedCreateWithoutEnvironmentInput>
  }

  export type ZoneCreateManyEnvironmentInputEnvelope = {
    data: ZoneCreateManyEnvironmentInput | ZoneCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type ObstacleCreateWithoutEnvironmentInput = {
    name: string
    description: string
    cords: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    name: string
    description: string
    cords: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleCreateOrConnectWithoutEnvironmentInput = {
    where: ObstacleWhereUniqueInput
    create: XOR<ObstacleCreateWithoutEnvironmentInput, ObstacleUncheckedCreateWithoutEnvironmentInput>
  }

  export type ObstacleCreateManyEnvironmentInputEnvelope = {
    data: ObstacleCreateManyEnvironmentInput | ObstacleCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type EnvUserCreateWithoutEnvironmentInput = {
    user: UserCreateNestedOneWithoutEnvUsersInput
  }

  export type EnvUserUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    userId: number
  }

  export type EnvUserCreateOrConnectWithoutEnvironmentInput = {
    where: EnvUserWhereUniqueInput
    create: XOR<EnvUserCreateWithoutEnvironmentInput, EnvUserUncheckedCreateWithoutEnvironmentInput>
  }

  export type EnvUserCreateManyEnvironmentInputEnvelope = {
    data: EnvUserCreateManyEnvironmentInput | EnvUserCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryCreateWithoutEnvironementInput = {
    startPoint: JsonNullValueInput | InputJsonValue
    endPoint: JsonNullValueInput | InputJsonValue
  }

  export type ItineraryUncheckedCreateWithoutEnvironementInput = {
    id?: number
    startPoint: JsonNullValueInput | InputJsonValue
    endPoint: JsonNullValueInput | InputJsonValue
  }

  export type ItineraryCreateOrConnectWithoutEnvironementInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutEnvironementInput, ItineraryUncheckedCreateWithoutEnvironementInput>
  }

  export type ItineraryCreateManyEnvironementInputEnvelope = {
    data: ItineraryCreateManyEnvironementInput | ItineraryCreateManyEnvironementInput[]
    skipDuplicates?: boolean
  }

  export type ZoneUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: ZoneWhereUniqueInput
    update: XOR<ZoneUpdateWithoutEnvironmentInput, ZoneUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<ZoneCreateWithoutEnvironmentInput, ZoneUncheckedCreateWithoutEnvironmentInput>
  }

  export type ZoneUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: ZoneWhereUniqueInput
    data: XOR<ZoneUpdateWithoutEnvironmentInput, ZoneUncheckedUpdateWithoutEnvironmentInput>
  }

  export type ZoneUpdateManyWithWhereWithoutEnvironmentInput = {
    where: ZoneScalarWhereInput
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type ZoneScalarWhereInput = {
    AND?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    OR?: ZoneScalarWhereInput[]
    NOT?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    id?: IntFilter<"Zone"> | number
    envId?: IntFilter<"Zone"> | number
    name?: StringFilter<"Zone"> | string
    type?: EnumZoneTypeFilter<"Zone"> | $Enums.ZoneType
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    color?: StringFilter<"Zone"> | string
    icon?: StringFilter<"Zone"> | string
    cords?: JsonFilter<"Zone">
  }

  export type ObstacleUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: ObstacleWhereUniqueInput
    update: XOR<ObstacleUpdateWithoutEnvironmentInput, ObstacleUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<ObstacleCreateWithoutEnvironmentInput, ObstacleUncheckedCreateWithoutEnvironmentInput>
  }

  export type ObstacleUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: ObstacleWhereUniqueInput
    data: XOR<ObstacleUpdateWithoutEnvironmentInput, ObstacleUncheckedUpdateWithoutEnvironmentInput>
  }

  export type ObstacleUpdateManyWithWhereWithoutEnvironmentInput = {
    where: ObstacleScalarWhereInput
    data: XOR<ObstacleUpdateManyMutationInput, ObstacleUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type ObstacleScalarWhereInput = {
    AND?: ObstacleScalarWhereInput | ObstacleScalarWhereInput[]
    OR?: ObstacleScalarWhereInput[]
    NOT?: ObstacleScalarWhereInput | ObstacleScalarWhereInput[]
    id?: IntFilter<"Obstacle"> | number
    envId?: IntFilter<"Obstacle"> | number
    name?: StringFilter<"Obstacle"> | string
    description?: StringFilter<"Obstacle"> | string
    cords?: JsonFilter<"Obstacle">
  }

  export type EnvUserUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: EnvUserWhereUniqueInput
    update: XOR<EnvUserUpdateWithoutEnvironmentInput, EnvUserUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<EnvUserCreateWithoutEnvironmentInput, EnvUserUncheckedCreateWithoutEnvironmentInput>
  }

  export type EnvUserUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: EnvUserWhereUniqueInput
    data: XOR<EnvUserUpdateWithoutEnvironmentInput, EnvUserUncheckedUpdateWithoutEnvironmentInput>
  }

  export type EnvUserUpdateManyWithWhereWithoutEnvironmentInput = {
    where: EnvUserScalarWhereInput
    data: XOR<EnvUserUpdateManyMutationInput, EnvUserUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type ItineraryUpsertWithWhereUniqueWithoutEnvironementInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutEnvironementInput, ItineraryUncheckedUpdateWithoutEnvironementInput>
    create: XOR<ItineraryCreateWithoutEnvironementInput, ItineraryUncheckedCreateWithoutEnvironementInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutEnvironementInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutEnvironementInput, ItineraryUncheckedUpdateWithoutEnvironementInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutEnvironementInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutEnvironementInput>
  }

  export type ItineraryScalarWhereInput = {
    AND?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    OR?: ItineraryScalarWhereInput[]
    NOT?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    id?: IntFilter<"Itinerary"> | number
    startPoint?: JsonFilter<"Itinerary">
    endPoint?: JsonFilter<"Itinerary">
    envId?: IntFilter<"Itinerary"> | number
  }

  export type UserCreateWithoutEnvUsersInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnvUsersInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnvUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnvUsersInput, UserUncheckedCreateWithoutEnvUsersInput>
  }

  export type EnvironmentCreateWithoutEnvUsersInput = {
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    zones?: ZoneCreateNestedManyWithoutEnvironmentInput
    obstacles?: ObstacleCreateNestedManyWithoutEnvironmentInput
    routes?: ItineraryCreateNestedManyWithoutEnvironementInput
  }

  export type EnvironmentUncheckedCreateWithoutEnvUsersInput = {
    id?: number
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    zones?: ZoneUncheckedCreateNestedManyWithoutEnvironmentInput
    obstacles?: ObstacleUncheckedCreateNestedManyWithoutEnvironmentInput
    routes?: ItineraryUncheckedCreateNestedManyWithoutEnvironementInput
  }

  export type EnvironmentCreateOrConnectWithoutEnvUsersInput = {
    where: EnvironmentWhereUniqueInput
    create: XOR<EnvironmentCreateWithoutEnvUsersInput, EnvironmentUncheckedCreateWithoutEnvUsersInput>
  }

  export type UserUpsertWithoutEnvUsersInput = {
    update: XOR<UserUpdateWithoutEnvUsersInput, UserUncheckedUpdateWithoutEnvUsersInput>
    create: XOR<UserCreateWithoutEnvUsersInput, UserUncheckedCreateWithoutEnvUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnvUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnvUsersInput, UserUncheckedUpdateWithoutEnvUsersInput>
  }

  export type UserUpdateWithoutEnvUsersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnvUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EnvironmentUpsertWithoutEnvUsersInput = {
    update: XOR<EnvironmentUpdateWithoutEnvUsersInput, EnvironmentUncheckedUpdateWithoutEnvUsersInput>
    create: XOR<EnvironmentCreateWithoutEnvUsersInput, EnvironmentUncheckedCreateWithoutEnvUsersInput>
    where?: EnvironmentWhereInput
  }

  export type EnvironmentUpdateToOneWithWhereWithoutEnvUsersInput = {
    where?: EnvironmentWhereInput
    data: XOR<EnvironmentUpdateWithoutEnvUsersInput, EnvironmentUncheckedUpdateWithoutEnvUsersInput>
  }

  export type EnvironmentUpdateWithoutEnvUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    zones?: ZoneUpdateManyWithoutEnvironmentNestedInput
    obstacles?: ObstacleUpdateManyWithoutEnvironmentNestedInput
    routes?: ItineraryUpdateManyWithoutEnvironementNestedInput
  }

  export type EnvironmentUncheckedUpdateWithoutEnvUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    zones?: ZoneUncheckedUpdateManyWithoutEnvironmentNestedInput
    obstacles?: ObstacleUncheckedUpdateManyWithoutEnvironmentNestedInput
    routes?: ItineraryUncheckedUpdateManyWithoutEnvironementNestedInput
  }

  export type EnvironmentCreateWithoutZonesInput = {
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    obstacles?: ObstacleCreateNestedManyWithoutEnvironmentInput
    envUsers?: EnvUserCreateNestedManyWithoutEnvironmentInput
    routes?: ItineraryCreateNestedManyWithoutEnvironementInput
  }

  export type EnvironmentUncheckedCreateWithoutZonesInput = {
    id?: number
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    obstacles?: ObstacleUncheckedCreateNestedManyWithoutEnvironmentInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutEnvironmentInput
    routes?: ItineraryUncheckedCreateNestedManyWithoutEnvironementInput
  }

  export type EnvironmentCreateOrConnectWithoutZonesInput = {
    where: EnvironmentWhereUniqueInput
    create: XOR<EnvironmentCreateWithoutZonesInput, EnvironmentUncheckedCreateWithoutZonesInput>
  }

  export type POICreateWithoutZoneInput = {
    name: string
    category: $Enums.POICategory
    description: string
    location: JsonNullValueInput | InputJsonValue
  }

  export type POIUncheckedCreateWithoutZoneInput = {
    id?: number
    name: string
    category: $Enums.POICategory
    description: string
    location: JsonNullValueInput | InputJsonValue
  }

  export type POICreateOrConnectWithoutZoneInput = {
    where: POIWhereUniqueInput
    create: XOR<POICreateWithoutZoneInput, POIUncheckedCreateWithoutZoneInput>
  }

  export type POICreateManyZoneInputEnvelope = {
    data: POICreateManyZoneInput | POICreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type EnvironmentUpsertWithoutZonesInput = {
    update: XOR<EnvironmentUpdateWithoutZonesInput, EnvironmentUncheckedUpdateWithoutZonesInput>
    create: XOR<EnvironmentCreateWithoutZonesInput, EnvironmentUncheckedCreateWithoutZonesInput>
    where?: EnvironmentWhereInput
  }

  export type EnvironmentUpdateToOneWithWhereWithoutZonesInput = {
    where?: EnvironmentWhereInput
    data: XOR<EnvironmentUpdateWithoutZonesInput, EnvironmentUncheckedUpdateWithoutZonesInput>
  }

  export type EnvironmentUpdateWithoutZonesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    obstacles?: ObstacleUpdateManyWithoutEnvironmentNestedInput
    envUsers?: EnvUserUpdateManyWithoutEnvironmentNestedInput
    routes?: ItineraryUpdateManyWithoutEnvironementNestedInput
  }

  export type EnvironmentUncheckedUpdateWithoutZonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    obstacles?: ObstacleUncheckedUpdateManyWithoutEnvironmentNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutEnvironmentNestedInput
    routes?: ItineraryUncheckedUpdateManyWithoutEnvironementNestedInput
  }

  export type POIUpsertWithWhereUniqueWithoutZoneInput = {
    where: POIWhereUniqueInput
    update: XOR<POIUpdateWithoutZoneInput, POIUncheckedUpdateWithoutZoneInput>
    create: XOR<POICreateWithoutZoneInput, POIUncheckedCreateWithoutZoneInput>
  }

  export type POIUpdateWithWhereUniqueWithoutZoneInput = {
    where: POIWhereUniqueInput
    data: XOR<POIUpdateWithoutZoneInput, POIUncheckedUpdateWithoutZoneInput>
  }

  export type POIUpdateManyWithWhereWithoutZoneInput = {
    where: POIScalarWhereInput
    data: XOR<POIUpdateManyMutationInput, POIUncheckedUpdateManyWithoutZoneInput>
  }

  export type POIScalarWhereInput = {
    AND?: POIScalarWhereInput | POIScalarWhereInput[]
    OR?: POIScalarWhereInput[]
    NOT?: POIScalarWhereInput | POIScalarWhereInput[]
    id?: IntFilter<"POI"> | number
    zoneId?: IntFilter<"POI"> | number
    name?: StringFilter<"POI"> | string
    category?: EnumPOICategoryFilter<"POI"> | $Enums.POICategory
    description?: StringFilter<"POI"> | string
    location?: JsonFilter<"POI">
  }

  export type ZoneCreateWithoutPoisInput = {
    name: string
    type: $Enums.ZoneType
    createdAt?: Date | string
    color: string
    icon: string
    cords: JsonNullValueInput | InputJsonValue
    environment: EnvironmentCreateNestedOneWithoutZonesInput
  }

  export type ZoneUncheckedCreateWithoutPoisInput = {
    id?: number
    envId: number
    name: string
    type: $Enums.ZoneType
    createdAt?: Date | string
    color: string
    icon: string
    cords: JsonNullValueInput | InputJsonValue
  }

  export type ZoneCreateOrConnectWithoutPoisInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutPoisInput, ZoneUncheckedCreateWithoutPoisInput>
  }

  export type ZoneUpsertWithoutPoisInput = {
    update: XOR<ZoneUpdateWithoutPoisInput, ZoneUncheckedUpdateWithoutPoisInput>
    create: XOR<ZoneCreateWithoutPoisInput, ZoneUncheckedCreateWithoutPoisInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutPoisInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutPoisInput, ZoneUncheckedUpdateWithoutPoisInput>
  }

  export type ZoneUpdateWithoutPoisInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    environment?: EnvironmentUpdateOneRequiredWithoutZonesNestedInput
  }

  export type ZoneUncheckedUpdateWithoutPoisInput = {
    id?: IntFieldUpdateOperationsInput | number
    envId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type EnvironmentCreateWithoutObstaclesInput = {
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    zones?: ZoneCreateNestedManyWithoutEnvironmentInput
    envUsers?: EnvUserCreateNestedManyWithoutEnvironmentInput
    routes?: ItineraryCreateNestedManyWithoutEnvironementInput
  }

  export type EnvironmentUncheckedCreateWithoutObstaclesInput = {
    id?: number
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    zones?: ZoneUncheckedCreateNestedManyWithoutEnvironmentInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutEnvironmentInput
    routes?: ItineraryUncheckedCreateNestedManyWithoutEnvironementInput
  }

  export type EnvironmentCreateOrConnectWithoutObstaclesInput = {
    where: EnvironmentWhereUniqueInput
    create: XOR<EnvironmentCreateWithoutObstaclesInput, EnvironmentUncheckedCreateWithoutObstaclesInput>
  }

  export type EnvironmentUpsertWithoutObstaclesInput = {
    update: XOR<EnvironmentUpdateWithoutObstaclesInput, EnvironmentUncheckedUpdateWithoutObstaclesInput>
    create: XOR<EnvironmentCreateWithoutObstaclesInput, EnvironmentUncheckedCreateWithoutObstaclesInput>
    where?: EnvironmentWhereInput
  }

  export type EnvironmentUpdateToOneWithWhereWithoutObstaclesInput = {
    where?: EnvironmentWhereInput
    data: XOR<EnvironmentUpdateWithoutObstaclesInput, EnvironmentUncheckedUpdateWithoutObstaclesInput>
  }

  export type EnvironmentUpdateWithoutObstaclesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    zones?: ZoneUpdateManyWithoutEnvironmentNestedInput
    envUsers?: EnvUserUpdateManyWithoutEnvironmentNestedInput
    routes?: ItineraryUpdateManyWithoutEnvironementNestedInput
  }

  export type EnvironmentUncheckedUpdateWithoutObstaclesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    zones?: ZoneUncheckedUpdateManyWithoutEnvironmentNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutEnvironmentNestedInput
    routes?: ItineraryUncheckedUpdateManyWithoutEnvironementNestedInput
  }

  export type EnvironmentCreateWithoutRoutesInput = {
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    zones?: ZoneCreateNestedManyWithoutEnvironmentInput
    obstacles?: ObstacleCreateNestedManyWithoutEnvironmentInput
    envUsers?: EnvUserCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentUncheckedCreateWithoutRoutesInput = {
    id?: number
    name: string
    address: string
    cords: JsonNullValueInput | InputJsonValue
    pathCartographie: string
    createdAt?: Date | string
    scale: number
    zones?: ZoneUncheckedCreateNestedManyWithoutEnvironmentInput
    obstacles?: ObstacleUncheckedCreateNestedManyWithoutEnvironmentInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentCreateOrConnectWithoutRoutesInput = {
    where: EnvironmentWhereUniqueInput
    create: XOR<EnvironmentCreateWithoutRoutesInput, EnvironmentUncheckedCreateWithoutRoutesInput>
  }

  export type EnvironmentUpsertWithoutRoutesInput = {
    update: XOR<EnvironmentUpdateWithoutRoutesInput, EnvironmentUncheckedUpdateWithoutRoutesInput>
    create: XOR<EnvironmentCreateWithoutRoutesInput, EnvironmentUncheckedCreateWithoutRoutesInput>
    where?: EnvironmentWhereInput
  }

  export type EnvironmentUpdateToOneWithWhereWithoutRoutesInput = {
    where?: EnvironmentWhereInput
    data: XOR<EnvironmentUpdateWithoutRoutesInput, EnvironmentUncheckedUpdateWithoutRoutesInput>
  }

  export type EnvironmentUpdateWithoutRoutesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    zones?: ZoneUpdateManyWithoutEnvironmentNestedInput
    obstacles?: ObstacleUpdateManyWithoutEnvironmentNestedInput
    envUsers?: EnvUserUpdateManyWithoutEnvironmentNestedInput
  }

  export type EnvironmentUncheckedUpdateWithoutRoutesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pathCartographie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scale?: IntFieldUpdateOperationsInput | number
    zones?: ZoneUncheckedUpdateManyWithoutEnvironmentNestedInput
    obstacles?: ObstacleUncheckedUpdateManyWithoutEnvironmentNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type EndUserCreateWithoutHelpRequestsInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEndUserInput
    helper?: HelperCreateNestedOneWithoutEndUsersInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    mySales?: SaleCreateNestedManyWithoutBuyerInput
  }

  export type EndUserUncheckedCreateWithoutHelpRequestsInput = {
    id?: number
    helperId?: number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userId: number
    createdAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    mySales?: SaleUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type EndUserCreateOrConnectWithoutHelpRequestsInput = {
    where: EndUserWhereUniqueInput
    create: XOR<EndUserCreateWithoutHelpRequestsInput, EndUserUncheckedCreateWithoutHelpRequestsInput>
  }

  export type HelperCreateWithoutHelpRequestsInput = {
    user: UserCreateNestedOneWithoutHelperInput
    endUsers?: EndUserCreateNestedManyWithoutHelperInput
  }

  export type HelperUncheckedCreateWithoutHelpRequestsInput = {
    id?: number
    userId: number
    endUsers?: EndUserUncheckedCreateNestedManyWithoutHelperInput
  }

  export type HelperCreateOrConnectWithoutHelpRequestsInput = {
    where: HelperWhereUniqueInput
    create: XOR<HelperCreateWithoutHelpRequestsInput, HelperUncheckedCreateWithoutHelpRequestsInput>
  }

  export type EndUserUpsertWithoutHelpRequestsInput = {
    update: XOR<EndUserUpdateWithoutHelpRequestsInput, EndUserUncheckedUpdateWithoutHelpRequestsInput>
    create: XOR<EndUserCreateWithoutHelpRequestsInput, EndUserUncheckedCreateWithoutHelpRequestsInput>
    where?: EndUserWhereInput
  }

  export type EndUserUpdateToOneWithWhereWithoutHelpRequestsInput = {
    where?: EndUserWhereInput
    data: XOR<EndUserUpdateWithoutHelpRequestsInput, EndUserUncheckedUpdateWithoutHelpRequestsInput>
  }

  export type EndUserUpdateWithoutHelpRequestsInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEndUserNestedInput
    helper?: HelperUpdateOneWithoutEndUsersNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    mySales?: SaleUpdateManyWithoutBuyerNestedInput
  }

  export type EndUserUncheckedUpdateWithoutHelpRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    helperId?: NullableIntFieldUpdateOperationsInput | number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    mySales?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type HelperUpsertWithoutHelpRequestsInput = {
    update: XOR<HelperUpdateWithoutHelpRequestsInput, HelperUncheckedUpdateWithoutHelpRequestsInput>
    create: XOR<HelperCreateWithoutHelpRequestsInput, HelperUncheckedCreateWithoutHelpRequestsInput>
    where?: HelperWhereInput
  }

  export type HelperUpdateToOneWithWhereWithoutHelpRequestsInput = {
    where?: HelperWhereInput
    data: XOR<HelperUpdateWithoutHelpRequestsInput, HelperUncheckedUpdateWithoutHelpRequestsInput>
  }

  export type HelperUpdateWithoutHelpRequestsInput = {
    user?: UserUpdateOneRequiredWithoutHelperNestedInput
    endUsers?: EndUserUpdateManyWithoutHelperNestedInput
  }

  export type HelperUncheckedUpdateWithoutHelpRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    endUsers?: EndUserUncheckedUpdateManyWithoutHelperNestedInput
  }

  export type DeviceCreateWithoutSalesInput = {
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    user?: EndUserCreateNestedOneWithoutDevicesInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutDeviceInput
    interventions?: InterventionCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutSalesInput = {
    id?: number
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    userId?: number | null
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutDeviceInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutSalesInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutSalesInput, DeviceUncheckedCreateWithoutSalesInput>
  }

  export type EndUserCreateWithoutMySalesInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEndUserInput
    helper?: HelperCreateNestedOneWithoutEndUsersInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    helpRequests?: HelpRequestCreateNestedManyWithoutUserInput
  }

  export type EndUserUncheckedCreateWithoutMySalesInput = {
    id?: number
    helperId?: number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userId: number
    createdAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    helpRequests?: HelpRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type EndUserCreateOrConnectWithoutMySalesInput = {
    where: EndUserWhereUniqueInput
    create: XOR<EndUserCreateWithoutMySalesInput, EndUserUncheckedCreateWithoutMySalesInput>
  }

  export type DeviceUpsertWithoutSalesInput = {
    update: XOR<DeviceUpdateWithoutSalesInput, DeviceUncheckedUpdateWithoutSalesInput>
    create: XOR<DeviceCreateWithoutSalesInput, DeviceUncheckedCreateWithoutSalesInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutSalesInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutSalesInput, DeviceUncheckedUpdateWithoutSalesInput>
  }

  export type DeviceUpdateWithoutSalesInput = {
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: EndUserUpdateOneWithoutDevicesNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutDeviceNestedInput
    interventions?: InterventionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutDeviceNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type EndUserUpsertWithoutMySalesInput = {
    update: XOR<EndUserUpdateWithoutMySalesInput, EndUserUncheckedUpdateWithoutMySalesInput>
    create: XOR<EndUserCreateWithoutMySalesInput, EndUserUncheckedCreateWithoutMySalesInput>
    where?: EndUserWhereInput
  }

  export type EndUserUpdateToOneWithWhereWithoutMySalesInput = {
    where?: EndUserWhereInput
    data: XOR<EndUserUpdateWithoutMySalesInput, EndUserUncheckedUpdateWithoutMySalesInput>
  }

  export type EndUserUpdateWithoutMySalesInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEndUserNestedInput
    helper?: HelperUpdateOneWithoutEndUsersNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    helpRequests?: HelpRequestUpdateManyWithoutUserNestedInput
  }

  export type EndUserUncheckedUpdateWithoutMySalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    helperId?: NullableIntFieldUpdateOperationsInput | number | null
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    helpRequests?: HelpRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DeviceCreateWithoutInterventionsInput = {
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    user?: EndUserCreateNestedOneWithoutDevicesInput
    sales?: SaleCreateNestedManyWithoutDeviceInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutInterventionsInput = {
    id?: number
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
    userId?: number | null
    sales?: SaleUncheckedCreateNestedManyWithoutDeviceInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutInterventionsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutInterventionsInput, DeviceUncheckedCreateWithoutInterventionsInput>
  }

  export type MaintainerCreateWithoutInterventionsInput = {
    user: UserCreateNestedOneWithoutMaintainerInput
  }

  export type MaintainerUncheckedCreateWithoutInterventionsInput = {
    id?: number
    userId: number
  }

  export type MaintainerCreateOrConnectWithoutInterventionsInput = {
    where: MaintainerWhereUniqueInput
    create: XOR<MaintainerCreateWithoutInterventionsInput, MaintainerUncheckedCreateWithoutInterventionsInput>
  }

  export type DeviceUpsertWithoutInterventionsInput = {
    update: XOR<DeviceUpdateWithoutInterventionsInput, DeviceUncheckedUpdateWithoutInterventionsInput>
    create: XOR<DeviceCreateWithoutInterventionsInput, DeviceUncheckedCreateWithoutInterventionsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutInterventionsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutInterventionsInput, DeviceUncheckedUpdateWithoutInterventionsInput>
  }

  export type DeviceUpdateWithoutInterventionsInput = {
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: EndUserUpdateOneWithoutDevicesNestedInput
    sales?: SaleUpdateManyWithoutDeviceNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutInterventionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: SaleUncheckedUpdateManyWithoutDeviceNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type MaintainerUpsertWithoutInterventionsInput = {
    update: XOR<MaintainerUpdateWithoutInterventionsInput, MaintainerUncheckedUpdateWithoutInterventionsInput>
    create: XOR<MaintainerCreateWithoutInterventionsInput, MaintainerUncheckedCreateWithoutInterventionsInput>
    where?: MaintainerWhereInput
  }

  export type MaintainerUpdateToOneWithWhereWithoutInterventionsInput = {
    where?: MaintainerWhereInput
    data: XOR<MaintainerUpdateWithoutInterventionsInput, MaintainerUncheckedUpdateWithoutInterventionsInput>
  }

  export type MaintainerUpdateWithoutInterventionsInput = {
    user?: UserUpdateOneRequiredWithoutMaintainerNestedInput
  }

  export type MaintainerUncheckedUpdateWithoutInterventionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutLogsInput = {
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminCreateNestedOneWithoutUserInput
    endUser?: EndUserCreateNestedOneWithoutUserInput
    helper?: HelperCreateNestedOneWithoutUserInput
    commercial?: CommercialCreateNestedOneWithoutUserInput
    maintainer?: MaintainerCreateNestedOneWithoutUserInput
    decider?: DeciderCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryCreateNestedManyWithoutUserInput
    envUsers?: EnvUserCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role | null
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    endUser?: EndUserUncheckedCreateNestedOneWithoutUserInput
    helper?: HelperUncheckedCreateNestedOneWithoutUserInput
    commercial?: CommercialUncheckedCreateNestedOneWithoutUserInput
    maintainer?: MaintainerUncheckedCreateNestedOneWithoutUserInput
    decider?: DeciderUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userDeviceHistories?: UserDeviceHistoryUncheckedCreateNestedManyWithoutUserInput
    envUsers?: EnvUserUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUpdateOneWithoutUserNestedInput
    endUser?: EndUserUpdateOneWithoutUserNestedInput
    helper?: HelperUpdateOneWithoutUserNestedInput
    commercial?: CommercialUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUpdateOneWithoutUserNestedInput
    decider?: DeciderUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    endUser?: EndUserUncheckedUpdateOneWithoutUserNestedInput
    helper?: HelperUncheckedUpdateOneWithoutUserNestedInput
    commercial?: CommercialUncheckedUpdateOneWithoutUserNestedInput
    maintainer?: MaintainerUncheckedUpdateOneWithoutUserNestedInput
    decider?: DeciderUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutUserNestedInput
    envUsers?: EnvUserUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type UserDeviceHistoryCreateManyUserInput = {
    id?: number
    deviceId: number
    useDate?: Date | string
  }

  export type EnvUserCreateManyUserInput = {
    id?: number
    envId: number
  }

  export type LogCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    details: string
  }

  export type NotificationUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceHistoryUpdateWithoutUserInput = {
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutUserDeviceHistoriesNestedInput
  }

  export type UserDeviceHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvUserUpdateWithoutUserInput = {
    environment?: EnvironmentUpdateOneRequiredWithoutEnvUsersNestedInput
  }

  export type EnvUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    envId?: IntFieldUpdateOperationsInput | number
  }

  export type EnvUserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    envId?: IntFieldUpdateOperationsInput | number
  }

  export type LogUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type LogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type LogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceCreateManyUserInput = {
    id?: number
    type: string
    version: string
    macAdr?: string | null
    status: $Enums.DeviceStatus
    battery: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    createdAt?: Date | string
  }

  export type HelpRequestCreateManyUserInput = {
    id?: number
    helperId: number
  }

  export type SaleCreateManyBuyerInput = {
    id?: number
    deviceId: number
    createdAt?: Date | string
  }

  export type DeviceUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutDeviceNestedInput
    userDeviceHistories?: UserDeviceHistoryUpdateManyWithoutDeviceNestedInput
    interventions?: InterventionUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutDeviceNestedInput
    userDeviceHistories?: UserDeviceHistoryUncheckedUpdateManyWithoutDeviceNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    macAdr?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    battery?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpRequestUpdateWithoutUserInput = {
    helper?: HelperUpdateOneRequiredWithoutHelpRequestsNestedInput
  }

  export type HelpRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    helperId?: IntFieldUpdateOperationsInput | number
  }

  export type HelpRequestUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    helperId?: IntFieldUpdateOperationsInput | number
  }

  export type SaleUpdateWithoutBuyerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutBuyerInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyWithoutBuyerInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EndUserCreateManyHelperInput = {
    id?: number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status: string
    userId: number
    createdAt?: Date | string
  }

  export type HelpRequestCreateManyHelperInput = {
    id?: number
    userId: number
  }

  export type EndUserUpdateWithoutHelperInput = {
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEndUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    helpRequests?: HelpRequestUpdateManyWithoutUserNestedInput
    mySales?: SaleUpdateManyWithoutBuyerNestedInput
  }

  export type EndUserUncheckedUpdateWithoutHelperInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    helpRequests?: HelpRequestUncheckedUpdateManyWithoutUserNestedInput
    mySales?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type EndUserUncheckedUpdateManyWithoutHelperInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastPos?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpRequestUpdateWithoutHelperInput = {
    user?: EndUserUpdateOneRequiredWithoutHelpRequestsNestedInput
  }

  export type HelpRequestUncheckedUpdateWithoutHelperInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type HelpRequestUncheckedUpdateManyWithoutHelperInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type InterventionCreateManyMaintainerInput = {
    id?: number
    type: $Enums.InterventionType
    deviceId: number
    isRemote: boolean
    planDate: Date | string
  }

  export type InterventionUpdateWithoutMaintainerInput = {
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutInterventionsNestedInput
  }

  export type InterventionUncheckedUpdateWithoutMaintainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    deviceId?: IntFieldUpdateOperationsInput | number
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUncheckedUpdateManyWithoutMaintainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    deviceId?: IntFieldUpdateOperationsInput | number
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyDeviceInput = {
    id?: number
    buyerId: number
    createdAt?: Date | string
  }

  export type UserDeviceHistoryCreateManyDeviceInput = {
    id?: number
    userId: number
    useDate?: Date | string
  }

  export type InterventionCreateManyDeviceInput = {
    id?: number
    type: $Enums.InterventionType
    maintainerId: number
    isRemote: boolean
    planDate: Date | string
  }

  export type SaleUpdateWithoutDeviceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: EndUserUpdateOneRequiredWithoutMySalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceHistoryUpdateWithoutDeviceInput = {
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserDeviceHistoriesNestedInput
  }

  export type UserDeviceHistoryUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceHistoryUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    useDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUpdateWithoutDeviceInput = {
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maintainer?: MaintainerUpdateOneRequiredWithoutInterventionsNestedInput
  }

  export type InterventionUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    maintainerId?: IntFieldUpdateOperationsInput | number
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    maintainerId?: IntFieldUpdateOperationsInput | number
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    planDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateManyEnvironmentInput = {
    id?: number
    name: string
    type: $Enums.ZoneType
    createdAt?: Date | string
    color: string
    icon: string
    cords: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleCreateManyEnvironmentInput = {
    id?: number
    name: string
    description: string
    cords: JsonNullValueInput | InputJsonValue
  }

  export type EnvUserCreateManyEnvironmentInput = {
    id?: number
    userId: number
  }

  export type ItineraryCreateManyEnvironementInput = {
    id?: number
    startPoint: JsonNullValueInput | InputJsonValue
    endPoint: JsonNullValueInput | InputJsonValue
  }

  export type ZoneUpdateWithoutEnvironmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pois?: POIUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
    pois?: POIUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleUpdateWithoutEnvironmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type ObstacleUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cords?: JsonNullValueInput | InputJsonValue
  }

  export type EnvUserUpdateWithoutEnvironmentInput = {
    user?: UserUpdateOneRequiredWithoutEnvUsersNestedInput
  }

  export type EnvUserUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type EnvUserUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ItineraryUpdateWithoutEnvironementInput = {
    startPoint?: JsonNullValueInput | InputJsonValue
    endPoint?: JsonNullValueInput | InputJsonValue
  }

  export type ItineraryUncheckedUpdateWithoutEnvironementInput = {
    id?: IntFieldUpdateOperationsInput | number
    startPoint?: JsonNullValueInput | InputJsonValue
    endPoint?: JsonNullValueInput | InputJsonValue
  }

  export type ItineraryUncheckedUpdateManyWithoutEnvironementInput = {
    id?: IntFieldUpdateOperationsInput | number
    startPoint?: JsonNullValueInput | InputJsonValue
    endPoint?: JsonNullValueInput | InputJsonValue
  }

  export type POICreateManyZoneInput = {
    id?: number
    name: string
    category: $Enums.POICategory
    description: string
    location: JsonNullValueInput | InputJsonValue
  }

  export type POIUpdateWithoutZoneInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumPOICategoryFieldUpdateOperationsInput | $Enums.POICategory
    description?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
  }

  export type POIUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumPOICategoryFieldUpdateOperationsInput | $Enums.POICategory
    description?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
  }

  export type POIUncheckedUpdateManyWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumPOICategoryFieldUpdateOperationsInput | $Enums.POICategory
    description?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}